{"version":3,"file":"forOf.js","sourceRoot":"","sources":["../../src/iterator/forOf.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAgB,iBAAiB,EAAE,MAAM,kBAAkB,CAAC;AACnE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,uBAAuB,CAAC;AAC1D,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,OAAO,EAAE,UAAU,EAAE,MAAM,YAAY,CAAC;AAExC,IAAI,WAAiC,CAAC;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCG;AACH,MAAM,UAAU,SAAS,CAAI,IAA+B,EAAE,UAA2E,EAAE,OAAa;IACpJ,IAAI,IAAI,EAAE;QACN,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YACnB,CAAC,WAAW,IAAI,CAAC,WAAW,GAAG,iBAAiB,CAAC,cAAc,mCAA2B,CAAC,CAAC,CAAC;YAC7F,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;SAC7D;QAED,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;YAClB,IAAI,GAAG,SAAY,CAAC;YACpB,IAAI,UAAU,SAAmB,CAAC;YAClC,IAAI;gBACA,IAAI,KAAK,GAAG,CAAC,CAAC;gBACd,OAAM,CAAC,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE;oBACrC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,IAAI,EAAE,UAAU,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;wBAC1E,MAAM;qBACT;oBAED,KAAK,EAAE,CAAC;iBACX;aACJ;YAAC,OAAO,MAAM,EAAE;gBACb,GAAG,GAAG,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC;gBACpB,IAAI,IAAI,CAAC,KAAK,EAAE;oBACZ,UAAU,GAAG,IAAI,CAAC;oBAClB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBACnB;aACJ;oBAAS;gBACN,IAAI;oBACA,IAAI,UAAU,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;wBACjC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;qBAC1C;iBACJ;wBAAS;oBACN,IAAI,GAAG,EAAE;wBACL,6CAA6C;wBAC7C,MAAM,GAAG,CAAC,CAAC,CAAC;qBACf;iBACJ;aACJ;SACJ;KACJ;AACL,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, createCachedValue } from \"../helpers/cache\";\r\nimport { CALL, DONE, VALUE } from \"../internal/constants\";\r\nimport { getKnownSymbol } from \"../symbol/symbol\";\r\nimport { WellKnownSymbols } from \"../symbol/well_known\";\r\nimport { isIterator } from \"./iterator\";\r\n\r\nlet _iterSymbol: ICachedValue<symbol>;\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEach}\r\n * you CAN stop / break the iteration by returning -1 from the`callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elements to the iterator, the actual behavior\r\n * will depend on the iterator imeplementation.\r\n *\r\n * If the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes preceedence.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols,\r\n * if you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOf expects a `synchronous` function.\r\n * iterForOf does not wait for promises. Make sure you are aware of the implications while using\r\n * promises (or async functions) as forEach callback.\r\n *\r\n * @since 0.4.2\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param callbackfn A `synchronous` function that accepts up to three arguments. iterForOf calls the\r\n * callbackfn function one time for each element returned by the iterator.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is\r\n * omitted, null or undefined the iterator will be used as the this value.\r\n * @throws Any exception thrown while processing the iterator\r\n * @example\r\n * ```ts\r\n * const items = {\r\n *     'item1': 'value1',\r\n *     'item2': 'value2',\r\n *     'item3': 'value3\r\n * };\r\n * const copyItems = [];\r\n *\r\n * iterForOf(items, (item) => {\r\n *   copyItems.push(item);\r\n *   // May return -1 to abort the iteration\r\n * });\r\n * ```\r\n */\r\nexport function iterForOf<T>(iter: Iterator<T> | Iterable<T>, callbackfn: (value: T, count?: number, iter?: Iterator<T>) => void | number, thisArg?: any): void {\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.iterator)));\r\n            iter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\r\n        }\r\n        \r\n        if (isIterator(iter)) {\r\n            let err: { e: any };\r\n            let iterResult: IteratorResult<T>;\r\n            try {\r\n                let count = 0;\r\n                while(!(iterResult = iter.next())[DONE]) {\r\n                    if (callbackfn[CALL](thisArg || iter, iterResult[VALUE], count, iter) === -1) {\r\n                        break;\r\n                    }\r\n        \r\n                    count++;\r\n                }\r\n            } catch (failed) {\r\n                err = { e: failed };\r\n                if (iter.throw) {\r\n                    iterResult = null;\r\n                    iter.throw(err);\r\n                }\r\n            } finally {\r\n                try {\r\n                    if (iterResult && !iterResult[DONE]) {\r\n                        iter.return && iter.return(iterResult);\r\n                    }\r\n                } finally {\r\n                    if (err) {\r\n                        // eslint-disable-next-line no-unsafe-finally\r\n                        throw err.e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}