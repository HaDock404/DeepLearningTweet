{"version":3,"file":"symbol.js","sourceRoot":"","sources":["../../src/symbol/symbol.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE, SYMBOL, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { polyGetKnownSymbol, polyNewSymbol, polySymbolFor, polySymbolKeyFor } from \"../polyfills/symbol\";\r\nimport { WellKnownSymbols, _wellKnownSymbolMap } from \"./well_known\";\r\nimport { _createIs } from \"../helpers/base\";\r\nimport { ILazyValue, _globalLazyTestHooks, _initTestHooks } from \"../helpers/lazy\";\r\nimport { safeGetLazy } from \"../helpers/safe_lazy\";\r\nimport { lazySafeGetInst } from \"../helpers/environment\";\r\n\r\nlet _symbol: ILazyValue<Symbol>;\r\nlet _symbolFor: ILazyValue<(key: string) => symbol>;\r\nlet _symbolKeyFor: ILazyValue<(sym: symbol) => string | undefined>;\r\n\r\nexport function _initSymbol() {\r\n    if (!_symbol || !_symbol.b) {\r\n        _symbol = lazySafeGetInst<Symbol>(SYMBOL);\r\n        _symbolFor = safeGetLazy<typeof Symbol.for>(() => (_symbol.v ? _symbol.v[\"for\"] : UNDEF_VALUE), UNDEF_VALUE);\r\n        _symbolKeyFor = safeGetLazy<typeof Symbol.keyFor>(() => (_symbol.v ? _symbol.v[\"keyFor\"] : UNDEF_VALUE), UNDEF_VALUE);\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the type of value is a symbol.\r\n * @group Symbol\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a symbol, false otherwise.\r\n */\r\nexport const isSymbol: (value: any) => value is symbol = (/*#__PURE__*/_createIs<symbol>(\"symbol\"));\r\n\r\n/**\r\n * Helper to identify whether the runtime support the Symbols either via native or an installed polyfill\r\n * @group Symbol\r\n * @returns true if Symbol's are support otherwise false\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function hasSymbol(): boolean {\r\n    return !!getSymbol();\r\n}\r\n\r\n/**\r\n * If Symbols are supported then attempt to return the named Symbol\r\n * @group Symbol\r\n * @returns The value of the named Symbol (if available)\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getSymbol(): Symbol {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    (!_symbol || _globalLazyTestHooks.lzy) && _initSymbol();\r\n    \r\n    return _symbol.v;\r\n}\r\n\r\n/**\r\n * If Symbols are supported then get the property of the global Symbol, if Symbol's are\r\n * not supported and noPoly is true it returns null. Used to access the well known symbols.\r\n * @group Symbol\r\n * @param name - The property name to return (if it exists) for Symbol\r\n * @param noPoly - Flag indicating whether to return a polyfill if symbols are not supported.\r\n * @returns The value of the property if present\r\n * @example\r\n * ```ts\r\n * // If Symbol is supported in the runtime\r\n * getKnownSymbol(\"toStringTag\") === Symbol.toStringTag;                // true\r\n * getKnownSymbol(WellKnownSymbols.toStringTag) === Symbol.toStringTag; // true\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getKnownSymbol<T = symbol>(name: string | WellKnownSymbols, noPoly?: boolean): T {\r\n    let knownName = _wellKnownSymbolMap[name];\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbol || _globalLazyTestHooks.lzy) && _initSymbol();\r\n\r\n    return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);\r\n}\r\n\r\n/**\r\n * Returns a new unique Symbol value. If noPoly is true and symbols are not supported\r\n * then this will return null.\r\n * @group Symbol\r\n * @param description Description of the new Symbol object.\r\n * @param noPoly - Flag indicating whether to return a polyfil if symbols are not supported.\r\n * @returns The new symbol\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function newSymbol(description?: string | number, noPoly?: boolean): symbol {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    // Cause lazy _symbol to get initialized\r\n    (!_symbol || _globalLazyTestHooks.lzy) && _initSymbol();\r\n\r\n    return _symbol.v ? (_symbol.v as any)(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);\r\n}\r\n\r\n/**\r\n * Returns a Symbol object from the global symbol registry matching the given key if found.\r\n * Otherwise, returns a new symbol with this key. This will always return a polyfill if symbols\r\n * are not supported.\r\n * @group Symbol\r\n * @param key key to search for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function symbolFor(key: string): symbol {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbolFor || !_symbol || _globalLazyTestHooks.lzy) && _initSymbol();\r\n\r\n    return (_symbolFor.v || polySymbolFor)(key);\r\n}\r\n\r\n/**\r\n * Returns a key from the global symbol registry matching the given Symbol if found.\r\n * Otherwise, returns a undefined. This will always attempt to lookup the polyfill\r\n * implementation if symbols are not supported\r\n * @group Symbol\r\n * @param sym Symbol to find the key for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function symbolKeyFor(sym: symbol): string | undefined {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbolKeyFor || !_symbol || _globalLazyTestHooks.lzy) && _initSymbol();\r\n\r\n    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);\r\n}\r\n"]}