{"version":3,"file":"symbol.js","sourceRoot":"","sources":["../../src/polyfills/symbol.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { WellKnownSymbols, _wellKnownSymbolMap } from \"../symbol/well_known\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { POLYFILL_TAG, SYMBOL, TO_STRING } from \"../internal/constants\";\r\nimport { objHasOwn } from \"../object/has_own\";\r\nimport { asString } from \"../string/as_string\";\r\nimport { _GlobalPolySymbols, _getGlobalConfig } from \"../internal/global\";\r\nimport { strSubstring } from \"../string/substring\";\r\nimport { objKeys } from \"../object/object\";\r\n\r\nconst UNIQUE_REGISTRY_ID = \"_urid\";\r\nlet _polySymbols: _GlobalPolySymbols;\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _globalSymbolRegistry(): _GlobalPolySymbols {\r\n    if (!_polySymbols) {\r\n        let gblCfg = _getGlobalConfig();\r\n        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s:{} };\r\n    }\r\n\r\n    return _polySymbols;\r\n}\r\n\r\nlet _wellKnownSymbolCache: { [key in keyof typeof WellKnownSymbols ]: symbol };\r\n\r\n/**\r\n * Returns a new (polyfill) Symbol object for the provided description that's guaranteed to be unique.\r\n * Symbols are often used to add unique property keys to an object that won't collide with keys any\r\n * other code might add to the object, and which are hidden from any mechanisms other code will\r\n * typically use to access the object. That enables a form of weak encapsulation, or a weak form of\r\n * information hiding.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param description - The description of the symbol\r\n * @returns A new polyfill version of a Symbol object\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyNewSymbol(description?: string | number): symbol {\r\n    let theSymbol: symbol = {\r\n        description: asString(description),\r\n        toString: () => SYMBOL + \"(\" + description + \")\"\r\n    } as symbol;\r\n\r\n    // Tag the symbol so we know it a polyfill\r\n    theSymbol[POLYFILL_TAG] = true;\r\n\r\n    return theSymbol;\r\n}\r\n\r\n/**\r\n * Returns a Symbol object from the global symbol registry matching the given key if found.\r\n * Otherwise, returns a new symbol with this key.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param key key to search for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polySymbolFor(key: string): symbol {\r\n    let registry = _globalSymbolRegistry();\r\n    if (!objHasOwn(registry.k, key)) {\r\n        let newSymbol = polyNewSymbol(key);\r\n        let regId = objKeys(registry.s).length;\r\n        newSymbol[UNIQUE_REGISTRY_ID] = () => regId + \"_\" + newSymbol[TO_STRING]();\r\n        registry.k[key] = newSymbol;\r\n        registry.s[newSymbol[UNIQUE_REGISTRY_ID]()] = asString(key);\r\n    }\r\n\r\n    return registry.k[key];\r\n}\r\n\r\n/**\r\n * Returns a key from the global symbol registry matching the given Symbol if found.\r\n * Otherwise, returns a undefined.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param sym Symbol to find the key for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polySymbolKeyFor(sym: symbol): string | undefined {\r\n    if (!sym || !sym[TO_STRING] || strSubstring(sym[TO_STRING](), 0, 6) != SYMBOL) {\r\n        throwTypeError((sym as any) + \" is not a symbol\");\r\n    }\r\n\r\n    const regId = sym[POLYFILL_TAG] && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();\r\n\r\n    return regId ? _globalSymbolRegistry().s[regId] : undefined;\r\n}\r\n\r\n/**\r\n * Returns the polyfill version of a well-known global symbol, this will only return\r\n * known values.\r\n * @example\r\n * ```ts\r\n * // Always returns the polyfill version, even if Symbols are supported in the runtime\r\n * polyGetKnownSymbol(\"toStringTag\") === polyGetKnownSymbol(\"toStringTag\");                // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) === polyGetKnownSymbol(\"toStringTag\"); // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== Symbol.toStringTag;                // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== Symbol.toStringTag; // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== polySymbolFor(\"toStringTag\");      // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== polySymbolFor(\"toStringTag\"); // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== polyNewSymbol(\"toStringTag\");      // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== polyNewSymbol(\"toStringTag\"); // true\r\n * ```\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param name - The property name to return (if it exists) for Symbol\r\n * @returns The value of the property if present\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyGetKnownSymbol(name: string | WellKnownSymbols): symbol {\r\n    !_wellKnownSymbolCache && (_wellKnownSymbolCache = {} as any);\r\n    let result: symbol;\r\n    let knownName: WellKnownSymbols = _wellKnownSymbolMap[name];\r\n    if (knownName) {\r\n        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + \".\" + knownName);\r\n    }\r\n\r\n    return result\r\n}\r\n"]}