{"version":3,"file":"readArgs.js","sourceRoot":"","sources":["../../src/funcs/readArgs.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAC1C,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AAClE,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC9C,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC9C,OAAO,EAAE,cAAc,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;AAE7D,OAAO,EAAgB,iBAAiB,EAAE,MAAM,kBAAkB,CAAC;AAEnE,IAAI,WAAiC,CAAC;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkEG;AACH,wBAAwB;AACxB,MAAM,UAAU,QAAQ,CAAU,OAAmC,EAAE,KAAc,EAAE,GAAY;IAE/F,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;QAC7B,uEAAuE;QACvE,2EAA2E;QAC3E,2BAA2B;QAC3B,CAAC,WAAW,IAAI,CAAC,WAAW,GAAG,iBAAiB,CAAC,SAAS,EAAE,IAAI,cAAc,mCAA2B,CAAC,CAAC,CAAC;QAC5G,IAAI,MAAM,GAAG,WAAW,CAAC,CAAC,IAAI,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QACrD,IAAI,MAAM,EAAE;YACR,IAAI,QAAM,GAAQ,EAAE,CAAC;YACrB,IAAI,MAAI,GAAG,CAAC,KAAK,KAAK,WAAW,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YAC5D,IAAI,IAAE,GAAG,GAAG,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC;YAClD,SAAS,CAAI,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,EAAE,UAAC,KAAK,EAAE,GAAG;gBAC3C,IAAI,IAAE,KAAK,WAAW,IAAI,GAAG,IAAI,IAAE,EAAE;oBACjC,OAAO,CAAC,CAAC,CAAC;iBACb;gBAED,IAAI,GAAG,IAAI,MAAI,EAAE;oBACb,QAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACtB;YACL,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,KAAK,KAAK,WAAW,IAAI,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,WAAW,IAAI,GAAG,IAAI,CAAC,CAAC,EAAE;gBAC5E,OAAO,QAAM,CAAC;aACjB;YAED,OAAO,GAAG,QAAM,CAAC;SACpB;KACJ;IAED,OAAO,QAAQ,CAAC,OAAuB,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;AACzD,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2023 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrSlice } from \"../array/slice\";\r\nimport { CALL, LENGTH, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { iterForOf } from \"../iterator/forOf\";\r\nimport { objHasOwn } from \"../object/has_own\";\r\nimport { getKnownSymbol, hasSymbol } from \"../symbol/symbol\";\r\nimport { WellKnownSymbols } from \"../symbol/well_known\"\r\nimport { ICachedValue, createCachedValue } from \"../helpers/cache\";\r\n\r\nlet _iterSymbol: ICachedValue<symbol>;\r\n\r\n/**\r\n * Read the arguments from the provided array, iterator /  or generator function\r\n * When processing an Iterable and a negative start or end is provided the entire\r\n * iterator will be processed into an array before applying the start / end restrictions\r\n * and when undefined or >= 0 any iterator will not be fully processed.\r\n * @param theArgs - The arguments to process, may be ArrayLike or an Iterable\r\n * @param start Zero-based index at which to start extraction, converted to an integer.\r\n * - Negative index counts back from the end of the array or iteration\r\n * - if start < 0, start + (array.length || iterator.count) is used.\r\n * - If start < -array.length or start is omitted, 0 is used.\r\n * - If start >= array.length, nothing is extracted.\r\n * @param end Zero-based index at which to end extraction, converted to an integer. readArgs() extracts\r\n * up to but not including end.\r\n * - Negative index counts back from the end of the array â€” if end < 0, end + array.length is used.\r\n * - If end < -array.length, 0 is used.\r\n * - If end >= array.length or end is omitted, array.length is used, causing all elements until the\r\n * end to be extracted.\r\n * - If end is positioned before or at start after normalization, nothing is extracted.\r\n * @returns A new array with the extracted elements\r\n * @example\r\n * ```ts\r\n * function myFunc<T>(firstArg: T, ...otherArgs) {\r\n *    // Read all of the arguments\r\n *    let allArgs = readArgs(arguments);\r\n *\r\n *    // Get all of the arguments after the first\r\n *    let optArgs = readArgs(arguments, 1);\r\n * }\r\n *\r\n * myFunc(\"Hello\");\r\n * myFunc(\"Hello\", \"Darkness\", \"my\", \"old\", \"friend\", \".\");\r\n *\r\n * function* myGenerator() {\r\n *   yield \"Hello\";\r\n *   yield \"Darkness\";\r\n *   yield \"my\";\r\n *   yield \"old\";\r\n *   yield \"friend\";\r\n * }\r\n *\r\n * function* myGenerator2() {\r\n *   yield \"I've\";\r\n *   yield \"come\";\r\n *   yield \"to\";\r\n *   yield \"talk\";\r\n *   yield \"with\";\r\n *   yield \"you\";\r\n *   yield \"again\";\r\n * }\r\n *\r\n * readArgs(myGenerator());\r\n * // [ \"Hello\", \"Darkness\", \"my\", \"old\", \"friend\"]);\r\n *\r\n * readArgs(myGenerator(), 1);\r\n * // [ \"Darkness\", \"my\", \"old\", \"friend\"]);\r\n *\r\n * readArgs(myGenerator2());\r\n * // [ \"I've\", \"come\", \"to\", \"talk\", \"with\", \"you\", \"again\" ]);\r\n *\r\n * readArgs(myGenerator2(), 0, -2);\r\n * // [ \"I've\", \"come\", \"to\", \"talk\", \"with\" ]);\r\n *\r\n * readArgs(myGenerator2(), -3, -2);\r\n * // [ \"with\" ]);\r\n\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function readArgs<T = any>(theArgs: ArrayLike<T> | Iterable<T>, start?: number, end?: number): T[] {\r\n    \r\n    if (!objHasOwn(theArgs, LENGTH)) {\r\n        // Does not contain a length property so lets check if it's an iterable\r\n        // IArgument is both ArrayLike and an iterable, so prefering to treat it as\r\n        // an array for performance\r\n        !_iterSymbol && (_iterSymbol = createCachedValue(hasSymbol() && getKnownSymbol(WellKnownSymbols.iterator)));\r\n        let iterFn = _iterSymbol.v && theArgs[_iterSymbol.v];\r\n        if (iterFn) {\r\n            let values: T[] = [];\r\n            let from = (start === UNDEF_VALUE || start < 0) ? 0 : start;\r\n            let to = end < 0 || start < 0 ? UNDEF_VALUE : end;\r\n            iterForOf<T>(iterFn[CALL](theArgs), (value, cnt) => {\r\n                if (to !== UNDEF_VALUE && cnt >= to) {\r\n                    return -1;\r\n                }\r\n\r\n                if (cnt >= from) {\r\n                    values.push(value);\r\n                }\r\n            });\r\n\r\n            if ((start === UNDEF_VALUE || start >= 0) && (end === UNDEF_VALUE || end >= 0)) {\r\n                return values;\r\n            }\r\n\r\n            theArgs = values;\r\n        }\r\n    }\r\n\r\n    return arrSlice(theArgs as ArrayLike<T>, start, end);\r\n}\r\n"]}