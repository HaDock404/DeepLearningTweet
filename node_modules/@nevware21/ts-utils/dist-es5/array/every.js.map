{"version":3,"file":"every.js","sourceRoot":"","sources":["../../src/array/every.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AACjD,OAAO,EAAE,eAAe,EAAE,MAAM,4BAA4B,CAAC;AAG7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2CG;AACH,MAAM,CAAC,IAAM,QAAQ,GAAuJ,aAAa,CAAA,eAAe,CAAC,OAAO,EAAE,QAAQ,CAAS,CAAC;AAEpO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA0DG;AACH,MAAM,CAAC,IAAM,SAAS,GAAiJ,aAAa,CAAA,eAAe,CAAC,QAAQ,EAAE,QAAQ,CAAS,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ArrProto } from \"../internal/constants\";\r\nimport { _unwrapFunction } from \"../internal/unwrapFunction\";\r\nimport { ArrPredicateCallbackFn, ArrPredicateCallbackFn2 } from \"./callbacks\";\r\n\r\n/**\r\n * The arrEvery() method is an iterative method. It calls a provided callbackFn function once for\r\n * each element in an array, until the callbackFn returns a falsy value. If such an element is found,\r\n * arrEvery() immediately returns false and stops iterating through the array. Otherwise, if callbackFn\r\n * returns a truthy value for all elements, every() returns true.\r\n * @since 0.8.0\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the base type of array elements\r\n * @typeParam E - Identifies a more specific instance of the base array type\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A function that accepts up to three arguments of type {@link ArrPredicateCallbackFn} or\r\n * {@link ArrPredicateCallbackFn2}. The predicate function is called for each element in the thArray until\r\n * the predicate returns a value which is coercible to the Boolean value false, or until the end of the array.\r\n * @param thisArg - A value to use as this when executing callbackFn. Defaults to the array if not provided.\r\n * @return `true` if the callbackFn returns a `truthy` value for every array elements. Otherwise `false`.\r\n * @example\r\n * ```ts\r\n * function isBigEnough<T>(element: T, index: number, array: T[]) {\r\n *   return element >= 10;\r\n * }\r\n *\r\n * arrEvery([12, 5, 8, 130, 44], isBigEnough);   // false\r\n * arrEvery([12, 54, 18, 130, 44], isBigEnough); // true\r\n *\r\n * const isSubset = <T>(array1: T[], array2: T[]) => arrEvery(array2, (element) => arrIncludes(array1, element));\r\n *\r\n * isSubset([1, 2, 3, 4, 5, 6, 7], [5, 7, 6]);  // true\r\n * isSubset([1, 2, 3, 4, 5, 6, 7], [5, 8, 7]);  // false\r\n *\r\n * arrEvery([1, , 3], (x) => x !== undefined);  // true\r\n * arrEvery([2, , 2], (x) => x === 2);          // true\r\n *\r\n * // Array Like combinations\r\n * isSubset([1, 2, 3, 4, 5, 6, 7], { length: 3, 0: 5, 1: 7, 2: 6}); // true\r\n * isSubset([1, 2, 3, 4, 5, 6, 7], { length: 3, 0: 5, 1: 8, 2: 7}); // false\r\n *\r\n * isSubset({ length: 7, 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7 }, [ 5, 7, 6 ]); // true\r\n * isSubset({ length: 7, 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7 }, [5, 8, 7]); // false\r\n *\r\n * isSubset({ length: 7, 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7 }, { length: 3, 0: 5, 1: 7, 2: 6}); // true\r\n * isSubset({ length: 7, 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7 }, { length: 3, 0: 5, 1: 8, 2: 7}); // false\r\n * ```\r\n */\r\nexport const arrEvery: <T, E extends T>(theArray: ArrayLike<T>, callbackFn: ArrPredicateCallbackFn<T, E> | ArrPredicateCallbackFn2<T>, thisArg?: any) => theArray is T[] = (/*#__PURE__*/_unwrapFunction(\"every\", ArrProto) as any);\r\n\r\n/**\r\n * The arrFilter() method creates a shallow copy of a portion of a given array, filtered down to just the elements\r\n * from the given array that pass the test implemented by the provided function.\r\n *\r\n * The filter() method is an iterative method. It calls a provided callbackFn function once for each element in an\r\n * array, and constructs a new array of all the values for which callbackFn returns a truthy value. Array elements\r\n * which do not pass the callbackFn test are not included in the new array.\r\n *\r\n * `callbackFn` is invoked only for array indexes which have assigned values. It is not invoked for empty slots in\r\n * sparse arrays.\r\n *\r\n * The arrFilter() method is a copying method. It does not alter this but instead returns a shallow copy that contains\r\n * the same elements as the ones from the original array (with some filtered out). However, the function provided as\r\n * callbackFn can mutate the array. Note, however, that the length of the array is saved before the first invocation\r\n * of callbackFn. Therefore:\r\n * - `callbackFn` will not visit any elements added beyond the array's initial length when the call to arrFilter()\r\n * began.\r\n * - Changes to already-visited indexes do not cause callbackFn to be invoked on them again.\r\n * - If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the `callbackFn`\r\n * will be the value at the time that element gets visited. Deleted elements are not visited.\r\n * @since 0.8.0\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the base type of the elements.\r\n * @typeParam E - Identifies a more specific instance of the base array type.\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A function that accepts up to three arguments of type {@link ArrPredicateCallbackFn} or\r\n * {@link ArrPredicateCallbackFn2}. The predicate function is called for each element in the thArray until\r\n * the predicate returns a value which is coercible to the Boolean value false, or until the end of the array.\r\n * @param thisArg - A value to use as this when executing callbackFn. Defaults to the array if not provided.\r\n * @return A shallow copy of a portion of the given array, filtered down to just the elements from the given\r\n * array that pass the test implemented by the provided function. If no elements pass the test, an empty array\r\n * will be returned.\r\n * @example\r\n * ```ts\r\n * function isBigEnough<T>(value: T) {\r\n *   return value >= 10;\r\n * }\r\n *\r\n * const filtered = arrFilter([12, 5, 8, 130, 44], isBigEnough);\r\n * // filtered is [12, 130, 44]\r\n *\r\n * const arrayLikeFiltered = arrFilter({ length: 5, 0: 12, 1: 5, 2: 8, 3: 130, 4: 44}, isBigEnough);\r\n * // arrayLikeFiltered is [12, 130, 44]\r\n *\r\n * const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\r\n *\r\n * function isPrime(num) {\r\n *   for (let i = 2; num > i; i++) {\r\n *     if (num % i === 0) {\r\n *       return false;\r\n *     }\r\n *   }\r\n *   return num > 1;\r\n * }\r\n *\r\n * console.log(arrFilter(array, isPrime)); // [2, 3, 5, 7, 11, 13]\r\n * ```\r\n */\r\nexport const arrFilter: <T, E extends T>(theArray: ArrayLike<T>, callbackFn: ArrPredicateCallbackFn<T, E> | ArrPredicateCallbackFn2<T>, thisArg?: any) => T[] | E[] = (/*#__PURE__*/_unwrapFunction(\"filter\", ArrProto) as any);\r\n"]}