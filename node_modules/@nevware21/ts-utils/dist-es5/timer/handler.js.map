{"version":3,"file":"handler.js","sourceRoot":"","sources":["../../src/timer/handler.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAEjD,IAAM,GAAG,GAAG,KAAK,CAAC;AAClB,IAAM,KAAK,GAAG,IAAI,GAAG,GAAc,CAAC;AACpC,IAAM,OAAO,GAAG,QAAQ,CAAC;AACzB,IAAM,OAAO,GAAG,SAAS,CAAC;AA2I1B;;;;;;;;;GASG;AACH,MAAM,UAAU,mBAAmB,CAAI,UAAmB,EAAE,SAA4B,EAAE,QAA8B;;IACpH,IAAI,GAAG,GAAG,IAAI,CAAC;IACf,IAAI,OAAO,GAAM,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;IACjE,IAAI,eAA8B,CAAC;IAEnC,IAAM,MAAM,GAAG;QACX,GAAG,GAAG,KAAK,CAAC;QACZ,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QAC9C,OAAO,eAAe,CAAC;IAC3B,CAAC,CAAC;IAEF,IAAM,IAAI,GAAG;QACT,GAAG,GAAG,IAAI,CAAC;QACX,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QAC1C,OAAO,eAAe,CAAC;IAC3B,CAAC,CAAC;IAEF,IAAM,OAAO,GAAG;QACZ,IAAI,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YAC7B,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;SAC7B;QACD,OAAO,GAAG,CAAC;IACf,CAAC,CAAC;IAEF,IAAM,QAAQ,GAAG;QACb,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,EAAE;YACN,MAAM,EAAE,CAAC;SACZ;QAED,OAAO,eAAe,CAAC;IAC3B,CAAC,CAAC;IAEF,IAAM,OAAO,GAAG;QACZ,OAAO,IAAI,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC7B,OAAO,GAAG,UAAU,CAAC;IACzB,CAAC,CAAC;IAEF,IAAM,WAAW,GAAG,UAAC,KAAc;QAC/B,CAAC,KAAK,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;QAC/B,KAAK,IAAI,CAAC,OAAO,IAAI,QAAQ,EAAE,CAAC;IACpC,CAAC,CAAA;IAED,eAAe;YACX,MAAM,EAAE,OAAO;YACf,OAAO,EAAE,QAAQ;;QACjB,GAAC,OAAO,IAAG,OAAO;QAClB,GAAC,GAAG,IAAG,IAAI;QACX,GAAC,KAAK,IAAG,MAAM;QACf,GAAC,OAAO,IAAG,KAAK;WACnB,CAAC;IAEF,aAAa,CAAC,eAAe,EAAE,OAAO,EAAE;QACpC,GAAG,EAAE,cAAM,OAAA,CAAC,CAAC,OAAO,EAAT,CAAS;QACpB,GAAG,EAAE,WAAW;KACnB,CAAC,CAAC;IAEH,OAAO;QACH,CAAC,EAAE,eAAe;QAClB,EAAE,EAAE;YACA,OAAO,GAAG,UAAU,CAAC;QACzB,CAAC;KACJ,CAAC;AACN,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE } from \"../internal/constants\";\r\nimport { objDefineProp } from \"../object/define\";\r\n\r\nconst REF = \"ref\";\r\nconst UNREF = \"un\" + REF as \"unref\";\r\nconst HAS_REF = \"hasRef\";\r\nconst ENABLED = \"enabled\";\r\n\r\n/**\r\n * A Timer handler which is returned from {@link scheduleTimeout} which contains functions to\r\n * cancel or restart (refresh) the timeout function.\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n */\r\nexport interface ITimerHandler {\r\n    /**\r\n     * Cancels a timeout that was previously scheduled, after calling this function any previously\r\n     * scheduled timer will not execute.\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = scheduleTimeout(...);\r\n     * theTimer.cancel();\r\n     * ```\r\n     */\r\n    cancel(): void;\r\n\r\n    /**\r\n     * Reschedules the timer to call its callback at the previously specified duration\r\n     * adjusted to the current time. This is useful for refreshing a timer without allocating\r\n     * a new JavaScript object.\r\n     *\r\n     * Using this on a timer that has already called its callback will reactivate the timer.\r\n     * Calling on a timer that has not yet executed will just reschedule the current timer.\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = scheduleTimeout(...);\r\n     * // The timer will be restarted (if already executed) or rescheduled (if it has not yet executed)\r\n     * theTimer.refresh();\r\n     * ```\r\n     */\r\n    refresh(): ITimerHandler;\r\n\r\n    /**\r\n     * When called, requests that the event loop not exit so long when the ITimerHandler is active.\r\n     * Calling timer.ref() multiple times will have no effect. By default, all ITimerHandler objects\r\n     * will create \"ref'ed\" instances, making it normally unnecessary to call timer.ref() unless\r\n     * timer.unref() had been called previously.\r\n     * @since 0.7.0\r\n     * @returns the ITimerHandler instance\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Make sure the timer is referenced (the default) so that the runtime (Node) does not terminate\r\n     * // if there is a waiting referenced timer.\r\n     * theTimer.ref();\r\n     * ```\r\n     */\r\n    ref(): this;\r\n\r\n    /**\r\n     * When called, the any active ITimerHandler instance will not require the event loop to remain\r\n     * active (Node.js). If there is no other activity keeping the event loop running, the process may\r\n     * exit before the ITimerHandler instance callback is invoked. Calling timer.unref() multiple times\r\n     * will have no effect.\r\n     * @since 0.7.0\r\n     * @returns the ITimerHandler instance\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Unreference the timer so that the runtime (Node) may terminate if nothing else is running.\r\n     * theTimer.unref();\r\n     * ```\r\n     */\r\n    unref(): this;\r\n\r\n    /**\r\n     * If true, any running referenced `ITimerHandler` instance will keep the Node.js event loop active.\r\n     * @since 0.7.0\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Unreference the timer so that the runtime (Node) may terminate if nothing else is running.\r\n     * theTimer.unref();\r\n     * let hasRef = theTimer.hasRef(); // false\r\n     *\r\n     * theTimer.ref();\r\n     * hasRef = theTimer.hasRef(); // true\r\n     * ```\r\n     */\r\n    hasRef(): boolean;\r\n\r\n    /**\r\n     * Gets or Sets a flag indicating if the underlying timer is currently enabled and running.\r\n     * Setting the enabled flag to the same as it's current value has no effect, setting to `true`\r\n     * when already `true` will not {@link ITimerHandler.refresh | refresh}() the timer.\r\n     * And setting to 'false` will {@link ITimerHandler.cancel | cancel}() the timer.\r\n     * @since 0.8.1\r\n        * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Check if enabled\r\n     * theTimer.enabled; // false\r\n     *\r\n     * // Start the timer\r\n     * theTimer.enabled = true;     // Same as calling refresh()\r\n     * theTimer.enabled; //true\r\n     *\r\n     * // Has no effect as it's already running\r\n     * theTimer.enabled = true;\r\n     *\r\n     * // Will refresh / restart the time\r\n     * theTimer.refresh()\r\n     *\r\n     * let theTimer = scheduleTimeout(...);\r\n     *\r\n     * // Check if enabled\r\n     * theTimer.enabled; // true\r\n     * ```\r\n     */\r\n    enabled: boolean;\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n */\r\nexport interface _TimerHandler {\r\n    /**\r\n     * The public handler to return to the caller\r\n     */\r\n    h: ITimerHandler,\r\n\r\n    /**\r\n     * The callback function that should be called when the timer operation\r\n     * has completed and will not automatically rescheduled\r\n     * @returns\r\n     */\r\n    dn: () => void\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Internal function to create and manage an ITimerHandler implementation, the object returned from this function\r\n * it directly used / returned by the pulic functions used to create timers (idle, interval and timeout)\r\n * @param startTimer - Should the timer be started as part of creating the handler\r\n * @param refreshFn - The function used to create/start or refresh the timer\r\n * @param cancelFn - The function used to cancel the timer.\r\n * @returns The new ITimerHandler instance\r\n */\r\nexport function _createTimerHandler<T>(startTimer: boolean, refreshFn: (timerId: T) => T, cancelFn: (timerId: T) => void): _TimerHandler {\r\n    let ref = true;\r\n    let timerId: T = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;\r\n    let theTimerHandler: ITimerHandler;\r\n\r\n    const _unref = () => {\r\n        ref = false;\r\n        timerId && timerId[UNREF] && timerId[UNREF]();\r\n        return theTimerHandler;\r\n    };\r\n\r\n    const _ref = () => {\r\n        ref = true;\r\n        timerId && timerId[REF] && timerId[REF]();\r\n        return theTimerHandler;\r\n    };\r\n\r\n    const _hasRef = () => {\r\n        if (timerId && timerId[HAS_REF]) {\r\n            return timerId[HAS_REF]();\r\n        }\r\n        return ref;\r\n    };\r\n\r\n    const _refresh = () => {\r\n        timerId = refreshFn(timerId);\r\n        if (!ref) {\r\n            _unref();\r\n        }\r\n\r\n        return theTimerHandler;\r\n    };\r\n\r\n    const _cancel = () => {\r\n        timerId && cancelFn(timerId);\r\n        timerId = NULL_VALUE;\r\n    };\r\n\r\n    const _setEnabled = (value: boolean) => {\r\n        !value && timerId && _cancel();\r\n        value && !timerId && _refresh();\r\n    }\r\n\r\n    theTimerHandler = {\r\n        cancel: _cancel,\r\n        refresh: _refresh,\r\n        [HAS_REF]: _hasRef,\r\n        [REF]: _ref,\r\n        [UNREF]: _unref,\r\n        [ENABLED]: false\r\n    };\r\n\r\n    objDefineProp(theTimerHandler, ENABLED, {\r\n        get: () => !!timerId,\r\n        set: _setEnabled\r\n    });\r\n\r\n    return {\r\n        h: theTimerHandler,\r\n        dn: () => {\r\n            timerId = NULL_VALUE;\r\n        }\r\n    };\r\n}\r\n"]}