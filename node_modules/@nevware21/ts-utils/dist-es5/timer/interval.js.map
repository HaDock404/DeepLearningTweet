{"version":3,"file":"interval.js","sourceRoot":"","sources":["../../src/timer/interval.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,OAAO,EAAE,MAAM,kBAAkB,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,uBAAuB,CAAC;AAC9D,OAAO,EAAiB,mBAAmB,EAAE,MAAM,WAAW,CAAC;AAoC/D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,MAAM,UAAU,gBAAgB,CAAkB,QAA8B,EAAE,OAAe;IAC7F,IAAI,IAAI,GAAG,IAAI,CAAC;IAChB,IAAI,YAAY,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,CAAC;IAEpD,IAAI,OAAO,GAAG,mBAAmB,CAAC,IAAI,EAAE,UAAC,UAAe;QACpD,UAAU,IAAI,aAAa,CAAC,UAAU,CAAC,CAAC;QACxC,OAAO,OAAO,CAAC,WAAW,EAAE,IAAI,EAAE,YAAY,CAAC,CAAA;IACnD,CAAC,EAAE,UAAC,UAAe;QACf,OAAO,CAAC,aAAa,EAAE,IAAI,EAAE,CAAE,UAAU,CAAE,CAAC,CAAC;IACjD,CAAC,CAAC,CAAC;IAEH,OAAO,OAAO,CAAC,CAAC,CAAC;AACrB,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { fnApply } from \"../funcs/fnApply\";\r\nimport { ArrProto, CALL, SLICE } from \"../internal/constants\";\r\nimport { ITimerHandler, _createTimerHandler } from \"./handler\";\r\n\r\n/**\r\n * Repeatedly calls a function or executes a code snippet, with a fixed time delay between each call.\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel or refresh the interval.\r\n * @example\r\n * ```ts\r\n * let intervalCalled = 0;\r\n * let theIntervalTimer = scheduleInvertal(() => {\r\n *     // This callback will be called every 100ms as this uses setInterval()\r\n *     intervalCalled++;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearInterval() with the returned value from setInterval() the returned\r\n * // handler instance can be used instead to cancel the timer\r\n * theIntervalTimer.cancel();\r\n * theIntervalTimer.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theIntervalTimer.enabled = true;\r\n *\r\n * // Or you can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theIntervalTimer.refresh();\r\n * ```\r\n */\r\nexport function scheduleInterval<A extends any[]>(callback: (...args: A) => void, timeout: number, ...args: A): ITimerHandler;\r\n\r\n/**\r\n * Repeatedly calls a function or executes a code snippet, with a fixed time delay between each call.\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel or refresh the interval.\r\n * @example\r\n * ```ts\r\n * let intervalCalled = 0;\r\n * let theIntervalTimer = scheduleInvertal(() => {\r\n *     // This callback will be called every 100ms as this uses setInterval()\r\n *     intervalCalled++;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearInterval() with the returned value from setInterval() the returned\r\n * // handler instance can be used instead to cancel the timer\r\n * theIntervalTimer.cancel();\r\n * theIntervalTimer.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theIntervalTimer.enabled = true;\r\n *\r\n * // Or you can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theIntervalTimer.refresh();\r\n * ```\r\n */\r\nexport function scheduleInterval<A extends any[]>(callback: (...args: A) => void, timeout: number): ITimerHandler {\r\n    let self = this;\r\n    let theArguments = ArrProto[SLICE][CALL](arguments);\r\n\r\n    let handler = _createTimerHandler(true, (intervalId: any) => {\r\n        intervalId && clearInterval(intervalId);\r\n        return fnApply(setInterval, self, theArguments)\r\n    }, (intervalId: any) => {\r\n        fnApply(clearInterval, self, [ intervalId ]);\r\n    });\r\n\r\n    return handler.h;\r\n}\r\n"]}