{"version":3,"file":"pad.js","sourceRoot":"","sources":["../../src/string/pad.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,iBAAiB,EAAE,MAAM,iBAAiB,CAAC;AACpD,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AAChE,OAAO,EAAE,uBAAuB,EAAE,MAAM,4BAA4B,CAAC;AACrE,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AACzC,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AACvC,OAAO,EAAE,SAAS,EAAE,MAAM,UAAU,CAAC;AACrC,OAAO,EAAE,YAAY,EAAE,MAAM,aAAa,CAAC;AAE3C,wBAAwB;AACxB,SAAS,SAAS,CAAC,KAAa,EAAE,YAAoB,EAAE,SAAkB;IACtE,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,YAAY,GAAG,SAAS,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;IAC7C,YAAY,KAAK,CAAC,CAAC;IAEnB,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;IACxB,IAAI,GAAG,GAAG,YAAY,EAAE;QACpB,MAAM,GAAG,iBAAiB,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QAClE,YAAY,GAAG,YAAY,GAAG,GAAG,CAAC;QAClC,IAAI,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE;YAC/B,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE,QAAQ,CAAC,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;SACvE;QAED,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,YAAY,EAAE;YAC/B,MAAM,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,YAAY,CAAC,CAAC;SAClD;KACJ;IAED,OAAO,MAAM,CAAC;AAClB,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,CAAC,IAAM,WAAW,GAAwE,EAAC,aAAa,uBAAuB,CAAC,UAAU,EAAE,QAAQ,EAAE,eAAe,CAAC,CAAC,CAAC;AAE9K;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,IAAM,SAAS,GAAwE,EAAC,aAAa,uBAAuB,CAAC,QAAQ,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC,CAAC;AAExK;;;;;;;;;;;;GAYG;AACH,wBAAwB;AACxB,MAAM,UAAU,eAAe,CAAC,KAAa,EAAE,YAAoB,EAAE,SAAkB;IACnF,OAAO,SAAS,CAAC,KAAK,EAAE,YAAY,EAAE,SAAS,CAAC,GAAG,KAAK,CAAC;AAC7D,CAAC;AAED;;;;;;;;;;;GAWG;AACH,wBAAwB;AACxB,MAAM,UAAU,aAAa,CAAC,KAAa,EAAE,YAAoB,EAAE,SAAkB;IACjF,OAAO,KAAK,GAAG,SAAS,CAAC,KAAK,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;AAC7D,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isNullOrUndefined } from \"../helpers/base\";\r\nimport { EMPTY, LENGTH, StrProto } from \"../internal/constants\";\r\nimport { _unwrapFunctionWithPoly } from \"../internal/unwrapFunction\";\r\nimport { mathCeil } from \"../math/floor\";\r\nimport { mathToInt } from \"../math/to_int\";\r\nimport { asString } from \"./as_string\";\r\nimport { strRepeat } from \"./repeat\";\r\nimport { strSubstring } from \"./substring\";\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _padValue(value: string, targetLength: number, padString?: string) {\r\n    let result = EMPTY;\r\n    targetLength = mathToInt(targetLength, true);\r\n    targetLength >>= 0;\r\n\r\n    let len = value[LENGTH];\r\n    if (len < targetLength) {\r\n        result = isNullOrUndefined(padString) ? \" \" : asString(padString);\r\n        targetLength = targetLength - len;\r\n        if (targetLength > result[LENGTH]) {\r\n            result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));\r\n        }\r\n\r\n        if (result[LENGTH] > targetLength) {\r\n            result = strSubstring(result, 0, targetLength);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * The `strPadStart()` method pads the current string with another string (multiple times, if needed)\r\n * until the resulting string reaches the given length. The padding is applied from the start of the\r\n * current string. This will use any native implementation if available, but will fall back to the\r\n * provided polyfill for runtimes that don't support [padStart](https://caniuse.com/?search=padStart)\r\n * @group String\r\n * @param value - The value to be padded\r\n * @param targetLength - The length of the resulting string once the current str has been padded.\r\n * If the value is less than str.length, then str is returned as-is.\r\n * @param padString - The string to pad the current str with. If padString is too long to stay within\r\n * the targetLength, it will be truncated from the end. The default value is the unicode \"space\"\r\n * character (U+0020).\r\n */\r\nexport const strPadStart: (value: string, targetLength: number, padString?: string) => string = (/*#__PURE__*/_unwrapFunctionWithPoly(\"padStart\", StrProto, polyStrPadStart));\r\n\r\n/**\r\n * The `strPadEnd()` method pads the current string with a given string (repeated, if needed) so that\r\n * the resulting string reaches a given length. The padding is applied from the end of the current string.\r\n * @group String\r\n * @param value - The value to be padded\r\n * @param targetLength - The length of the resulting string once the current `value`` has been padded. If\r\n * the `targetLength` is lower than `value.length`, the current string will be returned as-is.\r\n * @param padString - The string to pad the current `value` with. If padString is too long to stay within\r\n * `targetLength`, it will be truncated: for left-to-right languages the left-most part and for right-to-left\r\n * languages the right-most will be applied. The default value for this parameter is \" \" (U+0020).\r\n * @returns A String of the specified targetLength with the padString applied at the end of the current str.\r\n */\r\nexport const strPadEnd: (value: string, targetLength: number, padString?: string) => string = (/*#__PURE__*/_unwrapFunctionWithPoly(\"padEnd\", StrProto, polyStrPadEnd));\r\n\r\n/**\r\n * The `strPadStart()` method pads the current string with another string (multiple times, if needed)\r\n * until the resulting string reaches the given length. The padding is applied from the start of the\r\n * current string. Provided for runtimes that don't support see [padStart](https://caniuse.com/?search=padStart)\r\n * @group Polyfill\r\n * @group String\r\n * @param value - The value to be padded\r\n * @param targetLength - The length of the resulting string once the current str has been padded.\r\n * If the value is less than str.length, then str is returned as-is.\r\n * @param padString - The string to pad the current str with. If padString is too long to stay within\r\n * the targetLength, it will be truncated from the end. The default value is the unicode \"space\"\r\n * character (U+0020).\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyStrPadStart(value: string, targetLength: number, padString?: string): string {\r\n    return _padValue(value, targetLength, padString) + value;\r\n}\r\n\r\n/**\r\n * The `strPadEnd()` method pads the current string with a given string (repeated, if needed) so that\r\n * the resulting string reaches a given length. The padding is applied from the end of the current string.\r\n * @group Polyfill\r\n * @group String\r\n * @param value - The value to be padded\r\n * @param targetLength - The length of the resulting string once the current `value`` has been padded. If\r\n * the `targetLength` is lower than `value.length`, the current string will be returned as-is.\r\n * @param padString - The string to pad the current `value` with. If padString is too long to stay within\r\n * `targetLength`, it will be truncated. The default value for this parameter is \" \" (U+0020).\r\n * @returns A String of the specified targetLength with the padString applied at the end of the current str.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyStrPadEnd(value: string, targetLength: number, padString?: string): string {\r\n    return value + _padValue(value, targetLength, padString);\r\n}\r\n"]}