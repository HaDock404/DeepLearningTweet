{"version":3,"file":"conversion.js","sourceRoot":"","sources":["../../src/string/conversion.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,KAAK,EAAE,MAAM,uBAAuB,CAAC;AAC9C,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AACvC,OAAO,EAAE,OAAO,EAAE,MAAM,QAAQ,CAAC;AACjC,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAEnD;;;;;;;;GAQG;AACH,wBAAwB;AACxB,SAAS,YAAY,CAAI,KAAQ,EAAE,SAAiB,EAAE,SAAmB;IACrE,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,oCAAoC,EACxE,UAAC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,SAAS,EAAE,WAAW,EAAE,WAAW;QAClD,IAAI,YAAY,GAAG,SAAS,IAAI,WAAW,IAAG,KAAK,CAAC;QACpD,IAAI,SAAS,EAAE;YACX,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAC;SACzC;QACD,OAAO,CAAC,WAAW,IAAI,KAAK,CAAC,GAAG,SAAS,GAAG,YAAY,CAAC;IAC7D,CAAC,CAAC,CAAC;AACX,CAAC;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,wBAAwB;AACxB,MAAM,UAAU,aAAa,CAAI,KAAQ;IACrC,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;AAC1D,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,wBAAwB;AACxB,MAAM,UAAU,YAAY,CAAI,KAAQ,EAAE,UAAoB;IAC1D,IAAI,MAAM,GAAG,YAAY,CAAC,KAAK,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;IAE3C,OAAO,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;AACnE,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACH,wBAAwB;AACxB,MAAM,UAAU,YAAY,CAAI,KAAQ,EAAE,MAAgB;IACtD,IAAI,MAAM,GAAG,YAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACtC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,CAAC;AAClD,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BG;AACH,wBAAwB;AACxB,MAAM,UAAU,YAAY,CAAI,KAAQ,EAAE,MAAgB;IACtD,IAAI,MAAM,GAAG,YAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACtC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,CAAC;AAClD,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { EMPTY } from \"../internal/constants\";\r\nimport { asString } from \"./as_string\";\r\nimport { strTrim } from \"./trim\";\r\nimport { strLower, strUpper } from \"./upper_lower\";\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function to escape and convert the case\r\n * @param value - The value to be converted\r\n * @param newPrefix - The new prefix to add between matches\r\n * @param upperWord - Identify whether to uppercase the match\r\n * @returns The converted string\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _convertCase<T>(value: T, newPrefix: string, upperWord?: boolean): string {\r\n    return strTrim(asString(value)).replace(/((_|\\W)+(\\w){0,1}|([a-z])([A-Z]))/g,\r\n        (_match, _g1, _g2, wordStart, upperPrefix, upperLetter) => {\r\n            let convertMatch = wordStart || upperLetter|| EMPTY;\r\n            if (upperWord) {\r\n                convertMatch = strUpper(convertMatch);\r\n            }\r\n            return (upperPrefix || EMPTY) + newPrefix + convertMatch;\r\n        });\r\n}\r\n\r\n/**\r\n * Convert the provided value to a `Letter Cased` string, where the start of each word is\r\n * capitalized, all non-word character and spaces are retained.\r\n * If the value is not a string it will be converted.\r\n * @since 0.9.0\r\n * @group String\r\n * @group Conversion\r\n * @param value - The value to be converted to letter case\r\n * @returns The Letter Cased version of the provided value\r\n * @example\r\n * ```ts\r\n * strLetterCase(null);             // \"Null\"\r\n * strLetterCase(undefined);        // \"Undefined\"\r\n * strLetterCase(\"hello darkness\"); // \"Hello Darkness\"\r\n * strLetterCase(\"hello_darkness\"); // \"Hello_Darkness\"\r\n * strLetterCase(\"_hello_darkness\"); // \"_Hello_Darkness\"\r\n * strLetterCase(\"hello darkness, my old friend.\"); // \"Hello Darkness; // My Old Friend.\"\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function strLetterCase<T>(value: T): string {\r\n    return asString(value).replace(/(_|\\b)\\w/g, strUpper);\r\n}\r\n\r\n/**\r\n * Convert the provided value to `camelCased` string, you can optionally specifify whether the\r\n * first caracter is upper cased (lowercase by default)from kebab `-` or snake `_` case.\r\n * All whitespace characters are removed\r\n * If the value is not a string it will be converted.\r\n * @since 0.9.0\r\n * @group String\r\n * @group Conversion\r\n * @param value - The value to be converted to camelCased string\r\n * @param upperFirst - Optionally, uppercase the first character of the first word, so when `true`\r\n * this will produce a Pascal Cased result.\r\n * @returns The `camelCased` version of the provided value.\r\n * @example\r\n * ```ts\r\n * strCamelCase(null);                  // \"null\"\r\n * strCamelCase(undefined);             // \"undefined\"\r\n * strCamelCase(\"hello darkness\");      // \"helloDarkness\"\r\n * strCamelCase(\"hello_darkness\");      // \"helloDarkness\"\r\n * strCamelCase(\"_hello_darkness\");     // \"helloDarkness\"\r\n * strCamelCase(\"hello-darkness\");      // \"helloDarkness\"\r\n * strCamelCase(\"-hello-darkness\");     // \"helloDarkness\"\r\n * strCamelCase(\"hello darkness, my old friend.\"); // \"helloDarknessMyOldFriend\"\r\n *\r\n * // Uppercase first character\r\n * strCamelCase(\"hello darkness\", true); // \"HelloDarkness\"\r\n * strCamelCase(\"hello_darkness\", true); // \"HelloDarkness\"\r\n * strCamelCase(\"_hello_darkness\", true); // \"HelloDarkness\"\r\n * strCamelCase(\"hello-darkness\", true); // \"HelloDarkness\"\r\n * strCamelCase(\"-hello-darkness\", true); // \"HelloDarkness\"\r\n * strCamelCase(\"hello darkness, my old friend.\", true); // \"HelloDarknessMyOldFriend\"\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function strCamelCase<T>(value: T, upperFirst?: boolean): string {\r\n    let result = _convertCase(value, \"\", true);\r\n\r\n    return result.replace(/^\\w/, upperFirst ? strUpper : strLower);\r\n}\r\n\r\n/**\r\n * Convert the provided value to `kebab-cased` string, you can optionally specify whther the result\r\n * is all uppercased by passing `true` as the optional `scream` argument, otherwise the entire result\r\n * will be lowercased.\r\n * If the value is not a string it will be converted.\r\n * @since 0.9.0\r\n * @group String\r\n * @group Conversion\r\n * @param value - The value to be converted to kebab-case string\r\n * @param scream - Optionally return the result as UpperCase (Screaming).\r\n * @returns The `kebab-cased` version of the provided value\r\n * @example\r\n * ```ts\r\n * strKebabCase(null);              // \"null\"\r\n * strKebabCase(undefined);         // \"undefined\"\r\n * strKebabCase(\"hello darkness\");  // \"hello-darkness\"\r\n * strKebabCase(\"hello_darkness\");  // \"hello-darkness\"\r\n * strKebabCase(\"_hello_darkness\"); // \"-hello-darkness\"\r\n * strKebabCase(\"hello darkness, my old friend.\"); // \"hello-darkness-my-old-friend-\"\r\n *\r\n * // Add optional SCREAM flag\r\n * strKebabCase(\"hello darkness\", true);    // \"HELLO-DARKNESS\"\r\n * strKebabCase(\"hello_darkness\", true);    // \"HELLO-DARKNESS\"\r\n * strKebabCase(\"_hello_darkness\", true);   // \"-HELLO-DARKNESS\"\r\n * strKebabCase(\"hello darkness, my old friend.\", true); // \"HELLO-DARKNESS-MY-OLD-FRIEND-\"\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function strKebabCase<T>(value: T, scream?: boolean): string {\r\n    let result = _convertCase(value, \"-\");\r\n    return (scream ? strUpper : strLower)(result);\r\n}\r\n\r\n/**\r\n * Convert the provided value to `snake_cased` string, you can optionally specify whther the result\r\n * is all uppercased by passing `true` as the optional `scream` argument, otherwise the entire result\r\n * will be lowercased.\r\n * If the value is not a string it will be converted.\r\n * @since 0.9.0\r\n * @group String\r\n * @group Conversion\r\n * @param value - The value to be converted to `snake_cased` string\r\n * @param scream - Optionally return the result as UpperCase (Screaming).\r\n * @returns The `snake-cased` version of the provided value\r\n * @example\r\n * ```ts\r\n * strSnakeCase(null);              // \"null\"\r\n * strSnakeCase(undefined);         // \"undefined\"\r\n * strSnakeCase(\"hello darkness\");  // \"hello_darkness\"\r\n * strSnakeCase(\"hello_darkness\");  // \"hello_darkness\"\r\n * strSnakeCase(\"_hello_darkness\"); // \"_hello_darkness\"\r\n * strSnakeCase(\"hello-darkness\");  // \"hello_darkness\"\r\n * strSnakeCase(\"-hello-darkness\"); // \"_hello_darkness\"\r\n * strSnakeCase(\"hello darkness, my old friend.\"); // \"hello_darkness_my_old_friend_\"\r\n *\r\n * // Use optional Scream flag\r\n * strSnakeCase(\"hello darkness\", true);    // \"HELLO_DARKNESS\"\r\n * strSnakeCase(\"hello_darkness\", true);    // \"HELLO_DARKNESS\"\r\n * strSnakeCase(\"_hello_darkness\", true);   // \"_HELLO_DARKNESS\"\r\n * strSnakeCase(\"hello-darkness\", true);    // \"HELLO_DARKNESS\"\r\n * strSnakeCase(\"-hello-darkness\", true);   // \"_HELLO_DARKNESS\"\r\n * strSnakeCase(\"hello darkness, my old friend.\", true); // \"HELLO_DARKNESS_MY_OLD_FRIEND_\"\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function strSnakeCase<T>(value: T, scream?: boolean): string {\r\n    let result = _convertCase(value, \"_\");\r\n    return (scream ? strUpper : strLower)(result);\r\n}\r\n"]}