{"version":3,"file":"cache.js","sourceRoot":"","sources":["../../src/helpers/cache.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAsBjD;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAwB;AACxB,MAAM,UAAU,iBAAiB,CAAI,KAAQ;IACzC,OAAO,aAAa,CAAC;QACjB,MAAM,EAAE,cAAM,OAAA,KAAK,EAAL,CAAK;KACf,EAAE,GAAG,EAAE,EAAE,KAAK,OAAA,EAAE,CAAoB,CAAC;AACjD,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,wBAAwB;AACxB,MAAM,UAAU,yBAAyB,CAAI,EAAW;IACpD,OAAO,aAAa,CAAC,EAAqB,EAAE,GAAG,EAAE;QAC7C,GAAG,EAAE;YACD,IAAI,MAAM,GAAG,EAAE,EAAE,CAAC;YAClB,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE;gBACrB,KAAK,EAAE,MAAM;gBACb,UAAU,EAAE,IAAI;aACnB,CAAC,CAAC;YAEH,OAAO,MAAM,CAAC;QAClB,CAAC;QACD,UAAU,EAAE,IAAI;QAChB,YAAY,EAAE,IAAI;KACrB,CAAC,CAAC;AACP,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2024 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { objDefineProp } from \"../object/define\";\r\n\r\n/**\r\n * A generic interface for holding a cached value\r\n * @since 0.10.5\r\n * @group Helpers\r\n * @group Cache\r\n * @typeparam T - The type of the value to be cached\r\n * @example\r\n * ```ts\r\n * let cachedValue: ICachedValue<string> = {\r\n *    v: \"some value\"\r\n * };\r\n * ```\r\n */\r\nexport interface ICachedValue<T> {\r\n    /**\r\n     * Returns the current cached value\r\n     */\r\n    v: T\r\n}\r\n\r\n/**\r\n * Create and return a readonly {@link ICachedValue} instance that is populated with the provided value.\r\n * This is useful when you want to cache a previously fetched value and return it without having to re-fetch\r\n * it again.\r\n * This is a lightweight version of {@link getLazy} which does not support any expiration or invalidation,\r\n * it also will not honor the {@link setBypassLazyCache} setting and will always return the provided value.\r\n * @since 0.10.5\r\n * @group Helpers\r\n * @group Cache\r\n * @typeparam T - The type of the value to be cached\r\n * @param value\r\n * @returns A new {@link ICachedValue} instance which wraps the provided value\r\n * @example\r\n * ```ts\r\n * let cachedValue = createCachedValue(\"some value\");\r\n * // cachedValue.v === \"some value\"\r\n *\r\n * JSON.stringify(cachedValue) === '{\"v\":\"some value\"}';\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createCachedValue<T>(value: T): ICachedValue<T> {\r\n    return objDefineProp({\r\n        toJSON: () => value\r\n    } as any, \"v\", { value }) as ICachedValue<T>;\r\n}\r\n\r\n/**\r\n * Create and return a readonly {@link ICachedValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * will not cause re-execution of the callback as the result from the first call is cached internally.\r\n * This is a lightweight version of {@link getLazy} which does not support any expiration or invalidation,\r\n * it also will not honor the {@link setBypassLazyCache} setting and will always return the provided value.\r\n * @since 0.10.5\r\n * @group Helpers\r\n * @group Cache\r\n * @typeparam T - The type of the value to be cached\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createDeferredCachedValue<T>(cb: () => T): ICachedValue<T> {\r\n    return objDefineProp({} as ICachedValue<T>, \"v\", {\r\n        get: function () {\r\n            let result = cb();\r\n            objDefineProp(this, \"v\", {\r\n                value: result,\r\n                enumerable: true\r\n            });\r\n\r\n            return result;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n}\r\n\r\n\r\n\r\n"]}