{"version":3,"file":"lazy.js","sourceRoot":"","sources":["../../src/helpers/lazy.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAoB,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACxE,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAGjD;;;GAGG;AACH,MAAM,CAAC,IAAI,oBAAsC,CAAC;AAElD,MAAM,UAAU,cAAc;IAC1B,oBAAoB,GAAG,gBAAgB,EAAE,CAAC;AAC9C,CAAC;AAoBD;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACH,MAAM,UAAU,OAAO,CAAI,EAAW;IAClC,IAAI,SAAS,GAAG,EAAoB,CAAC;IACrC,CAAC,oBAAoB,IAAI,cAAc,EAAE,CAAC;IAC1C,SAAS,CAAC,CAAC,GAAG,oBAAoB,CAAC,GAAG,CAAC;IAEvC,aAAa,CAAC,SAAS,EAAE,GAAG,EAAE;QAC1B,YAAY,EAAE,IAAI;QAClB,GAAG,EAAE;YACD,IAAI,MAAM,GAAG,EAAE,EAAE,CAAC;YAClB,IAAI,CAAC,oBAAoB,CAAC,GAAG,EAAE;gBAC3B,yBAAyB;gBACzB,aAAa,CAAC,SAAS,EAAE,GAAG,EAAE;oBAC1B,KAAK,EAAE,MAAM;iBAChB,CAAC,CAAC;aACN;YAED,SAAS,CAAC,CAAC,GAAG,oBAAoB,CAAC,GAAG,CAAC;YAEvC,OAAO,MAAM,CAAC;QAClB,CAAC;KACJ,CAAC,CAAC;IAEH,OAAO,SAAS,CAAC;AACrB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,kBAAkB,CAAC,QAAiB;IAChD,CAAC,oBAAoB,IAAI,cAAc,EAAE,CAAC;IAC1C,oBAAoB,CAAC,GAAG,GAAG,QAAQ,CAAC;AACxC,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyCG;AACH,MAAM,UAAU,eAAe,CAAI,EAAW;IAC1C,IAAI,SAAS,GAAG,EAAoB,CAAC;IACrC,CAAC,oBAAoB,IAAI,cAAc,EAAE,CAAC;IAC1C,SAAS,CAAC,CAAC,GAAG,oBAAoB,CAAC,GAAG,CAAC;IAEvC,IAAI,SAAS,GAAG,UAAC,QAAW;QACxB,yBAAyB;QACzB,aAAa,CAAC,SAAS,EAAE,GAAG,EAAE;YAC1B,KAAK,EAAE,QAAQ;YACf,QAAQ,EAAE,IAAI;SACjB,CAAC,CAAC;QAEH,IAAI,SAAS,CAAC,CAAC,EAAE;YACb,OAAO,SAAS,CAAC,CAAC,CAAC;SACtB;IACL,CAAC,CAAC;IAEF,aAAa,CAAC,SAAS,EAAE,GAAG,EAAE;QAC1B,YAAY,EAAE,IAAI;QAClB,GAAG,EAAE;YACD,IAAI,MAAM,GAAG,EAAE,EAAE,CAAC;YAClB,IAAI,CAAC,oBAAoB,CAAC,GAAG,EAAE;gBAC3B,yBAAyB;gBACzB,SAAS,CAAC,MAAM,CAAC,CAAC;aACrB;YAED,IAAI,oBAAoB,CAAC,GAAG,IAAI,SAAS,CAAC,CAAC,KAAK,oBAAoB,CAAC,GAAG,EAAE;gBACtE,SAAS,CAAC,CAAC,GAAG,oBAAoB,CAAC,GAAG,CAAC;aAC1C;YAED,OAAO,MAAM,CAAC;QAClB,CAAC;QACD,GAAG,EAAE,SAAS;KACjB,CAAC,CAAC;IAEH,OAAO,SAAS,CAAC;AACrB,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { _GlobalTestHooks, _getGlobalConfig } from \"../internal/global\";\r\nimport { objDefineProp } from \"../object/define\";\r\nimport { ICachedValue } from \"./cache\";\r\n\r\n/**\r\n * @internal\r\n * Internal flag which is set by the public {@link setBypassLazyCache}, should not be externally exported\r\n */\r\nexport let _globalLazyTestHooks: _GlobalTestHooks;\r\n\r\nexport function _initTestHooks() {\r\n    _globalLazyTestHooks = _getGlobalConfig();\r\n}\r\n\r\n/**\r\n * Interface of the object returned by the {@link getLazy} instance\r\n * @since 0.4.5\r\n * @group Lazy\r\n */\r\nexport interface ILazyValue<T> extends ICachedValue<T> {\r\n    /**\r\n     * Returns the current cached value from the lazy lookup, if the callback function has not yet occurred\r\n     * accessing the value will cause the lazy evaluation to occur and the result will be returned.\r\n     */\r\n    v: T,\r\n\r\n    /**\r\n     * Identifies if this instance is bypassing the internal caching mechanism which is used for testing\r\n     */\r\n    b?: boolean\r\n}\r\n\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally.\r\n * @since 0.4.5\r\n * @group Lazy\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns A new readonly {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = getLazy(() => callSomeExpensiveFunction());\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * ```\r\n */\r\nexport function getLazy<T>(cb: () => T): ILazyValue<T> {\r\n    let lazyValue = { } as ILazyValue<T>;\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    lazyValue.b = _globalLazyTestHooks.lzy;\r\n\r\n    objDefineProp(lazyValue, \"v\", {\r\n        configurable: true,\r\n        get: function () {\r\n            let result = cb();\r\n            if (!_globalLazyTestHooks.lzy) {\r\n                // Just replace the value\r\n                objDefineProp(lazyValue, \"v\", {\r\n                    value: result\r\n                });\r\n            }\r\n\r\n            lazyValue.b = _globalLazyTestHooks.lzy;\r\n\r\n            return result;\r\n        }\r\n    });\r\n\r\n    return lazyValue;\r\n}\r\n\r\n/**\r\n * Test Hook function used to cause the internal caching of objects to be bypassed, this should never\r\n * be enabled for production as it has additional performance impact caused by the repetitive creation\r\n * of the lazy wrappers.\r\n * @group Lazy\r\n * @since 0.5.0\r\n * @param newValue - When `true` will cause all new lazy implementations to bypass the cached lookup.\r\n */\r\nexport function setBypassLazyCache(newValue: boolean) {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    _globalLazyTestHooks.lzy = newValue;\r\n}\r\n\r\n/**\r\n * Create and return a writable {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally. The\r\n * value may be set as many times as required, if the callback has not been called when you set the value\r\n * it will never get called.\r\n * @since 0.9.4\r\n * @group Lazy\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns A new writable {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = getWritableLazy(() => callSomeExpensiveFunction());\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * // Setting the value\r\n * let cachedValue = getWritableLazy(() => callSomeExpensiveFunction());\r\n * let theValue = \"new Value\";\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will set the value to be set explicitly and the callback\r\n *     // will now never occur and the result will be cached\r\n *     cachedValue.v = theValue;\r\n * }\r\n *\r\n * // Accessing the value again will cause the previously set value to be returned.\r\n * theValue === cachedValue.v;  // true\r\n * ```\r\n */\r\nexport function getWritableLazy<T>(cb: () => T): ILazyValue<T> {\r\n    let lazyValue = { } as ILazyValue<T>;\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    lazyValue.b = _globalLazyTestHooks.lzy;\r\n\r\n    let _setValue = (newValue: T) => {\r\n        // Just replace the value\r\n        objDefineProp(lazyValue, \"v\", {\r\n            value: newValue,\r\n            writable: true\r\n        });\r\n\r\n        if (lazyValue.b) {\r\n            delete lazyValue.b;\r\n        }\r\n    };\r\n\r\n    objDefineProp(lazyValue, \"v\", {\r\n        configurable: true,\r\n        get: function () {\r\n            let result = cb();\r\n            if (!_globalLazyTestHooks.lzy) {\r\n                // Just replace the value\r\n                _setValue(result);\r\n            }\r\n            \r\n            if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {\r\n                lazyValue.b = _globalLazyTestHooks.lzy;\r\n            }\r\n\r\n            return result;\r\n        },\r\n        set: _setValue\r\n    });\r\n\r\n    return lazyValue;\r\n}\r\n"]}