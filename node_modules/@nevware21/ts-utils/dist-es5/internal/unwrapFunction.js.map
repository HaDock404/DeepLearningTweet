{"version":3,"file":"unwrapFunction.js","sourceRoot":"","sources":["../../src/internal/unwrapFunction.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,OAAO,EAAE,MAAM,wBAAwB,CAAC;AACjD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AAC/C,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AAEpD,IAAI,MAA6B,CAAC;AAElC;;;;;;;;;GASG;AACH,MAAM,CAAC,IAAM,mBAAmB,GAAgE,YAAY,CAAA,uBAAuB,CAAC;AAEpI;;;;;;;GAOG;AACH,MAAM,CAAC,IAAM,eAAe,GAA6E,YAAY,CAAA,uBAAuB,CAAC;AAE7I;;;;;;;;GAQG;AACH,wBAAwB;AACxB,MAAM,UAAU,uBAAuB,CAAqC,QAAiB,EAAE,QAAY,EAAE,QAAY;IACrH,MAAM,GAAG,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;IACnC,IAAI,KAAK,GAAG,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAE3C,OAAO,UAAS,OAAY;QACxB,IAAI,OAAO,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,KAAK,CAAC;QACtD,IAAI,OAAO,IAAI,QAAQ,EAAE;YACrB,IAAI,OAAO,GAAG,SAAS,CAAC;YACxB,OAAQ,CAAC,OAAO,IAAI,QAAQ,CAAc,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;SAC3G;QAED,cAAc,CAAC,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,qBAAqB,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;IACzF,CAAC,CAAC;AACN,CAAC;AAED;;;;;;;;;GASG;AACH,wBAAwB;AACxB,MAAM,UAAU,WAAW,CAAI,QAAiB;IAC5C,OAAO,UAAU,OAAU;QACvB,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC;IAC7B,CAAC,CAAC;AACN,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { dumpObj } from \"../helpers/diagnostics\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { asString } from \"../string/as_string\";\r\nimport { ArrProto, CALL, SLICE } from \"./constants\";\r\n\r\nlet _slice: typeof ArrProto.slice;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to run the named function on the passed first argument, this does not support polyfill\r\n * or prototype fallback, so the function must exist on the provided first argument.\r\n * If the first argument is null, undefined or the function does not exist an exception will be thrown\r\n * by the runtime\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport const _unwrapInstFunction:<R, T>(funcName: keyof T) => <T>(this: T, ..._args:any) => R = /*__PURE__*/_unwrapFunctionWithPoly;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport const _unwrapFunction:<R, T>(funcName: keyof T, clsProto: T) => <T>(this: T, ..._args:any) => R = /*__PURE__*/_unwrapFunctionWithPoly;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @param polyFunc - The function to call if not available on the thisArg, act like the polyfill\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _unwrapFunctionWithPoly<T, P extends (...args: any) => any>(funcName: keyof T, clsProto?: T, polyFunc?: P) {\r\n    _slice = _slice || ArrProto[SLICE];\r\n    let clsFn = clsProto && clsProto[funcName];\r\n\r\n    return function(thisArg: any): ReturnType<P> {\r\n        let theFunc = (thisArg && thisArg[funcName]) || clsFn;\r\n        if (theFunc || polyFunc) {\r\n            let theArgs = arguments;\r\n            return ((theFunc || polyFunc) as Function).apply(thisArg, theFunc ? _slice[CALL](theArgs, 1) : theArgs);\r\n        }\r\n\r\n        throwTypeError(\"\\\"\" + asString(funcName) + \"\\\" not defined for \" + dumpObj(thisArg));\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to lookup and return the named property from the first argument (which becomes the this)\r\n *\r\n * @since 0.4.2\r\n * @typeParam T - The type of the object which contains the propName\r\n * @param propName - The property name\r\n * @returns The value of the property\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _unwrapProp<T>(propName: keyof T) {\r\n    return function (thisArg: T) {\r\n        return thisArg[propName];\r\n    };\r\n}"]}