{"version":3,"file":"idle.js","sourceRoot":"","sources":["../../src/timer/idle.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAC;AAEzD,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AACvD,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,EAAiB,mBAAmB,EAAE,MAAM,WAAW,CAAC;AAC/D,OAAO,EAAE,eAAe,EAAE,MAAM,WAAW,CAAC;AAE5C,IAAI,gBAAqC,CAAC;AAC1C,IAAI,mBAAmB,GAAG,GAAG,CAAC;AAC9B,IAAI,iBAAiB,GAAG,EAAE,CAAC;AAE3B;;;;;;;;;;;;;;GAcG;AACH,wBAAwB;AACxB,MAAM,UAAU,eAAe;IAC3B,CAAC,gBAAgB,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,mBAAmB,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IACnG,OAAO,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AAChE,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,qBAAqB,CAAC,OAAe;IACjD,mBAAmB,GAAG,OAAO,CAAC;AAClC,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,0BAA0B,CAAC,OAAe;IACtD,iBAAiB,GAAG,OAAO,CAAC;AAChC,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuDG;AACH,MAAM,UAAU,oBAAoB,CAAC,QAA6B,EAAE,OAA4B;IAC5F,SAAS,eAAe,CAAC,QAAiB;QACtC,IAAI,SAAS,GAAG,OAAO,EAAE,CAAC;QAC1B,OAAO;YACH,UAAU,EAAE,QAAQ;YACpB,aAAa,EAAE,GAAG,EAAE;gBAChB,OAAO,iBAAiB,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;YACtD,CAAC;SACJ,CAAC;IACN,CAAC;IAED,IAAI,eAAe,EAAE,EAAE;QACnB,IAAI,OAAO,GAAG,mBAAmB,CAAC,IAAI,EAAE,CAAC,MAAc,EAAE,EAAE;YACvD,MAAM,IAAI,kBAAkB,CAAC,MAAM,CAAC,CAAC;YACrC,OAAO,mBAAmB,CAAC,CAAC,QAAsB,EAAE,EAAE;gBAClD,OAAO,CAAC,EAAE,EAAE,CAAC;gBACb,QAAQ,CAAC,QAAQ,IAAI,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;YACjD,CAAC,EAAE,OAAO,CAAC,CAAC;QAChB,CAAC,EAAE,CAAC,MAAc,EAAE,EAAE;YAClB,kBAAkB,CAAC,MAAM,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;QAEH,OAAO,OAAO,CAAC,CAAC,CAAC;KACpB;IAED,IAAI,OAAO,GAAG,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC;IACtC,IAAI,WAAW,CAAC,OAAO,CAAC,EAAE;QACtB,OAAO,GAAG,mBAAmB,CAAC;KACjC;IAED,OAAO,eAAe,CAAC,GAAG,EAAE;QACxB,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;IACpC,CAAC,EAAE,OAAO,CAAC,CAAC;AAChB,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isDefined, isUndefined } from \"../helpers/base\";\r\nimport { ILazyValue } from \"../helpers/lazy\";\r\nimport { elapsedTime, perfNow } from \"../helpers/perf\";\r\nimport { safeGetLazy } from \"../helpers/safe_lazy\";\r\nimport { ITimerHandler, _createTimerHandler } from \"./handler\";\r\nimport { scheduleTimeout } from \"./timeout\";\r\n\r\nlet _hasIdleCallback: ILazyValue<boolean>;\r\nlet _defaultIdleTimeout = 100;\r\nlet _maxExecutionTime = 50;\r\n\r\n/**\r\n * Identifies if the runtime supports the `requestIdleCallback` API.\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n * @group Environment\r\n *\r\n * @returns True if the runtime supports `requestIdleCallback` otherwise false.\r\n * @example\r\n * ```ts\r\n * let nativeIdleTimeouts = hasIdleCallback();\r\n * // true === idle timeouts are supported by the runtime otherwise false and the {@linke scheduleIdleCallback}\r\n * will use `setTimeout` instead.\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function hasIdleCallback(): boolean {\r\n    !_hasIdleCallback && (_hasIdleCallback = safeGetLazy(() => isDefined(requestIdleCallback), false));\r\n    return !!(_hasIdleCallback.v ? requestIdleCallback : false);\r\n}\r\n\r\n/**\r\n * Set the idle timeout fallback timeout which is used when the runtime does not support `requestIdleCallback`\r\n * the default idle timeout will be used for the scheduled timer. Defaults to 100ms\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param timeout - The time in milliseconds that the timer should wait before calling the idle function.\r\n */\r\nexport function setDefaultIdleTimeout(timeout: number) {\r\n    _defaultIdleTimeout = timeout;\r\n}\r\n\r\n/**\r\n * Set the idle timeout fallback simulated maximum execution time, used when the runtime doesn't\r\n * support `requestIdleTimeout` to simulate the [IdleDeadline](https://w3c.github.io/requestidlecallback/#dom-idledeadline)\r\n * `timeRemaining` value.\r\n * This value is used as the base time of the [IdleDeadline.timeRemaining](https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline/timeRemaining)\r\n * less the start time the callback was called. Defaults to 50ms.\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param maxTime - The maximum execution time in milliseconds.\r\n */\r\nexport function setDefaultMaxExecutionTime(maxTime: number) {\r\n    _maxExecutionTime = maxTime;\r\n}\r\n\r\n/**\r\n * Queues a function to be called during a browser's idle periods. This enables developers to\r\n * perform background and low priority work on the main event loop, without impacting latency-critical\r\n * events such as animation and input response. Functions are generally called in first-in-first-out\r\n * order; however, callbacks which have a timeout specified may be called out-of-order if necessary\r\n * in order to run them before the timeout elapses.\r\n *\r\n * You can call scheduledleCallback() within an idle callback function to schedule another callback to\r\n * take place no sooner than the next pass through the event loop.\r\n *\r\n * If the runtime does not support the [requestIdleCallback](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback)\r\n * it will fallback to use `setTimeout` with either the provided timeout or the current default idle\r\n * timeout, which can be set via {@link setDefaultIdleTimeout}. It will always supply a deadline which\r\n * indicates that the request timed out.\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param callback - A reference to a function that should be called in the near future, when the\r\n * event loop is idle. The callback function is passed an [IdleDeadline](https://w3c.github.io/requestidlecallback/#dom-idledeadline)\r\n * object describing the amount of time available and whether or not the callback has been run because\r\n * the timeout period expired.\r\n * @param options - Contains optional configuration parameters. Currently only one property is defined:\r\n * `timeout` If the number of milliseconds represented by this parameter has elapsed and the callback\r\n * has not already been called, then a task to execute the callback is queued in the event loop (even\r\n * if doing so risks causing a negative performance impact). timeout must be a positive value or it\r\n * is ignored.\r\n * @returns A handle which can be used to cancel the callback by passing it into the `cancelIdleCallback()`\r\n * method.\r\n * @example\r\n * ```ts\r\n * let idleCalled = false;\r\n * let idleTimedOut = false;\r\n * let theIdleTimer = scheduleIdleCallback((idleDeadline: IdleDeadline) => {\r\n *     // This callback will be called when the system is idle (via requestIdleCallback) or after the provided timeout 100ms\r\n *     idleCalled = true;\r\n *     idleTimedOut = idleDeadline?.didTimeout;\r\n *     while ((idleDeadline.timeRemaining() > 0 || deadline.didTimeout)) {\r\n *         // Do some background operations while there is time remaining or we timed out\r\n *         // Unlike interval timers this callback will NOT be called again unless you call \"refresh\"\r\n *         // to restart it or create a new idle timer\r\n *     }\r\n * }, 100);\r\n *\r\n * // Instead of calling cancelIdleCallback() with the returned value from requestIdleCallback() the returned\r\n * // handler instance can be used instead to cancel the idle timer\r\n * theIdleTimer.cancel();\r\n * theIdleTimer.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theIdleTimer.enabled = true;\r\n *\r\n * // You can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theIdleTimer.refresh();\r\n * ```\r\n */\r\nexport function scheduleIdleCallback(callback: IdleRequestCallback, options?: IdleRequestOptions): ITimerHandler {\r\n    function _createDeadline(timedOut: boolean) {\r\n        let startTime = perfNow();\r\n        return {\r\n            didTimeout: timedOut,\r\n            timeRemaining: () => {\r\n                return _maxExecutionTime - elapsedTime(startTime);\r\n            }\r\n        };\r\n    }\r\n\r\n    if (hasIdleCallback()) {\r\n        let handler = _createTimerHandler(true, (idleId: number) => {\r\n            idleId && cancelIdleCallback(idleId);\r\n            return requestIdleCallback((deadline: IdleDeadline) => {\r\n                handler.dn();\r\n                callback(deadline || _createDeadline(false));\r\n            }, options);\r\n        }, (idleId: number) => {\r\n            cancelIdleCallback(idleId);\r\n        });\r\n\r\n        return handler.h;\r\n    }\r\n\r\n    let timeout = (options || {}).timeout;\r\n    if (isUndefined(timeout)) {\r\n        timeout = _defaultIdleTimeout;\r\n    }\r\n    \r\n    return scheduleTimeout(() => {\r\n        callback(_createDeadline(true));\r\n    }, timeout);\r\n}\r\n"]}