{"version":3,"file":"array.js","sourceRoot":"","sources":["../../src/polyfills/array.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ArrFromMapFn, ArrPredicateCallbackFn, ArrPredicateCallbackFn2 } from \"../array/callbacks\";\r\nimport { arrForEach } from \"../array/forEach\";\r\nimport { arrIndexOf } from \"../array/indexOf\";\r\nimport { arrMap } from \"../array/map\";\r\nimport { arrSlice } from \"../array/slice\";\r\nimport { isArray, isNullOrUndefined, objToString } from \"../helpers/base\";\r\nimport { CALL, LENGTH } from \"../internal/constants\";\r\nimport { iterForOf } from \"../iterator/forOf\";\r\n\r\n/**\r\n * Polyfill support function for Array.isArray\r\n * @group Polyfill\r\n * @group Array\r\n * @param value - The value to be checked\r\n * @returns true if the value is an array otherwise false.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyIsArray<T>(value: any): value is T[] {\r\n    if (isNullOrUndefined(value)) {\r\n        return false;\r\n    }\r\n\r\n    return objToString(value) === \"[object Array]\";\r\n}\r\n\r\n/**\r\n * The polyArrIncludes() method determines whether an array includes a certain value among its\r\n * entries, returning true or false as appropriate.\r\n * Note: The polyfill does not handle NaN correctly.\r\n * @since 0.8.0\r\n * @group Array\r\n * @group Polyfill\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param searchElement - The value to search for\r\n * @param fromIndex - The optional Zero-based index at which to start searching, converted to an integer.\r\n * - Negative index counts back from the end of the array â€” if fromIndex < 0, fromIndex + array.length\r\n * is used. However, the array is still searched from front to back in this case.\r\n * - If fromIndex < -array.length or fromIndex is omitted, 0 is used, causing the entire array to be searched.\r\n * - If fromIndex >= array.length, the array is not searched and false is returned.\r\n * @returns A boolean value which is true if the value searchElement is found within the array (or the part of\r\n * the array indicated by the index fromIndex, if specified).\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyArrIncludes<T>(theArray: ArrayLike<T>, searchElement: T, fromIndex?: number): boolean {\r\n    return arrIndexOf(theArray, searchElement, fromIndex) !== -1;\r\n}\r\n\r\n/**\r\n * The polyArrFind() method returns the first element in the provided array that satisfies\r\n * the provided testing function. If no values satisfy the testing function, undefined\r\n * is returned.\r\n * - If you need the index of the found element in the array, use {@link arrFindIndex}.\r\n * - If you need to find the index of a value, use arrIndexOf(). (It's similar to {@link arrFindIndex}, but checks\r\n * each element for equality with the value instead of using a testing function.)\r\n * - If you need to find if a value exists in an array, use arrIncludes(). Again, it checks each element for\r\n * equality with the value instead of using a testing function.\r\n * - If you need to find if any element satisfies the provided testing function, use {@link arrSome}.\r\n *\r\n * The polyArrFind() method is an iterative method. It calls a provided `callbackFn` function once for each element\r\n * in an array in ascending-index order, until `callbackFn` returns a truthy value. polyArrFind() then returns that\r\n * element and stops iterating through the array. If callbackFn never returns a truthy value, polyArrFind() returns\r\n * undefined.\r\n *\r\n * `callbackFn` is invoked for every index of the array, not just those with assigned values. Empty slots in\r\n * sparse arrays behave the same as undefined.\r\n *\r\n * polyArrFind() does not mutate the array on which it is called, but the function provided as callbackFn can.\r\n * Note, however, that the length of the array is saved before the first invocation of `callbackFn`. Therefore:\r\n * - `callbackFn` will not visit any elements added beyond the array's initial length when the call to polyArrFind() began.\r\n * - Changes to already-visited indexes do not cause callbackFn to be invoked on them again.\r\n * - If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the\r\n * `callbackFn` will be the value at the time that element gets visited. Deleted elements are visited as if they\r\n * were undefined.\r\n * @since 0.8.0\r\n * @group Polyfill\r\n * @group Array\r\n * @typeParam T - Identifies the base type of array elements\r\n * @typeParam E - Identifies a more specific instance of the base array type\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A function that accepts up to three arguments of type {@link ArrPredicateCallbackFn} or\r\n * {@link ArrPredicateCallbackFn2}. The predicate function is called for each element in the thArray until\r\n * the predicate returns a value which is coercible to the Boolean value false, or until the end of the array.\r\n * @return The first element in the array that satisfies the provided testing function. Otherwise, undefined\r\n * is returned.\r\n * @example\r\n * ```ts\r\n * const inventory = [\r\n *   { name: \"apples\", quantity: 2 },\r\n *   { name: \"bananas\", quantity: 0 },\r\n *   { name: \"cherries\", quantity: 5 },\r\n * ];\r\n *\r\n * function isCherries(fruit) {\r\n *   return fruit.name === \"cherries\";\r\n * }\r\n *\r\n * console.log(polyArrFind(inventory, isCherries));\r\n * // { name: 'cherries', quantity: 5 }\r\n *\r\n * function isPrime(element, index, array) {\r\n *   let start = 2;\r\n *   while (start <= Math.sqrt(element)) {\r\n *     if (element % start++ < 1) {\r\n *       return false;\r\n *     }\r\n *   }\r\n *   return element > 1;\r\n * }\r\n *\r\n * console.log(polyArrFind([4, 6, 8, 12], isPrime)); // undefined, not found\r\n * console.log(polyArrFind([4, 5, 8, 12], isPrime)); // 5\r\n * ```\r\n */\r\nexport function polyArrFind<T, E extends T>(theArray: ArrayLike<T>, callbackFn: ArrPredicateCallbackFn<T, E> | ArrPredicateCallbackFn2<T>, thisArg?: any): T | E | undefined {\r\n    let result;\r\n    let idx = polyArrFindIndex(theArray, callbackFn, thisArg);\r\n    return idx !== -1 ? theArray[idx] : result;\r\n}\r\n\r\n/**\r\n * The polyArrFindIndex() method returns the index of the first element in an array that satisfies the provided testing\r\n * function. If no elements satisfy the testing function, -1 is returned.\r\n *\r\n * The polyArrFindIndex() is an iterative method. It calls a provided callbackFn function once for each element in an\r\n * array in ascending-index order, until callbackFn returns a truthy value. polyArrFindIndex() then returns the index\r\n * of that element and stops iterating through the array. If `callbackFn` never returns a truthy value, polyArrFindIndex()\r\n * returns -1.\r\n *\r\n * `callbackFn` is invoked for every index of the array, not just those with assigned values. Empty slots in sparse\r\n * arrays behave the same as undefined.\r\n *\r\n * polyArrFindIndex() does not mutate the array on which it is called, but the function provided as `callbackFn` can.\r\n * Note, however, that the length of the array is saved before the first invocation of callbackFn. Therefore:\r\n * - `callbackFn` will not visit any elements added beyond the array's initial length when the call to polyArrFindIndex() began.\r\n * - Changes to already-visited indexes do not cause `callbackFn` to be invoked on them again.\r\n * If an existing, yet-unvisited element of the array is changed by `callbackFn`, its value passed to the `callbackFn`\r\n * will be the value at the time that element gets visited. Deleted elements are visited as if they were undefined.\r\n * @since 0.8.0\r\n * @group Polyfill\r\n * @group Array\r\n * @typeParam T - Identifies the base type of array elements\r\n * @typeParam E - Identifies a more specific instance of the base array type\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A function that accepts up to three arguments of type {@link ArrPredicateCallbackFn} or\r\n * {@link ArrPredicateCallbackFn2}. The predicate function is called for each element in the thArray until\r\n * the predicate returns a value which is coercible to the Boolean value false, or until the end of the array.\r\n * @param thisArg - A value to use as this when executing callbackFn. Defaults to the array if not provided.\r\n * @return The index of the first element in the array that passes the test. Otherwise, -1.\r\n * @example\r\n * ```ts\r\n * ```\r\n */\r\nexport function polyArrFindIndex<T, E extends T>(theArray: ArrayLike<T>, callbackFn: ArrPredicateCallbackFn<T, E> | ArrPredicateCallbackFn2<T>, thisArg?: any): number {\r\n    let result = -1;\r\n    arrForEach(theArray, (value, index) => {\r\n        if (callbackFn[CALL](thisArg | theArray as any, value, index, theArray)) {\r\n            result = index;\r\n            return -1;\r\n        }\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * The polyArrFindLast() method iterates the array in reverse order and returns the value of the first element that\r\n * satisfies the provided testing function. If no elements satisfy the testing function, undefined is returned.\r\n * - If you need the index of the found element in the array, use {@link arrFindLastIndex}.\r\n * - If you need to find the index of a value, use arrLastIndexOf(). (It's similar to {@link arrFindLastIndex}, but checks\r\n * each element for equality with the value instead of using a testing function.)\r\n * - If you need to find if a value exists in an array, use arrIncludes(). Again, it checks each element for\r\n * equality with the value instead of using a testing function.\r\n * - If you need to find if any element satisfies the provided testing function, use {@link arrSome}.\r\n *\r\n * The polyArrFindLast() method is an iterative method. It calls a provided callbackFn function once for each element\r\n * in an array in descending-index order, until callbackFn returns a truthy value. polyArrFindLast() then returns that\r\n * element and stops iterating through the array. If `callbackFn` never returns a truthy value, polyArrFindLast() returns\r\n * undefined.\r\n *\r\n * `callbackFn` is invoked for every index of the array, not just those with assigned values. Empty slots in sparse\r\n * arrays behave the same as undefined.\r\n *\r\n * polyArrFindLast() does not mutate the array on which it is called, but the function provided as `callbackFn` can.\r\n * Note, however, that the length of the array is saved before the first invocation of `callbackFn`. Therefore:\r\n * - `callbackFn` will not visit any elements added beyond the array's initial length when the call to polyArrFindLast() began.\r\n * - Changes to already-visited indexes do not cause callbackFn to be invoked on them again.\r\n * - If an existing, yet-unvisited element of the array is changed by `callbackFn`, its value passed to the `callbackFn`\r\n * will be the value at the time that element gets visited. Deleted elements are visited as if they were undefined.\r\n * @since 0.8.0\r\n * @group Polyfill\r\n * @group Array\r\n * @typeParam T - Identifies the base type of array elements\r\n * @typeParam E - Identifies a more specific instance of the base array type\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A function that accepts up to three arguments of type {@link ArrPredicateCallbackFn} or\r\n * {@link ArrPredicateCallbackFn2}. The predicate function is called for each element in the thArray until\r\n * the predicate returns a value which is coercible to the Boolean value false, or until the end of the array.\r\n * @param thisArg - A value to use as this when executing callbackFn. Defaults to the array if not provided.\r\n * @return The last element in the array that satisfies the provided testing function. Otherwise, undefined\r\n * is returned.\r\n * @example\r\n * ```ts\r\n * const inventory = [\r\n *   { name: \"apples\", quantity: 2 },\r\n *   { name: \"bananas\", quantity: 0 },\r\n *   { name: \"cherries\", quantity: 5 },\r\n * ];\r\n *\r\n * function isCherries(fruit) {\r\n *   return fruit.name === \"cherries\";\r\n * }\r\n *\r\n * console.log(polyArrFindLast(inventory, isCherries));\r\n * // { name: 'cherries', quantity: 5 }\r\n *\r\n * function isPrime(element, index, array) {\r\n *   let start = 2;\r\n *   while (start <= Math.sqrt(element)) {\r\n *     if (element % start++ < 1) {\r\n *       return false;\r\n *     }\r\n *   }\r\n *   return element > 1;\r\n * }\r\n *\r\n * console.log(polyArrFindLast([4, 6, 8, 12], isPrime)); // undefined, not found\r\n * console.log(polyArrFindLast([4, 5, 7, 12], isPrime)); // 7\r\n * ```\r\n */\r\nexport function polyArrFindLast<T, E extends T>(theArray: ArrayLike<T>, callbackFn: ArrPredicateCallbackFn<T, E> | ArrPredicateCallbackFn2<T>, thisArg?: any): T | E | undefined {\r\n    let result;\r\n    let idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);\r\n    return idx !== -1 ? theArray[idx] : result;\r\n}\r\n\r\n/**\r\n * The polyArrFindLastIndex() method iterates the array in reverse order and returns the index of the first element that\r\n * satisfies the provided testing function. If no elements satisfy the testing function, -1 is returned.\r\n *\r\n * The polyArrFindLastIndex() method is an iterative method. It calls a provided `callbackFn` function once for each element\r\n * in an array in descending-index order, until callbackFn returns a truthy value. polyArrFindLastIndex() then returns the\r\n * index of that element and stops iterating through the array. If callbackFn never returns a truthy value, returns -1.\r\n *\r\n * `callbackFn` is invoked for every index of the array, not just those with assigned values. Empty slots in sparse arrays\r\n * behave the same as undefined.\r\n *\r\n * polyArrFindLastIndex() does not mutate the array on which it is called, but the function provided as callbackFn can.\r\n * Note, however, that the length of the array is saved before the first invocation of callbackFn. Therefore:\r\n * - `callbackFn` will not visit any elements added beyond the array's initial length when the call to polyArrFindLastIndex() began.\r\n * - Changes to already-visited indexes do not cause callbackFn to be invoked on them again.\r\n * - If an existing, yet-unvisited element of the array is changed by `callbackFn`, its value passed to the callbackFn\r\n * will be the value at the time that element gets visited. Deleted elements are visited as if they were undefined.\r\n * @since 0.8.0\r\n * @group Polyfill\r\n * @group Array\r\n * @typeParam T - Identifies the base type of array elements\r\n * @typeParam E - Identifies a more specific instance of the base array type\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A function that accepts up to three arguments of type {@link ArrPredicateCallbackFn} or\r\n * {@link ArrPredicateCallbackFn2}. The predicate function is called for each element in the thArray until\r\n * the predicate returns a value which is coercible to the Boolean value false, or until the end of the array.\r\n * @param thisArg - A value to use as this when executing callbackFn. Defaults to the array if not provided.\r\n * @return The index of the last (highest-index) element in the array that passes the test. Otherwise -1 if\r\n * no matching element is found.\r\n */\r\nexport function polyArrFindLastIndex<T, E extends T>(theArray: ArrayLike<T>, callbackFn: ArrPredicateCallbackFn<T, E> | ArrPredicateCallbackFn2<T>, thisArg?: any): number {\r\n    let result = -1;\r\n    let len = theArray[LENGTH] >>> 0;\r\n    for (let idx = len - 1; idx >= 0; idx--) {\r\n        if (idx in theArray && callbackFn[CALL](thisArg | theArray as any, theArray[idx], idx, theArray)) {\r\n            result = idx;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * The polyArrFrom creates an new shallow-copied array from an array-like object or an iterable.\r\n * @since 0.9.7\r\n * @group Polyfill\r\n * @group ArrayLike\r\n * @group Array\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the array-like or iterable.\r\n * @typeParam U - Identifies returned type of the array\r\n * @param theValue - An array-like object or iterable to convert to an array.\r\n * @param mapFn - A {@link ArrFromMapFn | mapping function} to call on every element of the array. If provided, every\r\n * value to be added to the array is first passed through this map function, and the return\r\n * value is added to the array instead. The function is called with the following arguments:\r\n * @param thisArg Value of 'this' used to invoke the mapfn.\r\n * @example\r\n * ```ts\r\n * polyArrFrom(\"Hello\");\r\n * // [ \"H\", \"e\", \"l\", \"l\", \"o\" ]\r\n *\r\n * polyArrFrom(new Set([\"Hello\", \"Darkness\", \"my\", \"old\", \"friend\"]));\r\n * // [\"Hello\", \"Darkness\", \"my\", \"old\", \"friend\"]\r\n *\r\n * let map = new Map([\r\n *   [ 1, \"Hello\" ],\r\n *   [ 2, \"Darkness\" ],\r\n *   [ 3, \"my\" ],\r\n *   [ 4, \"old\" ],\r\n *   [ 5, \"friend\"]\r\n * ]);\r\n *\r\n * polyArrFrom(map.values());\r\n * // [\"Hello\", \"Darkness\", \"my\", \"old\", \"friend\"]\r\n *\r\n * polyArrFrom(map.keys());\r\n * // [ 1, 2, 3, 4, 5 ]\r\n *\r\n * polyArrFrom(map.entries());\r\n * // [ [ 1, \"Hello\" ], [ 2, \"Darkness\" ], [ 3, \"my\" ], [ 4, \"old\" ], [ 5, \"friend\"] ]\r\n *\r\n * polyArrFrom(map, ([ key, value ]) => ({ [key]: value }));\r\n * // [ {\"1\": \"Hello\"}, {\"2\": \"Darkness\"}, {\"3\": \"my\"}, {\"4\": \"old\"}, {\"5\": \"friend\"} ]\r\n * ```\r\n */\r\nexport function polyArrFrom<T, U = T>(theValue: ArrayLike<T> | Iterable<T>, mapFn?: ArrFromMapFn<T, U>, thisArg?: any): U[] {\r\n    if (isArray(theValue)) {\r\n        let result = arrSlice(theValue);\r\n        return mapFn ? arrMap<T, U>(result, mapFn, thisArg) : result;\r\n    }\r\n\r\n    let result: U[] = [];\r\n    iterForOf(theValue as any, (value: U, cnt) => {\r\n        return result.push(mapFn ? mapFn[CALL](thisArg, value, cnt) : value);\r\n    });\r\n\r\n    return result;\r\n}\r\n"]}