{"version":3,"file":"copy.js","sourceRoot":"","sources":["../../src/object/copy.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach } from \"../array/forEach\";\r\nimport { isArray, isDate, isNullOrUndefined, isPrimitiveType } from \"../helpers/base\";\r\nimport { CALL, FUNCTION, NULL_VALUE, OBJECT } from \"../internal/constants\";\r\nimport { objDefine } from \"./define\";\r\nimport { isPlainObject } from \"./is_plain_object\";\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Provides the current context while performing a deep copy\r\n */\r\ninterface _DeepCopyContext {\r\n    handler: ObjDeepCopyHandler;\r\n    src: any;\r\n    path?: Array<string | number | symbol>;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Defines the type used for tracking visited objects during deep copy to identify recursive\r\n * objects.\r\n */\r\ninterface _RecursiveVisitMap {\r\n    k: any;\r\n    v: any;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Generic Object deep copy handler which creates a new plain object and copies enumerable properties from\r\n * the source to the new target plain object. The source object does not have to be a plain object.\r\n * @param details - The details object for the current property being copied\r\n * @returns true if the handler processed the field.\r\n */\r\nconst _defaultDeepCopyHandler = (details: IObjDeepCopyHandlerDetails): boolean => {\r\n    // Make sure we at least copy plain objects\r\n    details.value && plainObjDeepCopyHandler(details);\r\n\r\n    // Always return true so that the iteration completes\r\n    return true;\r\n};\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * The ordered default deep copy handlers\r\n */\r\nconst defaultDeepCopyHandlers: ObjDeepCopyHandler[] = [\r\n    arrayDeepCopyHandler,\r\n    plainObjDeepCopyHandler,\r\n    functionDeepCopyHandler,\r\n    dateDeepCopyHandler\r\n];\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function used for detecting and handling recursive properties\r\n * @param visitMap - The current map of objects that have been visited\r\n * @param source - The value (object) to be copied\r\n * @param newPath - The new access path from the origin to the current property\r\n * @param cb - The callback function to call if the current object has not already been processed.\r\n * @returns The new deep copied property, may be incomplete as the object is recursive and is still in the process of being copied\r\n */\r\nfunction _getSetVisited(visitMap: _RecursiveVisitMap[], source: any, newPath: Array<string | number | symbol>, cb: (newEntry: _RecursiveVisitMap) => void) {\r\n    let theEntry: _RecursiveVisitMap;\r\n    arrForEach(visitMap, (entry) => {\r\n        if (entry.k === source) {\r\n            theEntry = entry;\r\n            return -1;\r\n        }\r\n    });\r\n\r\n    if (!theEntry) {\r\n        // Add the target to the visit map so that deep nested objects refer to the single instance\r\n        // Even if we have not finished processing it yet.\r\n        theEntry = { k: source, v: source };\r\n        visitMap.push(theEntry);\r\n\r\n        // Now call the copy callback so that it populates the target\r\n        cb(theEntry);\r\n    }\r\n\r\n    return theEntry.v;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper which performs the recursive deep copy\r\n * @param visitMap - The current map of objects that have been visited\r\n * @param value - The value being copied\r\n * @param ctx - The current copy context\r\n * @param key - [Optional] the current `key` for the value from the source object\r\n * @returns The new deep copied instance of the value.\r\n */\r\nfunction _deepCopy<T>(visitMap: _RecursiveVisitMap[], value: T, ctx: _DeepCopyContext, key?: string | number | symbol): T {\r\n    let userHandler = ctx.handler;\r\n    let newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];\r\n\r\n    let newCtx: _DeepCopyContext = {\r\n        handler: ctx.handler,\r\n        src: ctx.src,\r\n        path: newPath\r\n    };\r\n\r\n    const theType = typeof value;\r\n    let isPlain = false;\r\n    let isPrim = false;\r\n    if (value && theType === OBJECT) {\r\n        isPlain = isPlainObject(value);\r\n    } else {\r\n        isPrim = value === NULL_VALUE || isPrimitiveType(theType);\r\n    }\r\n\r\n    let details: IObjDeepCopyHandlerDetails = {\r\n        type: theType,\r\n        isPrim: isPrim,\r\n        isPlain: isPlain,\r\n        value: value,\r\n        result: value,\r\n        path: newPath,\r\n        origin: ctx.src,\r\n        copy: <T>(source: T, newKey?: string | number | symbol): T => {\r\n            return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);\r\n        },\r\n        copyTo: <T>(target: T, source: T): T => {\r\n            return _copyProps(visitMap, target, source, newCtx);\r\n        }\r\n    };\r\n\r\n    if (!details.isPrim) {\r\n        return _getSetVisited(visitMap, value, newPath, (newEntry) => {\r\n\r\n            // Use an accessor to set the new value onto the new entry\r\n            objDefine(details, \"result\", {\r\n                g: function () {\r\n                    return newEntry.v;\r\n                },\r\n                s: function (newValue: any) {\r\n                    newEntry.v = newValue;\r\n                }\r\n            });\r\n\r\n            let idx = 0;\r\n            let handler = userHandler;\r\n            while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {\r\n                handler = NULL_VALUE;\r\n            }\r\n        });\r\n    }\r\n\r\n    // Allow the user handler to override the provided value\r\n    if (userHandler && userHandler[CALL](ctx, details)) {\r\n        return details.result;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to copy all of the enumerable properties from the source object to the new target object\r\n * @param visitMap - The current map of objects that have been visited\r\n * @param target - The target object to copy the properties to.\r\n * @param source - The source object to copy the properties from.\r\n * @param ctx - The current deep copy context\r\n * @returns The populated target object\r\n */\r\nfunction _copyProps<T>(visitMap: _RecursiveVisitMap[], target: T, source: T, ctx: _DeepCopyContext) {\r\n    if (!isNullOrUndefined(source)) {\r\n        // Copy all properties (not just own properties)\r\n        for (const key in source) {\r\n            // Perform a deep copy of the object\r\n            target[key] = _deepCopy(visitMap, source[key], ctx, key);\r\n        }\r\n    }\r\n\r\n    return target;\r\n}\r\n\r\n/**\r\n * Object helper to copy all of the enumerable properties from the source object to the target, the\r\n * properties are copied via {@link objDeepCopy}. Automatic handling of recursive properties was added in v0.4.4\r\n * @group Object\r\n * @param target - The target object to populated\r\n * @param source - The source object to copy the properties from\r\n * @param handler - An optional callback that lets you provide / overide the deep cloning (Since 0.4.4)\r\n * @returns The target object\r\n * @example\r\n * ```ts\r\n * let a: any = { a: 1 };\r\n * let b: any = { b: 2, d: new Date(), e: new TestClass(\"Hello Darkness\") };\r\n * a.b = b;        // { a: 1, b: { b: 2} }\r\n * b.a = a;        // { a: 1, b: { b: 2, a: { a: 1, { b: 2, a: ... }}}}\r\n *\r\n * function copyHandler(details: IObjDeepCopyHandlerDetails) {\r\n *     // details.origin === a\r\n *     // details.path[] is the path to the current value\r\n *     if (details.value && isDate(details.value)) {\r\n *         // So for the date path === [ \"b\", \"d\" ] which represents\r\n *         // details.origin[\"b\"][\"d\"] === The Date\r\n *\r\n *         // Create a clone the Date object and set as the \"newValue\"\r\n *         details.value = new Date(details.value.getTime());\r\n *\r\n *         // Return true to indicate that we have \"handled\" the conversion\r\n *         // See objDeepCopy example for just reusing the original value (just don't replace details.value)\r\n *         return true;\r\n *     }\r\n *\r\n *     return false;\r\n * }\r\n *\r\n * let c: any = objCopyProps({}, a, copyHandler);\r\n *\r\n * assert.notEqual(a, c, \"check a and c are not the same\");\r\n * assert.ok(c !== c.b.a, \"The root object won't be the same for the target reference as are are copying properties to our target\");\r\n * assert.ok(c.b === c.b.a.b, \"Check that the 2 'b' references are the same object\");\r\n * assert.ok(c.b.a === c.b.a.b.a, \"Check that the 2 'a' references are the same object\");\r\n * assert.ok(c.b.d === c.b.a.b.d, \"Check that the 2 'd' references are the same object\");\r\n * assert.ok(isDate(c.b.d), \"The copied date is still real 'Date' instance\");\r\n * assert.notEqual(c.b.d, a.b.d, \"And the copied date is not the same as the original\");\r\n * assert.equal(c.b.d.getTime(), a.b.d.getTime(), \"But the dates are the same\");\r\n *\r\n * assert.ok(isObject(c.b.d), \"The copied date is now an object\");\r\n * ```\r\n */\r\nexport function objCopyProps<T>(target: T, source: any, handler?: ObjDeepCopyHandler) {\r\n    let ctx: _DeepCopyContext = {\r\n        handler: handler,\r\n        src: source,\r\n        path: []\r\n    };\r\n\r\n    return _copyProps([], target, source, ctx);\r\n}\r\n\r\n/**\r\n * Context details passed to the deep copy handler to allow it parse the current value based on the original source\r\n * and path to reach the current value. The provided value should be updated with the value to by copied into the\r\n * new deep copy and will be used when the handler returns true.\r\n * @since 0.4.4\r\n * @group Object - Deep Copy\r\n */\r\nexport interface IObjDeepCopyHandlerDetails {\r\n    /**\r\n     * Identifies the type of the value as per `typeof value`, saves each check having to process this value.\r\n     */\r\n    type: string;\r\n\r\n    /**\r\n     * Identifies whether the type of the value is considered to be a primitive value\r\n     */\r\n    isPrim: boolean;\r\n\r\n    /**\r\n     * Identifies whether the type is a plain object or not, this also saves each handler from checking\r\n     * the `type`, currently the type will also be \"object\" if this is `true`.\r\n     * @since 0.9.6\r\n     */\r\n    isPlain: boolean;\r\n\r\n    /**\r\n     * The current value to be processed, replace this value with the new deep copied value to use when returning\r\n     * true from the handler. Ignored when the handler returns false.\r\n     */\r\n    readonly value: any;\r\n\r\n    /**\r\n     * Replace this value with the new deep copied value (defaults to the same as the value property) this value will be\r\n     * used when returning true from the handler. Ignored when the handler returns false.\r\n     */\r\n    result: any;\r\n\r\n    /**\r\n     * A array of keys from the orginal source (origin) object which lead to the current value\r\n     */\r\n    path: Array<string | number | symbol>;\r\n\r\n    /**\r\n     * The original source object passed into the `objDeepCopy()` or `objCopyProps()` functions.\r\n     */\r\n    origin?: any;\r\n\r\n    /**\r\n     * Continue the deep copy with the current context and recursive checks, effectively calls {@link objDeepCopy}\r\n     * but keeps the current context and recursive references.\r\n     * @param source - The source object to be copied\r\n     */\r\n    copy<T>(source: T, key?: string | number | symbol): T;\r\n\r\n    /**\r\n     * Continue the deep copy with the current context and recursive checks by copying all of the properties\r\n     * from the source to the target instance, effectively calls {@link objCopyProps} but keeps the current context\r\n     * and recursive references.\r\n     * @param target - The target object to populated\r\n     * @param source - The source object to copy the properties from\r\n     */\r\n    copyTo<T>(target: T, source: T): T;\r\n}\r\n\r\n/**\r\n * An optional deep copy handler that lets you provide your own logic for deep copying objects, will\r\n * only be called once per object/property combination, so if an object is recursively included it\r\n * will only get called for the first instance.\r\n * Handlers SHOULD assign the \"result\" value with the new target instance BEFORE performing any additional deep copying,\r\n * so any recursive objects will get a reference to the new instance and not keep attempting to create new copies.\r\n * @since 0.4.4\r\n * @group Object - Deep Copy\r\n * @return true if handled and the value in details should be used otherwise false to continue with the default handling\r\n * The library includes several helpers which can be reused by any user provided handler\r\n * - {@link functionDeepCopyHandler} - Used to copy functions\r\n * - {@link arrayDeepCopyHandler} - Used to copy arrays\r\n * - {@link plainObjDeepCopyHandler} - Used to copy plain objects\r\n * - {@link dateDeepCopyHandler} - Used to copy date instances\r\n */\r\nexport type ObjDeepCopyHandler = (details: IObjDeepCopyHandlerDetails) => boolean;\r\n\r\n/**\r\n * Performs a deep copy of the source object, this is designed to work with base (plain) objects, arrays and primitives\r\n * if the source object contains class objects they will either be not cloned or may be considered non-operational after\r\n * performing a deep copy. ie. This is performing a deep copy of the objects properties so that altering the copy will\r\n * not mutate the source object hierarchy.\r\n * Automatic handling of recursive properties was added in v0.4.4.\r\n * @group Object\r\n * @group Object - Deep Copy\r\n * @param source - The source object to be copied\r\n * @param handler - An optional callback that lets you provide / overide the deep cloning (Since 0.4.4)\r\n * @return A new object which contains a deep copy of the source properties\r\n * @example\r\n * ```ts\r\n * let a: any = { a: 1 };\r\n * let b: any = { b: 2, d: new Date(), e: new TestClass(\"Hello Darkness\") };\r\n * a.b = b;        // { a: 1, b: { b: 2} }\r\n * b.a = a;        // { a: 1, b: { b: 2, a: { a: 1, { b: 2, a: ... }}}}\r\n *\r\n * function copyHandler(details: IObjDeepCopyHandlerDetails) {\r\n *     // details.origin === a\r\n *     // details.path[] is the path to the current value\r\n *     if (details.value && isDate(details.value)) {\r\n *         // So for the date path === [ \"b\", \"d\" ] which represents\r\n *         // details.origin[\"b\"][\"d\"] === The Date\r\n *\r\n *         // Return true to indicate that we have \"handled\" the conversion\r\n *         // Which in this case will reuse the existing instance (as we didn't replace details.value)\r\n *         // See objCopyProps example for replacing the Date instance\r\n *         return true;\r\n *     }\r\n *\r\n *     return false;\r\n * }\r\n *\r\n * let c: any = objDeepCopy(a, copyHandler);\r\n *\r\n * assert.notEqual(a, c, \"check a and c are not the same\");\r\n * assert.ok(c === c.b.a, \"The root object won't be the same for the target reference\");\r\n * assert.ok(c.b === c.b.a.b, \"Check that the 2 'b' references are the same object\");\r\n * assert.ok(c.b.a === c.b.a.b.a, \"Check that the 2 'a' references are the same object\");\r\n * assert.ok(c.b.d === c.b.a.b.d, \"Check that the 2 'd' references are the same object\");\r\n * assert.ok(isDate(c.b.d), \"The copied date is still real 'Date' instance\");\r\n * assert.equal(c.b.d, a.b.d, \"And the copied date is the original date\");\r\n * assert.equal(c.b.d.getTime(), a.b.d.getTime(), \"But the dates are the same\");\r\n * assert.ok(isObject(c.b.d), \"The copied date is now an object\");\r\n * assert.ok(!isError(c.b.e), \"The copied error is no longer a real 'Error' instance\");\r\n * assert.ok(isObject(c.b.e), \"The copied error is now an object\");\r\n * assert.equal(42, c.b.e.value, \"Expect that the local property was copied\");\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function objDeepCopy<T>(source: T, handler?: ObjDeepCopyHandler): T {\r\n    let ctx: _DeepCopyContext = {\r\n        handler: handler,\r\n        src: source\r\n    };\r\n\r\n    return _deepCopy([], source, ctx);\r\n}\r\n\r\n/**\r\n * Deep copy handler to identify and copy arrays.\r\n * @since 0.4.4\r\n * @group Object - Deep Copy\r\n * @param details - The details object for the current property being copied\r\n * @returns `true` if the current value is a function otherwise `false`\r\n */\r\nexport function arrayDeepCopyHandler(details: IObjDeepCopyHandlerDetails): boolean {\r\n    let value = details.value;\r\n    if (isArray(value)) {\r\n        // Assign the \"result\" value before performing any additional deep Copying, so any recursive object get a reference to this instance\r\n        let target: any[] = details.result = [];\r\n        target.length = value.length;\r\n\r\n        // Copying all properties as arrays can contain non-indexed based properties\r\n        details.copyTo(target, value);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Deep copy handler to identify and copy Date instances.\r\n * @since 0.4.4\r\n * @group Object - Deep Copy\r\n * @param details - The details object for the current property being copied\r\n * @returns `true` if the current value is a function otherwise `false`\r\n */\r\nexport function dateDeepCopyHandler(details: IObjDeepCopyHandlerDetails) {\r\n    let value = details.value;\r\n    if (isDate(value)) {\r\n        details.result = new Date(value.getTime());\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Deep copy handler to identify and copy functions. This handler just returns the original\r\n * function so the original function will be assigned to any new deep copied instance.\r\n * @since 0.4.4\r\n * @group Object - Deep Copy\r\n * @param details - The details object for the current property being copied\r\n * @returns `true` if the current value is a function otherwise `false`\r\n */\r\nexport function functionDeepCopyHandler(details: IObjDeepCopyHandlerDetails): boolean {\r\n    if (details.type === FUNCTION) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Deep copy handler to identify and copy plain objects.\r\n * @since 0.4.4\r\n * @group Object - Deep Copy\r\n * @param details - The details object for the current property being copied\r\n * @returns `true` if the current value is a function otherwise `false`\r\n */\r\nexport function plainObjDeepCopyHandler(details: IObjDeepCopyHandlerDetails): boolean {\r\n    let value = details.value;\r\n    if (value && details.isPlain) {\r\n        // Assign the \"result\" value before performing any additional deep Copying, so any recursive object get a reference to this instance\r\n        let target = details.result = {};\r\n        details.copyTo(target, value);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n"]}