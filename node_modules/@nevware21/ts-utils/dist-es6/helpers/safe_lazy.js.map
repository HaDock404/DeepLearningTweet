{"version":3,"file":"safe_lazy.js","sourceRoot":"","sources":["../../src/helpers/safe_lazy.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,OAAO,EAAc,MAAM,QAAQ,CAAC;AAC7C,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,wBAAwB;AACxB,MAAM,UAAU,WAAW,CAAc,EAAW,EAAE,QAAW;IAC7D,OAAO,OAAO,CAAI,GAAG,EAAE;QACnB,IAAI,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC;QACtB,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;IAC1C,CAAC,CAAC,CAAC;AACP,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getLazy, ILazyValue } from \"./lazy\";\r\nimport { safe } from \"./safe\";\r\n\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally.\r\n * If the callback throws the default value will be returned.\r\n * @since 0.9.5\r\n * @group Lazy\r\n * @group Safe\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @param defValue - The default value to return when an exception is thrown\r\n * @returns A new readonly {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = safeGetLazy(() => callSomeExpensiveFunctionWhichMightThrow(), \"someDefaultValue\");\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function safeGetLazy<T = boolean>(cb: () => T, defValue: T): ILazyValue<T> {\r\n    return getLazy<T>(() => {\r\n        let result = safe(cb);\r\n        return result.e ? defValue : result.v;\r\n    });\r\n}\r\n"]}