{"version":3,"file":"get_set_value.js","sourceRoot":"","sources":["../../src/helpers/get_set_value.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach } from \"../array/forEach\";\r\nimport { isNullOrUndefined } from \"./base\";\r\nimport { strSplit } from \"../string/split\";\r\nimport { iterForOf } from \"../iterator/forOf\";\r\n\r\n/**\r\n * Get the named value from the target object where the path may be presented by a string which\r\n * contains \".\" characters to separate the nested objects of the heirarchy / path to the value.\r\n * @since 0.9.1\r\n * @group Value\r\n * @param target - The source object that contains the value\r\n * @param path - The path identifing the location where the value should be located\r\n * @param defValue - If the final value or any intervening object in the heirarchy is not present\r\n * the default value will be returned\r\n * @returns The value located based on the path or the defaule value\r\n * @example\r\n * ```ts\r\n * let theValue = {\r\n *   Hello: {\r\n *      Darkness: {\r\n *          my: \"old\"\r\n *      }\r\n *   },\r\n *   friend: \"I've\",\r\n *   come: {\r\n *      to: {\r\n *          see: \"you\"\r\n *      }\r\n *   }\r\n * };\r\n *\r\n * let value = getValueByKey(theValue, \"Hello.Darkness.my\", \"friend\");\r\n * // value === \"my\"\r\n *\r\n * let value = getValueByKey(theValue, \"My.Old\", \"friend\");\r\n * // value === \"friend\"\r\n *\r\n * let value = getValueByKey(theValue, \"come.to\", \"friend\");\r\n * // value === { see: \"you\" }\r\n *\r\n * let value = getValueByKey(theValue, \"friend\", \"friend\");\r\n * // value === \"I've\"\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getValueByKey<V, T extends object = any>(target: T, path: string, defValue?: V): V {\r\n    if (!path || !target) {\r\n        return defValue;\r\n    }\r\n\r\n    let parts = strSplit(path, \".\");\r\n    let cnt = parts.length;\r\n\r\n    for (let lp = 0; lp < cnt && !isNullOrUndefined(target); lp++) {\r\n        target = target[parts[lp]];\r\n    }\r\n\r\n    return (!isNullOrUndefined(target) ? target : defValue) as V;\r\n}\r\n\r\n/**\r\n * Get the named value from the target object where the path is represented by the string iterator\r\n * or iterable to separate the nested objects of the heirarchy / path to the value. If the target\r\n * does not contain the full path the iterator will not be completed.\r\n *\r\n * The order of processing of the iterator is not reset if you add or remove elements to the iterator,\r\n * the actual behavior will depend on the iterator imeplementation.\r\n *\r\n * If the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes preceedence.\r\n * @since 0.9.1\r\n * @group Value\r\n * @param target - The source object that contains the value\r\n * @param iter - The iter identifying the path of the final key value\r\n * @param defValue - If the final value or any intervening object in the heirarchy is not present\r\n * the default value will be returned\r\n * @returns The value located based on the path or the defaule value\r\n * @example\r\n * ```ts\r\n * let theValue = {\r\n *   Hello: {\r\n *      Darkness: {\r\n *          my: \"old\"\r\n *      }\r\n *   },\r\n *   friend: \"I've\",\r\n *   come: {\r\n *      to: {\r\n *          see: \"you\"\r\n *      }\r\n *   }\r\n * };\r\n *\r\n * let value = getValueByKey(theValue, [\"Hello\", \"Darkness\", \"my\"], \"friend\");\r\n * // value === \"my\"\r\n *\r\n * let value = getValueByKey(theValue, [\"My\", \"Old\"], \"friend\");\r\n * // value === \"friend\"\r\n *\r\n * let value = getValueByKey(theValue, [\"come\", \"to\"], \"friend\");\r\n * // value === { see: \"you\" }\r\n *\r\n * let value = getValueByKey(theValue, [\"friend\"], \"friend\");\r\n * // value === \"I've\"\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getValueByIter<V, T extends object = any>(target: T, iter: Iterator<string> | Iterable<string>, defValue?: V): V {\r\n    if (!iter || !target) {\r\n        return defValue;\r\n    }\r\n\r\n    iterForOf(iter, (value) => {\r\n        if (isNullOrUndefined(target)) {\r\n            return -1;\r\n        }\r\n\r\n        target = target[value];\r\n    });\r\n\r\n    return (!isNullOrUndefined(target) ? target : defValue) as V;\r\n}\r\n\r\n/**\r\n * Set the named value on the target object where the path may be presented by a string which\r\n * contains \".\" characters to separate the nested objects of the heirarchy / path to the value.\r\n * @since 0.9.1\r\n * @group Value\r\n * @param target - The target object\r\n * @param path - The path identifying the location of the final key value\r\n * @param value - The value to set\r\n * @example\r\n * ```ts\r\n * let theValue = { };\r\n * setValueByKey(theValue, \"Hello.Darkness.my\", \"old\");\r\n * // Resulting Object: { Hello: { Darkness: { my: \"old\" } } }\r\n * setValueByKey(theValue, \"friend\", \"I've\");\r\n * // Resulting Object: { Hello: { Darkness: { my: \"old\" } }, friend: \"I've\" }\r\n * setValueByKey(theValue, \"come.to.see\", \"you\");\r\n * // Resulting Object: { Hello: { Darkness: { my: \"old\" } }, friend: \"I've\", come: { to : { see: \"you\" } } }\r\n * ```\r\n */\r\nexport function setValueByKey<T>(target: any, path: string, value: T) {\r\n    if (target && path) {\r\n        let parts = strSplit(path, \".\");\r\n        let lastKey = parts.pop();\r\n    \r\n        arrForEach(parts, (key) => {\r\n            if (isNullOrUndefined(target[key])) {\r\n                // Add an empty object / map\r\n                target[key] = {};\r\n            }\r\n    \r\n            target = target[key];\r\n        });\r\n    \r\n        target[lastKey] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Set the named value on the target object where the path is represented by the string iterator\r\n * or iterable to separate the nested objects of the heirarchy / path to the value.\r\n *\r\n * The order of processing of the iterator is not reset if you add or remove elements to the iterator,\r\n * the actual behavior will depend on the iterator imeplementation.\r\n *\r\n * If the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes preceedence.\r\n * @since 0.9.1\r\n * @group Value\r\n * @param target - The target object\r\n * @param iter - The iter identifying the path of the final key value\r\n * @param value - The value to set\r\n * @example\r\n * ```ts\r\n * let theValue = { };\r\n * setValueByIter(theValue, [\"Hello\", \"Darkness\", \"my\"], \"old\");\r\n * // Resulting Object: { Hello: { Darkness: { my: \"old\" } } }\r\n * setValueByIter(theValue, [\"friend\"], \"I've\");\r\n * // Resulting Object: { Hello: { Darkness: { my: \"old\" } }, friend: \"I've\" }\r\n * setValueByIter(theValue, [\"come\", \"to\", \"see\"], \"you\");\r\n * // Resulting Object: { Hello: { Darkness: { my: \"old\" } }, friend: \"I've\", come: { to : { see: \"you\" } } }\r\n * ```\r\n */\r\nexport function setValueByIter<T>(target: any, iter: Iterator<string> | Iterable<string>, value: T) {\r\n    if (target && iter) {\r\n        let lastKey: string;\r\n    \r\n        iterForOf(iter, (key: string) => {\r\n            if (lastKey) {\r\n                if (isNullOrUndefined(target[lastKey])) {\r\n                    // Add an empty object / map\r\n                    target[lastKey] = {};\r\n                }\r\n        \r\n                target = target[lastKey];\r\n            }\r\n\r\n            lastKey = key;\r\n        });\r\n    \r\n        target[lastKey] = value;\r\n    }\r\n}"]}