{"version":3,"file":"fnProxy.js","sourceRoot":"","sources":["../../src/funcs/fnProxy.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AACtD,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,uBAAuB,CAAC;AAC9D,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAGlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgDG;AACH,MAAM,UAAU,qBAAqB,CAAoC,MAAe,EAAE,QAA0B;IAEhH,OAAO;QACH,sDAAsD;QACtD,IAAI,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,CAAC;QAC/C,IAAI,OAAO,GAAG,MAAM,EAAE,CAAC;QAEvB,OAAO,OAAO,CAAC,OAAO,CAAC,QAAQ,CAA0B,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;IACjF,CAAiB,CAAC;AACtB,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqDG;AACH,MAAM,UAAU,gBAAgB,CAAO,MAAS,EAAE,IAAmB,EAAE,QAAkC;IACrG,IAAI,MAAM,IAAI,IAAI,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE;QACrC,IAAI,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;QAElC,UAAU,CAAC,QAAQ,EAAE,CAAC,OAAO,EAAE,EAAE;YAC7B,IAAI,UAAU,GAAG,CAAC,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,CAAC,CAAQ,CAAC;YAClD,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK,IAAI,MAAM,CAAC,UAAU,CAAC,EAAE;gBAC5C,OAAO;aACV;YAED,MAAM,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,CAAC;gBAC7B,qBAAqB,CAAC,IAAe,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnD,MAAM,CAAE,IAAU,CAAC,OAAO,CAAC,CAAC,CAAa,EAAE,IAAI,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;KACN;IAED,OAAO,MAAM,CAAC;AAClB,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2023 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach } from \"../array/forEach\";\r\nimport { isArray, isFunction } from \"../helpers/base\";\r\nimport { ArrProto, CALL, SLICE } from \"../internal/constants\";\r\nimport { fnApply } from \"./fnApply\";\r\nimport { fnBind } from \"./fnBind\";\r\nimport { ProxyFunctionDef, TypeFuncNames } from \"./types\";\r\n\r\n/**\r\n * Create a deferred proxy function which will call the named function of the result of the hostFn, this enables\r\n * creating bound functions which when called call the proxy the function to a different host (this) instance.\r\n *\r\n * This is different from `fnBind` which is provided with the concrete function and `this` instances, while the proxy\r\n * will lazily obtain the `this` and the function is obtained by looking up the named function from the returned\r\n * host (`this`) instance.\r\n *\r\n * @since 0.9.8\r\n * @group Function\r\n * @param hostFn - A function to get the current host and thisArg that will be called\r\n * @param funcName - The name of the function to call on the host\r\n * @returns The result of calling the function with the specified `this` value and arguments.\r\n * @example\r\n * ```ts\r\n * const module1 = {\r\n *     prefix: \"Hello\",\r\n *     x: 21,\r\n *     getX() {\r\n *         return this.x;\r\n *     },\r\n *     log(value: string) {\r\n *         return this.prefix + \" \" + value + \" : \" + this.x\r\n *     }\r\n * };\r\n *\r\n * // The 'this' parameter of 'getX' is bound to 'module'.\r\n * module1.getX(); // 21\r\n * module1.log(\"Darkness\"); // Hello Darkness : 21\r\n *\r\n * // Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.\r\n * let module2 = {\r\n *     prefix: \"my\",\r\n *     x: 42\r\n * };\r\n *\r\n * let getHost = () => {\r\n *     return module1;\r\n * };\r\n *\r\n * let deferredFn = createFnDeferredProxy(getHost, \"getX\");\r\n *\r\n * deferredFn();   // 21\r\n *\r\n * module2.defX = deferredFn;\r\n *\r\n * module2.defX();  // 21\r\n * ```\r\n */\r\nexport function createFnDeferredProxy<H, F extends (...args:any) => any>(hostFn: () => H, funcName: TypeFuncNames<H>): F {\r\n\r\n    return function() {\r\n        // Capture the original arguments passed to the method\r\n        var theArgs = ArrProto[SLICE][CALL](arguments);\r\n        let theHost = hostFn();\r\n\r\n        return fnApply(theHost[funcName] as (...args: any) => any, theHost, theArgs);\r\n    } as unknown as F;\r\n}\r\n\r\n/**\r\n * Creates proxy functions on the target which internally will call the source version with all arguments passed to the target method.\r\n *\r\n * @since 0.9.8\r\n * @group Function\r\n * @param target - The target object to be assigned with the source properties and functions\r\n * @param host - The host instance or a function to return the host instance which contains the\r\n * functions and will be assigned as the `this` for the function being called.\r\n * @param funcDefs - An array of function definitions on how each named function will be\r\n * proxied onto the target.\r\n * @return The original target after all proxies have been assigned\r\n * @example\r\n * ```ts\r\n * let test = {\r\n *     x: 21,\r\n *     func1() {\r\n *         return this.x;\r\n *     }\r\n * };\r\n *\r\n * test.func1();        // 21\r\n * let newTarget = createProxyFuncs({} as any, test, [\r\n *     { n: \"func1\" },\r\n *     { n: \"func1\", as: \"aliasFn\" }\r\n * ]);\r\n *\r\n * newTarget.func1();   // 21\r\n * newTarget.aliasFn();   // 21\r\n *\r\n * newTarget.x = 42;\r\n *\r\n * // The return is still using the `this.x` from the original `test` as it's proxied\r\n * newTarget.func1();   // 21\r\n * newTarget.aliasFn();   // 21\r\n *\r\n * let getHostFn = () => {\r\n *    return test;\r\n * };\r\n *\r\n * newTarget = createProxyFuncs({} as any, getHostFn, [\r\n *     { n: \"func1\" },\r\n *     { n: \"func1\", as: \"aliasFn\" }\r\n * ]);\r\n *\r\n * newTarget.func1();   // 21\r\n * newTarget.aliasFn();   // 21\r\n *\r\n * newTarget.x = 42;\r\n *\r\n * // The return is still using the `this.x` from the original `test` as it's proxied\r\n * newTarget.func1();   // 21\r\n * newTarget.aliasFn();   // 21\r\n * ```\r\n */\r\nexport function createProxyFuncs<T, H>(target: T, host: H | (() => H), funcDefs: ProxyFunctionDef<T, H>[]): T {\r\n    if (target && host && isArray(funcDefs)) {\r\n        let isDeferred = isFunction(host);\r\n\r\n        arrForEach(funcDefs, (funcDef) => {\r\n            let targetName = (funcDef.as || funcDef.n) as any;\r\n            if (funcDef.rp === false && target[targetName]) {\r\n                return;\r\n            }\r\n\r\n            target[targetName] = isDeferred ?\r\n                createFnDeferredProxy(host as () => H, funcDef.n) :\r\n                fnBind((host as H)[funcDef.n] as Function, host);\r\n        });\r\n    }\r\n\r\n    return target;\r\n}"]}