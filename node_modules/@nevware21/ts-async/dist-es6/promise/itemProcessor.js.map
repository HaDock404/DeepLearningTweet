{"version":3,"file":"itemProcessor.js","sourceRoot":"","sources":["../../src/promise/itemProcessor.ts"],"names":[],"mappings":"AAQA,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,oBAAoB,EAAE,eAAe,EAAE,MAAM,qBAAqB,CAAC;AAQlG,MAAM,oBAAoB,GAAG,CAAC,OAA2B,EAAE,EAAE;IACzD,UAAU,CAAC,OAAO,EAAE,CAAC,EAAoB,EAAE,EAAE;QACzC,IAAI;YACA,EAAE,EAAE,CAAC;SACR;QAAC,OAAO,CAAC,EAAE;SAGX;IACL,CAAC,CAAC,CAAC;AACP,CAAC,CAAA;AAQD,MAAM,UAAU,iBAAiB;IAC7B,OAAO,oBAAoB,CAAC;AAChC,CAAC;AASD,MAAM,UAAU,oBAAoB,CAAC,OAAgB;IACjD,IAAI,eAAe,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IAEtD,OAAO,CAAC,OAA2B,EAAE,EAAE;QACnC,eAAe,CAAC,GAAG,EAAE;YACjB,oBAAoB,CAAC,OAAO,CAAC,CAAC;QAClC,CAAC,EAAE,eAAe,CAAC,CAAC;IACxB,CAAC,CAAA;AACL,CAAC;AAUD,MAAM,UAAU,iBAAiB,CAAC,OAAgB;IAC9C,IAAI,OAAY,CAAC;IACjB,IAAI,OAAO,IAAI,CAAC,EAAE;QACd,OAAO,GAAG;YACN,OAAO,EAAE,CAAC,OAAO;SACpB,CAAC;KACL;IAED,OAAO,CAAC,OAA2B,EAAE,EAAE;QACnC,oBAAoB,CAAC,CAAC,QAAsB,EAAE,EAAE;YAC5C,oBAAoB,CAAC,OAAO,CAAC,CAAC;QAClC,CAAC,EAAE,OAAO,CAAC,CAAC;IAChB,CAAC,CAAC;AACN,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\n\r\nexport type PromisePendingProcessor = (pending: PromisePendingFn[]) => void;\r\nexport type PromisePendingFn = () => void;\r\nexport type PromiseCreatorFn = <T, TResult2 = never>(newExecutor: PromiseExecutor<T>, ...extraArgs: any) => IPromise<T | TResult2>;\r\n\r\nconst _processPendingItems = (pending: PromisePendingFn[]) => {\r\n    arrForEach(pending, (fn: PromisePendingFn) => {\r\n        try {\r\n            fn();\r\n        } catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor(): (pending: PromisePendingFn[]) => void {\r\n    return _processPendingItems;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleTimeout(() => {\r\n            _processPendingItems(pending);\r\n        }, callbackTimeout);\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let options: any;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleIdleCallback((deadline: IdleDeadline) => {\r\n            _processPendingItems(pending);\r\n        }, options);\r\n    };\r\n}"]}