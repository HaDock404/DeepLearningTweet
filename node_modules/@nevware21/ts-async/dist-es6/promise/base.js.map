{"version":3,"file":"base.js","sourceRoot":"","sources":["../../src/promise/base.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    arrForEach, arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined,\r\n    throwTypeError, WellKnownSymbols, objToString, scheduleTimeout, ITimerHandler, getWindow, isNode,\r\n    getGlobal, ILazyValue, objDefine, objDefineProp, lazySafeGetInst\r\n} from \"@nevware21/ts-utils\";\r\nimport { doAwait } from \"./await\";\r\nimport { _addDebugState, _debugLog, _promiseDebugEnabled } from \"./debug\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromisePendingProcessor } from \"./itemProcessor\";\r\nimport {\r\n    FinallyPromiseHandler, PromiseCreatorFn, PromiseExecutor, RejectedPromiseHandler, ResolvedPromiseHandler\r\n} from \"../interfaces/types\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\n\r\nconst NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nconst UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\n\r\nlet _currentPromiseId: number[] = [];\r\nlet _uniquePromiseId = 0;\r\nlet _unhandledRejectionTimeout = 10;\r\n\r\nlet _hasPromiseRejectionEvent: ILazyValue<any>;\r\n\r\nfunction dumpFnObj(value: any) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n\r\n    return dumpObj(value);\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>, ...additionalArgs: any): IPromise<T>;\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>): IPromise<T> {\r\n    let additionalArgs = arrSlice(arguments, 3);\r\n    let _state = ePromiseState.Pending;\r\n    let _hasResolved = false;\r\n    let _settledValue: T;\r\n    let _queue: (() => void)[] = [];\r\n    let _id = _uniquePromiseId++;\r\n    let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    let _handled = false;\r\n    let _unHandledRejectionHandler: ITimerHandler = null;\r\n    let _thePromise: IPromise<T>;\r\n\r\n    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + \"RejectionEvent\"));\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    const _then = <TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): IPromise<TResult1 | TResult2> => {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"then(\" + dumpFnObj(onResolved)+ \", \" + dumpFnObj(onResolved) +  \")\");\r\n            //#endif\r\n            let thenPromise = newPromise<TResult1, TResult2>(function (resolve, reject) {\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        let handler = _state === ePromiseState.Resolved ? onResolved : onRejected;\r\n                        let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n    \r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve as any, reject);\r\n                        } else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value as any);\r\n                        } else if (_state === ePromiseState.Rejected) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        } else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value as any);\r\n                        }\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n    \r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n    \r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n    \r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n    \r\n            return thenPromise;\r\n    \r\n        } finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    const _catch = <TResult1 = T>(onRejected: RejectedPromiseHandler<TResult1>) => {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    const _finally = <TResult1 = T, TResult2 = never>(onFinally: FinallyPromiseHandler): IPromise<TResult1 | TResult2> => {\r\n        let thenFinally: any = onFinally;\r\n        let catchFinally: any = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function(value: TResult1 | TResult2) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            }\r\n    \r\n            catchFinally = function(reason: any) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            }\r\n        }\r\n\r\n        return _then<TResult1, TResult2>(thenFinally as any, catchFinally as any);\r\n    }\r\n\r\n    const _strState = () => {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    const _processQueue = () => {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            let pending = _queue.slice();\r\n            _queue = [];\r\n\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n\r\n            _handled = true;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    const _createSettleIfFn = (newState: ePromiseState, allowState: ePromiseState) => {\r\n        return (theValue: T) => {\r\n            if (_state === allowState) {\r\n                if (newState === ePromiseState.Resolved && isPromiseLike(theValue)) {\r\n                    _state = ePromiseState.Resolving;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(\r\n                        _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Resolving),\r\n                        _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Resolving));\r\n                    return;\r\n                }\r\n\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === ePromiseState.Rejected && !_unHandledRejectionHandler) {\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout)\r\n                }\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n\r\n    const _notifyUnhandledRejection = () => {\r\n        if (!_handled) {\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            } else {\r\n                let gbl = getWindow() || getGlobal();\r\n    \r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, (theEvt: any) => {\r\n                    objDefine(theEvt, \"promise\", { g: () => _thePromise });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    } as any;\r\n\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);\r\n    }\r\n\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol<symbol>(WellKnownSymbols.toStringTag)] = \"IPromise\";\r\n    }\r\n\r\n    const _toString = () => {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\");\r\n    }\r\n\r\n    _thePromise.toString = _toString;\r\n\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n\r\n        const _rejectFn = _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Pending);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(\r\n                _thePromise,\r\n                _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Pending),\r\n                _rejectFn);\r\n        } catch (e) {\r\n            _rejectFn(e);\r\n        }\r\n    })();\r\n\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\nexport function _createAllPromise(newPromise: PromiseCreatorFn): <T>(input: PromiseLike<T>[], ...additionalArgs: any) => IPromise<T[]> {\r\n    return function <T>(input: PromiseLike<T>[]): IPromise<T[]> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<T[]>((resolve, reject) => {\r\n            try {\r\n                let values = [] as any;\r\n                let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n                arrForEach(input, (item, idx) => {\r\n                    if (item) {\r\n                        pending++;\r\n                        doAwait(item, (value) => {\r\n                            // Set the result values\r\n                            values[idx] = value;\r\n                            if (--pending === 0) {\r\n                                resolve(values);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\nexport function _createResolvedPromise(newPromise: PromiseCreatorFn): <T>(value: T, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(value: T): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike<T>(value)) {\r\n            return value as unknown as IPromise<T>;\r\n        }\r\n    \r\n        return newPromise((resolve) => {\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\nexport function _createRejectedPromise(newPromise: PromiseCreatorFn): <T>(reason: any, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(reason: any): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise((_resolve, reject) => {\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n"]}