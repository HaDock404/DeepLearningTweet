{"version":3,"file":"ts-polyfills-async.min.js","sources":["../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/internal/constants.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/helpers/base.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/object/get_own_prop_desc.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/object/has_own.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/object/has_own_prop.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/object/for_each_key.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/helpers/throw.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/object/object.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/internal/map.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/symbol/well_known.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/internal/global.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/string/as_string.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/helpers/diagnostics.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/internal/unwrapFunction.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/helpers/lazy.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/polyfills/symbol.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/object/define.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/helpers/safe_lazy.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/helpers/safe_get.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/helpers/environment.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/symbol/symbol.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/funcs/fnApply.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/array/forEach.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/array/slice.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/timer/handler.js","../../../common/temp/node_modules/@nevware21/ts-utils/dist-es5/timer/timeout.js","../../dist-es5/internal/state.js","../../dist-es5/promise/event.js","../../dist-es5/promise/base.js","../../dist-es5/internal/constants.js","../../dist-es5/promise/asyncPromise.js","../../dist-es5/promise/itemProcessor.js","../../dist-es5/promise/await.js","../../dist-es5/polyfills.js","../../dist-es5/polyfills/promise.js"],"sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n// These constants are currently NOT exported directly, we may export them later associated with a frozen namespace (maybe)\r\n// For now do NOT expect that we will export these values.\r\nexport var UNDEF_VALUE = undefined;\r\nexport var NULL_VALUE = null;\r\nexport var EMPTY = \"\";\r\nexport var BOOLEAN = \"boolean\";\r\nexport var FUNCTION = \"function\";\r\nexport var NUMBER = \"number\";\r\nexport var OBJECT = \"object\";\r\nexport var PROTOTYPE = \"prototype\";\r\nexport var __PROTO__ = \"__proto__\";\r\nexport var STRING = \"string\";\r\nexport var UNDEFINED = \"undefined\";\r\nexport var CONSTRUCTOR = \"constructor\";\r\nexport var SYMBOL = \"Symbol\";\r\nexport var POLYFILL_TAG = \"_polyfill\";\r\nexport var INDEX_OF = \"indexOf\";\r\nexport var LAST_INDEX_OF = \"lastIndexOf\";\r\nexport var LENGTH = \"length\";\r\nexport var DONE = \"done\";\r\nexport var VALUE = \"value\";\r\nexport var NAME = \"name\";\r\nexport var SLICE = \"slice\";\r\n/**\r\n * @ignore\r\n */\r\nexport var ObjClass = Object;\r\n/**\r\n * @ignore\r\n */\r\nexport var ObjProto = ObjClass[PROTOTYPE];\r\n/**\r\n * @ignore\r\n */\r\nexport var StrCls = String;\r\n/**\r\n * @ignore\r\n */\r\nexport var StrProto = StrCls[PROTOTYPE];\r\n/**\r\n * @ignore\r\n */\r\nexport var MathCls = Math;\r\n/**\r\n * @ignore\r\n */\r\nexport var ArrCls = Array;\r\n/**\r\n * @ignore\r\n */\r\nexport var ArrProto = ArrCls[PROTOTYPE];\r\n//# sourceMappingURL=constants.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { ArrCls, BOOLEAN, FUNCTION, NULL_VALUE, NUMBER, OBJECT, ObjProto, STRING, UNDEFINED, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { safeGet } from \"./safe_get\";\r\nvar PRIMITIVE_TYPES = [STRING, NUMBER, BOOLEAN, UNDEFINED, \"symbol\", \"bigint\"];\r\n/**\r\n * @ignore\r\n * @internal\r\n * Create and returns a function that will return `true` if the argument passed\r\n * to it matches the provided type.\r\n * @param theType - The type to match against the `typeof value`\r\n * @returns A function which takes a single argument and returns a boolean\r\n */\r\nexport function _createIs(theType) {\r\n    return function (value) {\r\n        return typeof value === theType;\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Create and returns a function that will return `true` if the argument passed\r\n * to it matches the object type specified based on {@link objToString}.\r\n * @param - The object name to match for the `objToString(value)`\r\n * @returns A function which takes a single argument and returns a boolean\r\n */\r\nexport function _createObjIs(theName) {\r\n    var theType = \"[object \" + theName + \"]\";\r\n    return function (value) {\r\n        return !!(value && objToString(value) === theType);\r\n    };\r\n}\r\n/**\r\n * The `objToString()` method returns a string representing the object. This explicitly\r\n * always calls the `Object.prototype.toString()` method.\r\n *\r\n * An object's toString() method is most commonly invoked when that object undergoes:\r\n * - explicit type conversion to a string (for example, String(myObject))\r\n * - implicit type coercion into a string (for example, myObject + \"hello world\")\r\n *\r\n * @group Object\r\n * @param value - The object to be converted into a string\r\n * @returns A string representation of the object\r\n * @example\r\n * ```ts\r\n * objToString(new Date()); // [object Date]\r\n * objToString(new String()); // [object String]\r\n *\r\n * // Math has its Symbol.toStringTag\r\n * objToString(Math); // [object Math]\r\n *\r\n * objToString(undefined); // [object Undefined]\r\n * objToString(null); // [object Null]\r\n * ```\r\n */\r\nexport function objToString(value) {\r\n    return ObjProto.toString.call(value);\r\n}\r\n/**\r\n * Validate if the provided value object is of the expected type\r\n * @group Type Identity\r\n * @param value - The value to check\r\n * @param theType - The expected type name as a string\r\n * @returns `true` if the value matches the provided type\r\n */\r\nexport function isTypeof(value, theType) {\r\n    return typeof value === theType;\r\n}\r\n/**\r\n * Checks if the provided value is undefined or contains the string value \"undefined\",\r\n * if you want to consider the string value as undefined see {@link isStrictUndefined}\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param value - The value to check\r\n * @returns true if the value is undefined or \"undefined\", otherwise false\r\n * @example\r\n * ```ts\r\n * isUndefined(undefined);              // true\r\n * isUndefined(\"undefined\");            // true\r\n *\r\n * isUndefined(null);                   // false\r\n * isUndefined(\"null\");                 // false\r\n * isUndefined(\"1\");                    // false\r\n * isUndefined(\"aa\");                   // false\r\n * isUndefined(new Date());             // false\r\n * isUndefined(1);                      // false\r\n * isUndefined(\"\");                     // false\r\n * isUndefined(_dummyFunction);         // false\r\n * isUndefined([]);                     // false\r\n * isUndefined(new Array(1));           // false\r\n * isUndefined(true);                   // false\r\n * isUndefined(false);                  // false\r\n * isUndefined(\"true\");                 // false\r\n * isUndefined(\"false\");                // false\r\n * isUndefined(new Boolean(true));      // false\r\n * isUndefined(new Boolean(false));     // false\r\n * isUndefined(new Boolean(\"true\"));    // false\r\n * isUndefined(new Boolean(\"false\"));   // false\r\n * isUndefined(Boolean(true));          // false\r\n * isUndefined(Boolean(false));         // false\r\n * isUndefined(Boolean(\"true\"));        // false\r\n * isUndefined(Boolean(\"false\"));       // false\r\n * isUndefined(new RegExp(\"\"));         // false\r\n * isUndefined(new ArrayBuffer(0));     // false\r\n * isUndefined(new Error(\"Test Error\"));// false\r\n * isUndefined(new TypeError(\"Test TypeError\"));    // false\r\n * isUndefined(new TestError(\"Test TestError\"));    // false\r\n * isUndefined(_dummyError());          // false\r\n * isUndefined(Promise.reject());       // false\r\n * isUndefined(Promise.resolve());      // false\r\n * isUndefined(new Promise(() => {}));  // false\r\n * isUndefined(_simplePromise());       // false\r\n * isUndefined(_simplePromiseLike());   // false\r\n * isUndefined(Object.create(null));    // false\r\n * isUndefined(polyObjCreate(null));    // false\r\n * ```\r\n */\r\nexport function isUndefined(value) {\r\n    return typeof value === UNDEFINED || value === UNDEFINED;\r\n}\r\n/**\r\n * Checks if the provided value is undefined, a string value of \"undefined\" is NOT considered\r\n * to be undefined.\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param value - The value to check\r\n * @returns true if the typeof value === UNDEFINED\r\n * @example\r\n * ```ts\r\n * isStrictUndefined(undefined);    // true\r\n *\r\n * isStrictUndefined(null);         // false\r\n * isStrictUndefined(\"null\");       // false\r\n * isStrictUndefined(\"undefined\");  // false\r\n * isStrictUndefined(\"1\");          // false\r\n * isStrictUndefined(\"aa\");         // false\r\n * isStrictUndefined(new Date());   // false\r\n * isStrictUndefined(0);            // false\r\n * isStrictUndefined(1);            // false\r\n * isStrictUndefined(\"\");           // false\r\n * ```\r\n */\r\nexport function isStrictUndefined(arg) {\r\n    return !isDefined(arg);\r\n}\r\n/**\r\n * Checks if the provided value is null, undefined or contains the string value of \"undefined\".\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param value - The value to check\r\n * @returns `true` if the value is `null` or `undefined`\r\n * @example\r\n * ```ts\r\n * isNullOrUndefined(null);         // true\r\n * isNullOrUndefined(undefined);    // true\r\n * isNullOrUndefined(\"undefined\");  // true\r\n *\r\n * let value = null;\r\n * isNullOrUndefined(value);        // true\r\n * let value = undefined;\r\n * isNullOrUndefined(value);        // true\r\n *\r\n * isNullOrUndefined(\"\");           // false\r\n * isNullOrUndefined(0);            // false\r\n * isNullOrUndefined(new Date());   // false\r\n * isNullOrUndefined(true);         // false\r\n * isNullOrUndefined(false);        // false\r\n * ```\r\n */\r\nexport function isNullOrUndefined(value) {\r\n    return value === NULL_VALUE || isUndefined(value);\r\n}\r\n/**\r\n * Checks if the provided value is null, undefined only, a string value of \"undefined\" is NOT considered\r\n * to be undefined.\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param value - The value to check\r\n * @returns\r\n * @example\r\n * ```ts\r\n * isStrictNullOrUndefined(null);         // true\r\n * isStrictNullOrUndefined(undefined);    // true\r\n * isStrictNullOrUndefined(\"undefined\");  // false\r\n *\r\n * let value = null;\r\n * isStrictNullOrUndefined(value);        // true\r\n * let value = undefined;\r\n * isStrictNullOrUndefined(value);        // true\r\n *\r\n * isStrictNullOrUndefined(\"\");           // false\r\n * isStrictNullOrUndefined(0);            // false\r\n * isStrictNullOrUndefined(new Date());   // false\r\n * isStrictNullOrUndefined(true);         // false\r\n * isStrictNullOrUndefined(false);        // false\r\n * ```\r\n */\r\nexport function isStrictNullOrUndefined(value) {\r\n    return value === NULL_VALUE || !isDefined(value);\r\n}\r\n/**\r\n * Checks if the passed value is defined, which means it has any value and is not undefined.\r\n * A string value of \"undefined\" is considered to be defined.\r\n * @group Value Check\r\n * @param arg - The value to check\r\n * @returns true if arg has a value (is not === undefined)\r\n * @example\r\n * ```ts\r\n * isDefined(null);         // false\r\n * isDefined(undefined);    // false\r\n * isDefined(\"undefined\");  // true\r\n *\r\n * let value = null;\r\n * isDefined(value);        // false\r\n * let value = undefined;\r\n * isDefined(value);        // false\r\n *\r\n * isDefined(\"\");           // true\r\n * isDefined(0);            // true\r\n * isDefined(new Date());   // true\r\n * isDefined(true);         // true\r\n * isDefined(false);        // true\r\n * ```\r\n */\r\nexport function isDefined(arg) {\r\n    return !!arg || arg !== UNDEF_VALUE;\r\n}\r\n/**\r\n * Identifies whether the provided value is a JavaScript [primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\r\n * which is when is it not an object and has no methods or properties. There are 7 primitive data types:\r\n * - string\r\n * - number\r\n * - bigint\r\n * - boolean\r\n * - undefined\r\n * - null\r\n * - symbol\r\n *\r\n * Most of the time, a primitive value is represented directly at the lowest level of the language implementation.\r\n *\r\n * All primitives are immutable; that is, they cannot be altered. It is important not to confuse a primitive itself\r\n * with a variable assigned a primitive value. The variable may be reassigned to a new value, but the existing value\r\n * can not be changed in the ways that objects, arrays, and functions can be altered. The language does not offer\r\n * utilities to mutate primitive values.\r\n * @since 0.4.4\r\n * @group Type Identity\r\n * @param value - The value to check whether it's a primitive value\r\n * @example\r\n * ```ts\r\n * isPrimitive(null);                   // true\r\n * isPrimitive(undefined);              // true\r\n * isPrimitive(\"null\");                 // true\r\n * isPrimitive(\"undefined\");            // true\r\n * isPrimitive(\"1\");                    // true\r\n * isPrimitive(\"aa\");                   // true\r\n * isPrimitive(1);                      // true\r\n * isPrimitive(Number(2));              // true\r\n * isPrimitive(\"\");                     // true\r\n * isPrimitive(String(\"\"));             // true\r\n * isPrimitive(true);                   // true\r\n * isPrimitive(false);                  // true\r\n * isPrimitive(\"true\");                 // true\r\n * isPrimitive(\"false\");                // true\r\n * isPrimitive(BigInt(42));             // true\r\n * isPrimitive(Symbol.for(\"Hello\"));    // true\r\n *\r\n * isPrimitive(new String(\"aa\"));       // false\r\n * isPrimitive(new Date());             // false\r\n * isPrimitive(_dummyFunction);         // false\r\n * isPrimitive([]);                     // false\r\n * isPrimitive(new Array(1));           // false\r\n * isPrimitive(new Boolean(true));      // false\r\n * isPrimitive(new Boolean(false));     // false\r\n * isPrimitive(new Boolean(\"true\"));    // false\r\n * isPrimitive(new Boolean(\"false\"));   // false\r\n * ```\r\n */\r\nexport var isPrimitive = function (value) {\r\n    return value === NULL_VALUE || isPrimitiveType(typeof value);\r\n};\r\n/**\r\n * Identifies whether the provided value is a JavaScript [primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\r\n * which is when is it not an object and has no methods or properties. There are 6 primitive data types:\r\n * - string\r\n * - number\r\n * - bigint\r\n * - boolean\r\n * - undefined\r\n * - symbol\r\n *\r\n * Most of the time, a primitive value is represented directly at the lowest level of the language implementation.\r\n *\r\n * All primitives are immutable; that is, they cannot be altered. It is important not to confuse a primitive itself\r\n * with a variable assigned a primitive value. The variable may be reassigned to a new value, but the existing value\r\n * can not be changed in the ways that objects, arrays, and functions can be altered. The language does not offer\r\n * utilities to mutate primitive values.\r\n * @since 0.9.6\r\n * @group Type Identity\r\n * @param theType - The type as a string value to be checked whther it's a primitive type, this should be the value\r\n * returned from `typeof value`.\r\n * @example\r\n * ```ts\r\n * isPrimitiveType(null);                   // false\r\n * isPrimitiveType(undefined);              // false\r\n * isPrimitiveType(\"null\");                 // false\r\n * isPrimitiveType(\"undefined\");            // false\r\n * isPrimitiveType(\"1\");                    // false\r\n * isPrimitiveType(\"aa\");                   // false\r\n * isPrimitiveType(1);                      // false\r\n * isPrimitiveType(Number(2));              // false\r\n * isPrimitiveType(\"\");                     // false\r\n * isPrimitiveType(String(\"\"));             // false\r\n * isPrimitiveType(true);                   // false\r\n * isPrimitiveType(false);                  // false\r\n * isPrimitiveType(\"true\");                 // false\r\n * isPrimitiveType(\"false\");                // false\r\n * isPrimitiveType(BigInt(42));             // false\r\n * isPrimitiveType(Symbol.for(\"Hello\"));    // false\r\n *\r\n * isPrimitiveType(\"string\");               // true\r\n * isPrimitiveType(\"number\");               // true\r\n * isPrimitiveType(\"boolean\");              // true\r\n * isPrimitiveType(\"undefined\");            // true\r\n * isPrimitiveType(\"symbol\");               // true\r\n * isPrimitiveType(\"bigint\");               // true\r\n * ```\r\n */\r\nexport var isPrimitiveType = function (theType) {\r\n    return theType !== OBJECT && PRIMITIVE_TYPES.indexOf(theType) !== -1;\r\n};\r\n/**\r\n * Checks to see if the past value is a string value\r\n * @group Type Identity\r\n * @group String\r\n * @param value - The value to check\r\n * @returns\r\n * @example\r\n * ```ts\r\n * isString(\"\");            // true\r\n * isString(\"null\");        // true\r\n * isString(\"undefined\");   // true\r\n * isString(String(\"\"));    // true\r\n *\r\n * isString(null);          // false\r\n * isString(undefined);     // false\r\n * isString(0);             // false\r\n * ```\r\n */\r\nexport var isString = _createIs(STRING);\r\n/**\r\n * Checks to see if the past value is a function value\r\n * @group Type Identity\r\n * @param value - The value to check\r\n * @returns\r\n * @example\r\n * ```ts\r\n * function myFunction() { }\r\n * isFunction(null);            // false\r\n * isFunction(undefined);       // false\r\n * isFunction(\"null\");          // false\r\n * isFunction(\"undefined\");     // false\r\n * isFunction(\"1\");             // false\r\n * isFunction(\"aa\");            // false\r\n * isFunction(new Date());      // false\r\n * isFunction(1);               // false\r\n * isFunction(\"\");              // false\r\n * isFunction(myFunction);      // true\r\n * isFunction([]);              // false\r\n * isFunction(new Array(1));    // false\r\n * ```\r\n */\r\nexport var isFunction = _createIs(FUNCTION);\r\n/**\r\n * Checks to see if the past value is an object value\r\n * @group Type Identity\r\n * @group Object\r\n * @typeParam T - The object type, defaults to any\r\n * @param value - The value to check\r\n * @returns\r\n */\r\nexport function isObject(value) {\r\n    if (!value && isNullOrUndefined(value)) {\r\n        return false;\r\n    }\r\n    return !!value && typeof value === OBJECT;\r\n}\r\n/**\r\n * Checks if the type of value is an Array.\r\n *\r\n * @group Type Identity\r\n * @group Array\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a Array, false otherwise.\r\n * @example\r\n * ```ts\r\n * import { isArray, isObject } from \"@nevware21/ts-utils\";\r\n *\r\n * function performAction(value: any) {\r\n *     if (isArray(value) || isObject(value)) {\r\n *         // Do something\r\n *     } else {\r\n *         // Do something else\r\n *     }\r\n * }\r\n * ```\r\n */\r\nexport var isArray = ArrCls.isArray;\r\n/**\r\n * Check if an object is of type Date\r\n * @group Type Identity\r\n * @example\r\n * ```ts\r\n * import { isDate } from \"@nevware21/ts-utils\";\r\n *\r\n * let _theDate = null;\r\n *\r\n * function getSetDate(newDate?: any) {\r\n *     _theDate = isDate(newDate) ? newDate : new Date();\r\n *\r\n *     return _theDate;\r\n * }\r\n * ```\r\n */\r\nexport var isDate = _createObjIs(\"Date\");\r\n/**\r\n * Checks if the type of value is a number.\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a number, false otherwise.\r\n */\r\nexport var isNumber = _createIs(NUMBER);\r\n/**\r\n * Checks if the type of value is a boolean.\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a boolean, false otherwise.\r\n */\r\nexport var isBoolean = _createIs(BOOLEAN);\r\n/**\r\n * Determines if a value is a regular expression object.\r\n * @group Type Identity\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is a `RegExp`.\r\n */\r\nexport var isRegExp = _createObjIs(\"RegExp\");\r\n/**\r\n * Checks if the type of value is a File object.\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a File, false otherwise.\r\n */\r\nexport var isFile = _createObjIs(\"File\");\r\n/**\r\n * Checks if the type of value is a FormData object.\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a FormData, false otherwise.\r\n */\r\nexport var isFormData = _createObjIs(\"FormData\");\r\n/**\r\n * Checks if the type of value is a Blob object.\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a Blob, false otherwise.\r\n */\r\nexport var isBlob = _createObjIs(\"Blob\");\r\n/**\r\n * Checks if the type of value is a ArrayBuffer object.\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a ArrayBuffer, false otherwise.\r\n */\r\nexport var isArrayBuffer = _createObjIs(\"ArrayBuffer\");\r\n/**\r\n * Checks if the type of value is a Error object.\r\n * @group Type Identity\r\n * @group Error\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a Error, false otherwise.\r\n */\r\nexport var isError = _createObjIs(\"Error\");\r\n/**\r\n * Checks if the type of value is a PromiseLike instance (contains a then function).\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a PromiseLike, false otherwise.\r\n */\r\nexport function isPromiseLike(value) {\r\n    return !!value && isFunction(value.then);\r\n}\r\n/**\r\n * Checks if the type of value is a PromiseLike instance (contains a then function).\r\n * This is an alias for {@link isPromiseLike}.\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a PromiseLike, false otherwise.\r\n */\r\nexport var isThenable = isPromiseLike;\r\n/**\r\n * Checks if the type of value is a Promise instance (contains then and catch functions).\r\n * @group Type Identity\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a Promise, false otherwise.\r\n */\r\nexport function isPromise(value) {\r\n    return isPromiseLike(value) && isFunction(value.catch);\r\n}\r\n/**\r\n * Checks if the type of value does not evaluate to true value, handling some special\r\n * case usages of Boolean(true/false) and new Boolean(true/false).\r\n * @group Value Check\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is not truthy, false otherwise.\r\n */\r\nexport function isNotTruthy(value) {\r\n    return !value || !safeGet(function () { return (value && (0 + value)); }, value);\r\n}\r\n/**\r\n * Checks if the type of value evaluates to true value, handling some special\r\n * case usages of Boolean(true/false) and new Boolean(true/false).\r\n * @group Value Check\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is not truthy, false otherwise.\r\n */\r\nexport function isTruthy(value) {\r\n    // Objects created with no prototype (Object.create(null)) cannot be converted to primitives\r\n    // Which causes this code to throw, additionally just using !! also fails for Boolean objects\r\n    // !!(new Boolean(false)) evaluates to true\r\n    return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));\r\n    //return !(!value || !(value && (0 + value)));\r\n}\r\n//# sourceMappingURL=base.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { ObjClass } from \"../internal/constants\";\r\n/**\r\n * The objGetOwnPropertyDescriptor() method returns an object describing the configuration of a specific property on\r\n * a given object (that is, one directly present on an object and not in the object's prototype chain). The object\r\n * returned is mutable but mutating it has no effect on the original property's configuration.\r\n * @since 0.4.3\r\n * @group Object\r\n * @param target - Object that contains the property.\r\n * @param prop - Name of the property.\r\n * @returns A property descriptor of the given property if it exists on the object, otherwise undefined.\r\n *\r\n * @example\r\n * ```ts\r\n * o = {};\r\n * objDefineProp(o, 'qux', {\r\n *   value: 8675309,\r\n *   writable: false,\r\n *   enumerable: false\r\n * });\r\n * d = objGetOwnPropertyDescriptor(o, 'qux');\r\n * // d is {\r\n * //   value: 8675309,\r\n * //   writable: false,\r\n * //   enumerable: false,\r\n * //   configurable: false\r\n * // }\r\n *\r\n * objGetOwnPropertyDescriptor('foo', 0);\r\n * // TypeError: \"foo\" is not an object  // ES5 code\r\n *\r\n * objGetOwnPropertyDescriptor('foo', 0);\r\n * // Object returned by ES2015 code: {\r\n * //   configurable: false,\r\n * //   enumerable: true,\r\n * //   value: \"f\",\r\n * //   writable: false\r\n * // }\r\n * ```\r\n * Note: In ES5, if the first argument to this method is not an object (a primitive), then it will cause a TypeError. In ES2015, a non-object first argument will be coerced to an object at first.\r\n */\r\nexport var objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;\r\n//# sourceMappingURL=get_own_prop_desc.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { ObjClass } from \"../internal/constants\";\r\nimport { objGetOwnPropertyDescriptor } from \"./get_own_prop_desc\";\r\nimport { objHasOwnProperty } from \"./has_own_prop\";\r\n/**\r\n * The objHasOwn() method returns a boolean indicating whether the object\r\n * has the specified property as its own property (as opposed to inheriting it).\r\n * If the property is inherited, or does not exist, the method returns false.\r\n *\r\n * The objHasOwn() method returns true if the specified property is a direct property\r\n * of the object — even if the property value is null or undefined. The method returns\r\n * false if the property is inherited, or has not been declared at all. Unlike the in operator,\r\n * this method does not check for the specified property in the object's prototype chain.\r\n *\r\n * It is recommended over {@link objHasOwnProperty} () because it works for objects created using\r\n * objCreate(null) and with objects that have overridden the inherited hasOwnProperty() method.\r\n * While it is possible to workaround these problems by calling Object.prototype.hasOwnProperty()\r\n * on an external object, Object.hasOwn() is more intuitive.\r\n *\r\n * @since 0.4.3\r\n * @group Object\r\n * @param obj - The object being evaluated\r\n * @param prop - The String or Symbol of the property to test\r\n * @returns `true` if the object has the specified property as own property; otherwise `false`\r\n * @example\r\n * ```ts\r\n * let example = {};\r\n * objHasOwn(example, 'prop');   // false\r\n *\r\n * example.prop = 'exists';\r\n * objHasOwn(example, 'prop');   // true - 'prop' has been defined\r\n *\r\n * example.prop = null;\r\n * objHasOwn(example, 'prop');   // true - own property exists with value of null\r\n *\r\n * example.prop = undefined;\r\n * objHasOwn(example, 'prop');   // true - own property exists with value of undefined\r\n * ```\r\n */\r\nexport var objHasOwn = ObjClass[\"hasOwn\"] || polyObjHasOwn;\r\n/**\r\n * The polyObjHasOwn() method is a polyfill for {@link objHasOwn} when the native\r\n * [Object.hasOwnreturns](https://caniuse.com/?search=hasOwn) is not supported, it returns a\r\n * boolean indicating whether the object has the specified property as its own property (as\r\n * opposed to inheriting it). If the property is inherited, or does not exist, the method\r\n * returns false.\r\n *\r\n * The objHasOwn() method returns true if the specified property is a direct property\r\n * of the object — even if the property value is null or undefined. The method returns\r\n * false if the property is inherited, or has not been declared at all. Unlike the in operator,\r\n * this method does not check for the specified property in the object's prototype chain.\r\n *\r\n * It is recommended over objHasOwnProperty() because it works for objects created using\r\n * objCreate(null) and with objects that have overridden the inherited hasOwnProperty() method.\r\n * While it is possible to workaround these problems by calling Object.prototype.hasOwnProperty()\r\n * on an external object, Object.hasOwn() is more intuitive.\r\n *\r\n * @since 0.4.3\r\n * @group Object\r\n * @group Polyfill\r\n * @param obj - The object being evaluated\r\n * @param prop - The String or Symbol of the property to test\r\n * @returns `true` if the object has the specified property as own property; otherwise `false`\r\n * @example\r\n * ```ts\r\n * let example = {};\r\n * polyObjHasOwn(example, 'prop');   // false\r\n *\r\n * example.prop = 'exists';\r\n * polyObjHasOwn(example, 'prop');   // true - 'prop' has been defined\r\n *\r\n * example.prop = null;\r\n * polyObjHasOwn(example, 'prop');   // true - own property exists with value of null\r\n *\r\n * example.prop = undefined;\r\n * polyObjHasOwn(example, 'prop');   // true - own property exists with value of undefined\r\n * ```\r\n */\r\nexport function polyObjHasOwn(obj, prop) {\r\n    return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);\r\n}\r\n//# sourceMappingURL=has_own.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { ObjProto } from \"../internal/constants\";\r\n/**\r\n * The objHasOwnProperty() method returns a boolean indicating whether the object\r\n * has the specified property as its own property (as opposed to inheriting it).\r\n *\r\n * The objHasOwnProperty() method returns true if the specified property is a direct\r\n * property of the object — even if the value is null or undefined. The method returns\r\n * false if the property is inherited, or has not been declared at all. Unlike the in\r\n * operator, this method does not check for the specified property in the object's\r\n * prototype chain.\r\n *\r\n * The method can be called on most JavaScript objects, because most objects descend\r\n * from Object, and hence inherit its methods. For example Array is an Object, so you\r\n * can use objHasOwnProperty() method to check whether an index exists:\r\n * @group Object\r\n * @param obj - The object being evaluated\r\n * @param prop - The String or Symbol of the property to test\r\n * @returns `true` if the object has the specified property as own property; otherwise `false`\r\n * @example\r\n * ```ts\r\n * let example = {};\r\n * objHasOwnProperty(example, 'prop');   // false\r\n *\r\n * example.prop = 'exists';\r\n * objHasOwnProperty(example, 'prop');   // true - 'prop' has been defined\r\n *\r\n * example.prop = null;\r\n * objHasOwnProperty(example, 'prop');   // true - own property exists with value of null\r\n *\r\n * example.prop = undefined;\r\n * objHasOwnProperty(example, 'prop');   // true - own property exists with value of undefined\r\n * ```\r\n */\r\nexport function objHasOwnProperty(obj, prop) {\r\n    return obj && ObjProto.hasOwnProperty.call(obj, prop);\r\n}\r\n//# sourceMappingURL=has_own_prop.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { isObject } from \"../helpers/base\";\r\nimport { objHasOwn } from \"./has_own\";\r\n/**\r\n * Calls the provided `callbackFn` function once for each key in an object. This is equivelent to `arrForEach(Object.keys(theObject), callbackFn)` or\r\n * if not using the array helper `Object.keys(theObject).forEach(callbackFn)` except that this helper avoid creating a temporary of the object\r\n * keys before iterating over them and like the `arrForEach` helper you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n * @group Object\r\n * @typeParam T - The object type\r\n * @param callbackfn  A function that accepts up to two arguments, the key name and the current value of the property represented by the key.\r\n * @param thisArg  [Optional] An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the object will be used as the this value.\r\n * @example\r\n * ```ts\r\n * function performAction<T>(target: T, source: any) {\r\n *    if (!isNullOrUndefined(source)) {\r\n *        objForEachKey(source, (key, value) => {\r\n *            // Set the target with a reference to the same value with the same name\r\n *            target[key] = value;\r\n *        });\r\n *    }\r\n *\r\n *    return target;\r\n * }\r\n * ```\r\n */\r\nexport function objForEachKey(theObject, callbackfn, thisArg) {\r\n    if (theObject && isObject(theObject)) {\r\n        for (var prop in theObject) {\r\n            if (objHasOwn(theObject, prop)) {\r\n                if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=for_each_key.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n/**\r\n * Throw an error exception with the specified optional message\r\n * @group Error\r\n * @param message\r\n */\r\nexport function throwError(message) {\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Throw a type error with the specified optional message\r\n * @group Error\r\n * @param message\r\n */\r\nexport function throwTypeError(message) {\r\n    throw new TypeError(message);\r\n}\r\n/**\r\n * Throw a RangeError with the specified optional message\r\n * @group Error\r\n * @param message\r\n */\r\nexport function throwRangeError(message) {\r\n    throw new RangeError(message);\r\n}\r\n//# sourceMappingURL=throw.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { NULL_VALUE, ObjClass, __PROTO__ } from \"../internal/constants\";\r\nimport { isArray, isObject } from \"../helpers/base\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { objForEachKey } from \"./for_each_key\";\r\nimport { polyObjEntries, polyObjValues } from \"../polyfills/object\";\r\nvar _objFreeze = ObjClass[\"freeze\"];\r\nvar _doNothing = function (value) { return value; };\r\nvar _getProto = function (value) { return value[__PROTO__] || NULL_VALUE; };\r\n/**\r\n * The `objAssign()` method copies all enumerable own properties from one or more source objects\r\n * to a target object. It returns the modified target object.\r\n *\r\n * Properties in the target object are overwritten by properties in the sources if they have the\r\n * same key. Later sources' properties overwrite earlier ones.\r\n *\r\n * The objAssign() method only copies enumerable and own properties from a source object to a\r\n * target object. It uses `Get` on the source and `Set` on the target, so it will invoke\r\n * [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) and\r\n * [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\r\n * Therefore it assigns properties, versus copying or defining new properties. This may make it\r\n * unsuitable for merging new properties into a prototype if the merge sources contain getters.\r\n *\r\n * For copying property definitions (including their enumerability) into prototypes, use\r\n * {@link objGetOwnPropertyDescriptor} and {@link objDefineProp} instead.\r\n *\r\n * Both String and Symbol properties are copied.\r\n *\r\n * In case of an error, for example if a property is non-writable, a TypeError is raised, and\r\n * the target object is changed if any properties are added before the error is raised.\r\n * @group Object\r\n * @example\r\n * ```ts\r\n * const obj = { a: 1 };\r\n * const copy = objAssign({}, obj);\r\n * console.log(copy); // { a: 1 }\r\n *\r\n * const o1 = { a: 1 };\r\n * const o2 = { b: 2 };\r\n * const o3 = { c: 3 };\r\n *\r\n * const obj = objAssign(o1, o2, o3);\r\n * console.log(obj); // { a: 1, b: 2, c: 3 }\r\n * console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.\r\n * ```\r\n */\r\nexport var objAssign = ObjClass[\"assign\"];\r\n/**\r\n * The `objKeys()` method returns an array of a given object's own enumerable property names, iterated in\r\n * the same order that a normal loop would.\r\n *\r\n * objKeys() returns an array whose elements are strings corresponding to the enumerable properties found\r\n * directly upon object. The ordering of the properties is the same as that given by looping over the\r\n * properties of the object manually.\r\n * @group Object\r\n * @param value - The object to obtain a copy of the keys from\r\n * @returns An array of the properties names for the value object.\r\n * @example\r\n * ```ts\r\n * // simple array\r\n * const arr = ['a', 'b', 'c'];\r\n * console.log(objKeys(arr)); // console: ['0', '1', '2']\r\n *\r\n * // array-like object\r\n * const obj = { 0: 'a', 1: 'b', 2: 'c' };\r\n * console.log(objKeys(obj)); // console: ['0', '1', '2']\r\n *\r\n * // array-like object with random key ordering\r\n * const anObj = { 100: 'a', 2: 'b', 7: 'c' };\r\n * console.log(objKeys(anObj)); // console: ['2', '7', '100']\r\n *\r\n * // getFoo is a property which isn't enumerable\r\n * const myObj = objCreate({}, {\r\n *   getFoo: {\r\n *     value() { return this.foo; }\r\n *   }\r\n * });\r\n * myObj.foo = 1;\r\n * console.log(objKeys(myObj)); // console: ['foo']\r\n * ```\r\n */\r\nexport function objKeys(value) {\r\n    if (!isObject(value) || value === NULL_VALUE) {\r\n        throwTypeError(\"objKeys called on non-object\");\r\n    }\r\n    return ObjClass.keys(value);\r\n}\r\n/**\r\n * Perform a deep freeze on the object and all of it's contained values / properties by recursively calling\r\n * `objFreeze()` on all enumerable properties of the object and on each property returned.\r\n * @group Object\r\n * @param value - the object to be completly frozen.\r\n * @returns The originally passed in object.\r\n */\r\nexport function objDeepFreeze(value) {\r\n    if (_objFreeze) {\r\n        objForEachKey(value, function (key, value) {\r\n            if (isArray(value) || isObject(value)) {\r\n                _objFreeze(value);\r\n            }\r\n        });\r\n    }\r\n    return objFreeze(value);\r\n}\r\n/**\r\n * The `objFreeze()` method freezes an object. A frozen object can no longer be changed; freezing an object\r\n * prevents new properties from being added to it, existing properties from being removed, prevents changing the\r\n * enumerability, configurability, or writability of existing properties, and prevents the values of existing\r\n * properties from being changed. In addition, freezing an object also prevents its prototype from being changed.\r\n * `objFreeze()` returns the same object that was passed in.\r\n *\r\n * Nothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail,\r\n * either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\r\n *\r\n * For data properties of a frozen object, values cannot be changed, the writable and configurable attributes are\r\n * set to false. Accessor properties (getters and setters) work the same (and still give the illusion that you are\r\n * changing the value). Note that values that are objects can still be modified, unless they are also frozen. As\r\n * an object, an array can be frozen; after doing so, its elements cannot be altered and no elements can be added\r\n * to or removed from the array.\r\n *\r\n * `objFreeze()` returns the same object that was passed into the function. It does not create a frozen copy.\r\n * @group Object\r\n * @param value - The object to freeze.\r\n * @returns The object that was passed to the function.\r\n */\r\nexport var objFreeze = _objFreeze || _doNothing;\r\n/**\r\n * The `objSeal()` method seals an object, preventing new properties from being added to it and marking all\r\n * existing properties as non-configurable. Values of present properties can still be changed as long as they\r\n * are writable.\r\n * @group Object\r\n * @param value - The object which should be sealed.\r\n * @returns The object being sealed.\r\n */\r\nexport var objSeal = ObjClass[\"seal\"] || _doNothing;\r\n/**\r\n * The objGetPrototypeOf() method returns the prototype (i.e. the value of the internal `Prototype` property)\r\n * of the specified value.\r\n * @since 0.4.4\r\n * @group Object\r\n * @param value - The object whose prototype is to be returned, which may be null.\r\n */\r\nexport var objGetPrototypeOf = ObjClass[\"getPrototypeOf\"] || _getProto;\r\n/**\r\n * Returns an array of key/values of the enumerable properties of an object\r\n * @since 0.9.7\r\n * @group Object\r\n * @group ArrayLike\r\n * @param value Object that contains the properties and methods.\r\n * @example\r\n * ```ts\r\n * objEntries({ Hello: \"Darkness\", my: \"old\", friend: \".\" });\r\n * // [ [ \"Hello\", \"Darkness\" ], [ \"my\", \"old\"], [ \"friend\", \".\" ] ]\r\n *\r\n * // Array-like object\r\n * objEntries({ 0: \"a\", 1: \"b\", 2: \"c\" }));\r\n * // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]\r\n *\r\n * // Array-like object with random key ordering\r\n * objEntries({ 100: \"a\", 2: \"b\", 7: \"c\" });\r\n * // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]*\r\n * ```\r\n */\r\nexport var objEntries = ObjClass.entries || polyObjEntries;\r\n/**\r\n * The objValues() returns an array whose elements are values of enumerable string-keyed properties found\r\n * directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop\r\n * enumerates properties in the prototype chain as well. The order of the array returned by objValues()\r\n * is the same as that provided by a for...in loop.\r\n *\r\n * If you need the property keys, use objKeys() instead. If you need both the property keys and values, use objEntries() instead.\r\n * @since 0.9.7\r\n * @group Object\r\n * @group ArrayLike\r\n * @param value - The object that contains the properties and methods.\r\n * @returns An array containing the given object's own enumerable string-keyed property values.\r\n * @example\r\n * ```ts\r\n * objValues({ Hello: \"Darkness\", my: \"old\", friend: \".\" });\r\n * // [ \"Darkness\", \"old\", \".\" ]\r\n *\r\n * // Array-like object\r\n * objValues({ 0: \"a\", 1: \"b\", 2: \"c\" }));\r\n * // [ 'a', 'b', 'c']\r\n *\r\n * // Array-like object with random key ordering\r\n * objValues({ 100: \"a\", 2: \"b\", 7: \"c\" });\r\n * // [ 'b', 'c', 'a']\r\n * ```\r\n */\r\nexport var objValues = ObjClass.values || polyObjValues;\r\n//# sourceMappingURL=object.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { objForEachKey } from \"../object/for_each_key\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal Helper function to create a key and value mapped representation of the values\r\n * @param values - The source values\r\n * @param keyType - Identifies the value to populate against the key\r\n * @param valueType - Identifies the value to populate against the value\r\n * @param completeFn - The function to call to complete the map (used to freeze the instance)\r\n * @returns\r\n */\r\nexport function _createKeyValueMap(values, keyType, valueType, completeFn) {\r\n    var theMap = {};\r\n    objForEachKey(values, function (key, value) {\r\n        theMap[key] = keyType ? value : key;\r\n        theMap[value] = valueType ? value : key;\r\n    });\r\n    return completeFn(theMap);\r\n}\r\n//# sourceMappingURL=map.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { createEnumKeyMap } from \"../helpers/enum\";\r\n/**\r\n * @ignore\r\n * @internal\r\n */\r\nexport var _wellKnownSymbolMap = createEnumKeyMap({\r\n    asyncIterator: 0 /* WellKnownSymbols.asyncIterator */,\r\n    hasInstance: 1 /* WellKnownSymbols.hasInstance */,\r\n    isConcatSpreadable: 2 /* WellKnownSymbols.isConcatSpreadable */,\r\n    iterator: 3 /* WellKnownSymbols.iterator */,\r\n    match: 4 /* WellKnownSymbols.match */,\r\n    matchAll: 5 /* WellKnownSymbols.matchAll */,\r\n    replace: 6 /* WellKnownSymbols.replace */,\r\n    search: 7 /* WellKnownSymbols.search */,\r\n    species: 8 /* WellKnownSymbols.species */,\r\n    split: 9 /* WellKnownSymbols.split */,\r\n    toPrimitive: 10 /* WellKnownSymbols.toPrimitive */,\r\n    toStringTag: 11 /* WellKnownSymbols.toStringTag */,\r\n    unscopables: 12 /* WellKnownSymbols.unscopables */\r\n});\r\n//# sourceMappingURL=well_known.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { UNDEFINED } from \"./constants\";\r\nvar GLOBAL_CONFIG_KEY = \"__tsUtils$gblCfg\";\r\nvar _globalCfg;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper to get the current global value\r\n * @returns\r\n */\r\nexport function _getGlobalValue() {\r\n    var result;\r\n    if (typeof globalThis !== UNDEFINED) {\r\n        result = globalThis;\r\n    }\r\n    if (!result && typeof self !== UNDEFINED) {\r\n        result = self;\r\n    }\r\n    if (!result && typeof window !== UNDEFINED) {\r\n        result = window;\r\n    }\r\n    if (!result && typeof global !== UNDEFINED) {\r\n        result = global;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Gets/Sets the named value from the global config store, this is used to share configuration across\r\n * multiple modules. Primarily used for poly symbol and test hooks.\r\n * @returns The globally registered value.\r\n */\r\nexport function _getGlobalConfig() {\r\n    if (!_globalCfg) {\r\n        var gbl = _getGlobalValue() || {};\r\n        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};\r\n    }\r\n    return _globalCfg;\r\n}\r\n//# sourceMappingURL=global.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { StrCls } from \"../internal/constants\";\r\n/**\r\n * The asString() method returns a string representing the value by\r\n * explicitly using `String(`value`)`.\r\n *\r\n * @since 0.4.3\r\n * @group String\r\n * @group Conversion\r\n * @group Value\r\n * @param value - The value to get a string representation of\r\n * @example\r\n * ```ts\r\n * const arr = [ 1, 2, 3];\r\n * asString(arr);       // \"1,2,3\"\r\n * asString(null);      // \"null\"\r\n * asString(undefined); // \"undefined\"\r\n * asString(42);        // \"42\"\r\n * asString(Symbol.for(\"Hello\"));   // \"Symbol(Hello)\"\r\n * ```\r\n */\r\nexport var asString = StrCls;\r\n//# sourceMappingURL=as_string.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { EMPTY, NULL_VALUE, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { isError, isNumber, objToString } from \"./base\";\r\n/**\r\n * Returns string representation of an object suitable for diagnostics logging.\r\n * @group Error\r\n * @group Diagnostic\r\n * @param object - The object to be converted to a diagnostic string value\r\n * @param format - Identifies whether the JSON value should be formated\r\n * - `true` - Format with 4 spaces\r\n * - 'number' - The number of spaces to format with\r\n * - `false` (or not Truthy) - Do not format\r\n */\r\nexport function dumpObj(object, format) {\r\n    var propertyValueDump = EMPTY;\r\n    if (isError(object)) {\r\n        propertyValueDump = \"{ stack: '\" + object.stack + \"', message: '\" + object.message + \"', name: '\" + object.name + \"'\";\r\n    }\r\n    else {\r\n        try {\r\n            propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);\r\n        }\r\n        catch (e) {\r\n            // Unable to convert object (probably circular)\r\n            propertyValueDump = \" - \" + dumpObj(e, format);\r\n        }\r\n    }\r\n    return objToString(object) + \": \" + propertyValueDump;\r\n}\r\n//# sourceMappingURL=diagnostics.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { dumpObj } from \"../helpers/diagnostics\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { asString } from \"../string/as_string\";\r\nimport { ArrProto, SLICE } from \"./constants\";\r\nvar _arrSlice = ArrProto[SLICE];\r\nvar _throwMissingFunction = function (funcName, thisArg) {\r\n    throwTypeError(\"'\" + asString(funcName) + \"' not defined for \" + dumpObj(thisArg));\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to run the named function on the passed first argument, this does not support polyfill\r\n * or prototype fallback, so the function must exist on the provided first argument.\r\n * If the first argument is null, undefined or the function does not exist an exception will be thrown\r\n * by the runtime\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport var _unwrapInstFunction = function (funcName) {\r\n    return function (thisArg) {\r\n        return thisArg[funcName].apply(thisArg, _arrSlice.call(arguments, 1));\r\n    };\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport var _unwrapFunction = function (funcName, clsProto) {\r\n    var clsFn = clsProto && clsProto[funcName];\r\n    return function (thisArg) {\r\n        var theFunc = (thisArg && thisArg[funcName]) || clsFn;\r\n        if (theFunc) {\r\n            return theFunc.apply(thisArg, _arrSlice.call(arguments, 1));\r\n        }\r\n        _throwMissingFunction(funcName, thisArg);\r\n    };\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @param polyFunc - The function to call if not available on the thisArg, act like the polyfill\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport var _unwrapFunctionWithPoly = function (funcName, clsProto, polyFunc) {\r\n    var clsFn = clsProto && clsProto[funcName];\r\n    return function (thisArg) {\r\n        var theFunc = (thisArg && thisArg[funcName]) || clsFn;\r\n        if (theFunc || polyFunc) {\r\n            var theArgs = arguments;\r\n            return (theFunc || polyFunc).apply(thisArg, theFunc ? _arrSlice.call(theArgs, 1) : theArgs);\r\n        }\r\n        _throwMissingFunction(funcName, thisArg);\r\n    };\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to lookup and return the named property from the first argument (which becomes the this)\r\n *\r\n * @since 0.4.2\r\n * @typeParam T - The type of the object which contains the propName\r\n * @param propName - The property name\r\n * @returns The value of the property\r\n */\r\nexport function _unwrapProp(propName) {\r\n    return function (thisArg) {\r\n        return thisArg[propName];\r\n    };\r\n}\r\n//# sourceMappingURL=unwrapFunction.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { NULL_VALUE } from \"../internal/constants\";\r\nimport { _getGlobalConfig } from \"../internal/global\";\r\nimport { objDefineProp } from \"../object/define\";\r\n/**\r\n * @internal\r\n * Internal flag which is set by the public {@link setBypassLazyCache}, should not be externally exported\r\n */\r\nexport var _globalLazyTestHooks;\r\nvar _fetchLazyTestHooks = function () {\r\n    _globalLazyTestHooks = _getGlobalConfig();\r\n    _fetchLazyTestHooks = NULL_VALUE;\r\n};\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally.\r\n * @since 0.4.5\r\n * @group Lazy\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns A new readonly {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = getLazy(() => callSomeExpensiveFunction());\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * ```\r\n */\r\nexport function getLazy(cb) {\r\n    var lazyValue = {};\r\n    _fetchLazyTestHooks && _fetchLazyTestHooks();\r\n    lazyValue.b = _globalLazyTestHooks.lzy;\r\n    objDefineProp(lazyValue, \"v\", {\r\n        configurable: true,\r\n        get: function () {\r\n            var result = cb();\r\n            if (!_globalLazyTestHooks.lzy) {\r\n                // Just replace the value\r\n                objDefineProp(lazyValue, \"v\", {\r\n                    value: result\r\n                });\r\n                if (lazyValue.b) {\r\n                    delete lazyValue.b;\r\n                }\r\n            }\r\n            if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {\r\n                lazyValue.b = _globalLazyTestHooks.lzy;\r\n            }\r\n            return result;\r\n        }\r\n    });\r\n    return lazyValue;\r\n}\r\n/**\r\n * Test Hook function used to cause the internal caching of objects to be bypassed, this should never\r\n * be enabled for production as it has additional performance impact caused by the repetitive creation\r\n * of the lazy wrappers.\r\n * @group Lazy\r\n * @since 0.5.0\r\n * @param newValue - When `true` will cause all new lazy implementations to bypass the cached lookup.\r\n */\r\nexport function setBypassLazyCache(newValue) {\r\n    _fetchLazyTestHooks && _fetchLazyTestHooks();\r\n    _globalLazyTestHooks.lzy = newValue;\r\n}\r\n/**\r\n * Create and return a writable {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally. The\r\n * value may be set as many times as required, if the callback has not been called when you set the value\r\n * it will never get called.\r\n * @since 0.9.4\r\n * @group Lazy\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns A new writable {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = getWritableLazy(() => callSomeExpensiveFunction());\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * // Setting the value\r\n * let cachedValue = getWritableLazy(() => callSomeExpensiveFunction());\r\n * let theValue = \"new Value\";\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will set the value to be set explicitly and the callback\r\n *     // will now never occur and the result will be cached\r\n *     cachedValue.v = theValue;\r\n * }\r\n *\r\n * // Accessing the value again will cause the previously set value to be returned.\r\n * theValue === cachedValue.v;  // true\r\n * ```\r\n */\r\nexport function getWritableLazy(cb) {\r\n    var lazyValue = {};\r\n    _fetchLazyTestHooks && _fetchLazyTestHooks();\r\n    lazyValue.b = _globalLazyTestHooks.lzy;\r\n    var _setValue = function (newValue) {\r\n        // Just replace the value\r\n        objDefineProp(lazyValue, \"v\", {\r\n            value: newValue,\r\n            writable: true\r\n        });\r\n        if (lazyValue.b) {\r\n            delete lazyValue.b;\r\n        }\r\n    };\r\n    objDefineProp(lazyValue, \"v\", {\r\n        configurable: true,\r\n        get: function () {\r\n            var result = cb();\r\n            if (!_globalLazyTestHooks.lzy) {\r\n                // Just replace the value\r\n                _setValue(result);\r\n            }\r\n            if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {\r\n                lazyValue.b = _globalLazyTestHooks.lzy;\r\n            }\r\n            return result;\r\n        },\r\n        set: _setValue\r\n    });\r\n    return lazyValue;\r\n}\r\n//# sourceMappingURL=lazy.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { _wellKnownSymbolMap } from \"../symbol/well_known\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { POLYFILL_TAG, SYMBOL } from \"../internal/constants\";\r\nimport { objHasOwn } from \"../object/has_own\";\r\nimport { asString } from \"../string/as_string\";\r\nimport { _getGlobalConfig } from \"../internal/global\";\r\nimport { strStartsWith } from \"../string/starts_with\";\r\nimport { objKeys } from \"../object/object\";\r\nvar UNIQUE_REGISTRY_ID = \"_urid\";\r\nvar _polySymbols;\r\nfunction _globalSymbolRegistry() {\r\n    if (!_polySymbols) {\r\n        var gblCfg = _getGlobalConfig();\r\n        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };\r\n    }\r\n    return _polySymbols;\r\n}\r\nvar _wellKnownSymbolCache = {};\r\n/**\r\n * Returns a new (polyfill) Symbol object for the provided description that's guaranteed to be unique.\r\n * Symbols are often used to add unique property keys to an object that won't collide with keys any\r\n * other code might add to the object, and which are hidden from any mechanisms other code will\r\n * typically use to access the object. That enables a form of weak encapsulation, or a weak form of\r\n * information hiding.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param description - The description of the symbol\r\n * @returns A new polyfill version of a Symbol object\r\n */\r\nexport function polyNewSymbol(description) {\r\n    var theSymbol = {\r\n        description: asString(description),\r\n        toString: function () { return SYMBOL + \"(\" + description + \")\"; }\r\n    };\r\n    // Tag the symbol so we know it a polyfill\r\n    theSymbol[POLYFILL_TAG] = true;\r\n    return theSymbol;\r\n}\r\n/**\r\n * Returns a Symbol object from the global symbol registry matching the given key if found.\r\n * Otherwise, returns a new symbol with this key.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param key key to search for.\r\n */\r\nexport function polySymbolFor(key) {\r\n    var registry = _globalSymbolRegistry();\r\n    if (!objHasOwn(registry.k, key)) {\r\n        var newSymbol_1 = polyNewSymbol(key);\r\n        var regId_1 = objKeys(registry.s).length;\r\n        newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + \"_\" + newSymbol_1.toString(); };\r\n        registry.k[key] = newSymbol_1;\r\n        registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);\r\n    }\r\n    return registry.k[key];\r\n}\r\n/**\r\n * Returns a key from the global symbol registry matching the given Symbol if found.\r\n * Otherwise, returns a undefined.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param sym Symbol to find the key for.\r\n */\r\nexport function polySymbolKeyFor(sym) {\r\n    if (!sym || !sym.toString || !strStartsWith(sym.toString(), SYMBOL)) {\r\n        throwTypeError(sym + \" is not a symbol\");\r\n    }\r\n    var regId = sym[POLYFILL_TAG] && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();\r\n    return regId ? _globalSymbolRegistry().s[regId] : undefined;\r\n}\r\n/**\r\n * Returns the polyfill version of a well-known global symbol, this will only return\r\n * known values.\r\n * @example\r\n * ```ts\r\n * // Always returns the polyfill version, even if Symbols are supported in the runtime\r\n * polyGetKnownSymbol(\"toStringTag\") === polyGetKnownSymbol(\"toStringTag\");                // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) === polyGetKnownSymbol(\"toStringTag\"); // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== Symbol.toStringTag;                // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== Symbol.toStringTag; // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== polySymbolFor(\"toStringTag\");      // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== polySymbolFor(\"toStringTag\"); // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== polyNewSymbol(\"toStringTag\");      // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== polyNewSymbol(\"toStringTag\"); // true\r\n * ```\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param name - The property name to return (if it exists) for Symbol\r\n * @returns The value of the property if present\r\n */\r\nexport function polyGetKnownSymbol(name) {\r\n    var result;\r\n    var knownName = _wellKnownSymbolMap[name];\r\n    if (knownName) {\r\n        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + \".\" + knownName);\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=symbol.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { ObjClass, VALUE } from \"../internal/constants\";\r\nimport { isFunction, isUndefined } from \"../helpers/base\";\r\nimport { objForEachKey } from \"./for_each_key\";\r\nimport { objGetOwnPropertyDescriptor } from \"./get_own_prop_desc\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Mapping from ObjDefinePropDescriptor key to PropertyDescriptor key\r\n */\r\nvar propMap = {\r\n    e: \"enumerable\",\r\n    c: \"configurable\",\r\n    v: VALUE,\r\n    w: \"writable\",\r\n    g: \"get\",\r\n    s: \"set\"\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper to convert ObjDefinePropDescriptor into PropertyDescriptor\r\n * @param value - The prop descriptor to convert\r\n * @returns\r\n */\r\nfunction _createProp(value) {\r\n    var prop = {};\r\n    prop[propMap[\"c\"]] = true;\r\n    prop[propMap[\"e\"]] = true;\r\n    if (value.l) {\r\n        // Asign a getter function to return the value when requested\r\n        prop.get = function () { return value.l.v; };\r\n        // If it has a setter then expose it as well\r\n        var desc = objGetOwnPropertyDescriptor(value.l, \"v\");\r\n        if (desc && desc.set) {\r\n            prop.set = function (newValue) {\r\n                value.l.v = newValue;\r\n            };\r\n        }\r\n    }\r\n    objForEachKey(value, function (key, value) {\r\n        prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;\r\n    });\r\n    return prop;\r\n}\r\n/**\r\n * Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\r\n * This is a wrapper for [Object.defineProperty](https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/object/defineproperty)\r\n *\r\n * This method allows a precise addition to or modification of a property on an object. Normal property addition through\r\n * assignment creates properties which show up during property enumeration (for...in loop or objKeys method), whose\r\n * values may be changed, and which may be deleted. This method allows these extra details to be changed from their\r\n * defaults. By default, properties added using objDefineProp() are not writable, not enumerable, and not configurable.\r\n *\r\n * Property descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data\r\n * descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property\r\n * described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\r\n *\r\n * This is an alias for Object.defineProperty\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param key - The name or Symbol of the property to be defined or modified.\r\n * @param descriptor - The descriptor for the property being defined or modified.\r\n */\r\nexport var objDefineProp = ObjClass[\"defineProperty\"];\r\n/**\r\n * The objDefineProperties() method defines new or modifies existing properties directly on an object, returning the object.\r\n * This is a wrapper for [Object.defineProperties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)\r\n * @since 0.6.0\r\n * @group Object\r\n * @param target - The object on which to define or modify properties.\r\n * @param props - An object whose keys represent the names of properties to be defined or modified and whose values are\r\n * objects describing those properties. Each value in props must be either a data descriptor or an accessor descriptor;\r\n * it cannot be both (see {@link ObjDefinePropDescriptorMap} for more details).\r\n * @returns\r\n */\r\nexport var objDefineProperties = ObjClass[\"defineProperties\"];\r\n/**\r\n * Try to define a get object property accessor for the target object, if a function is past as the value this will\r\n * be assumed to be a getter function and NOT the value.\r\n * @deprecated It is recommended that you use {@link objDefine} instead {@link objDefineGet} or {@link objDefineAccessors}\r\n * as it provides a deterministic way for identifying whether the value is a value or a function rather than wrapping any\r\n * function value in another function.\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param key - The name of the property to be defined or modified\r\n * @param value - The value or a function that returns the value\r\n * @param configurable - Can the value be changed, defaults to true.\r\n * @param enumerable - Should this get property be enumerable, defaults to true.\r\n * @returns The object that was passed to the function\r\n */\r\nexport function objDefineGet(target, key, value, configurable, enumerable) {\r\n    var _a;\r\n    return objDefineProp(target, key, _createProp((_a = {\r\n            e: enumerable,\r\n            c: configurable\r\n        },\r\n        _a[isFunction(value) ? \"g\" : \"v\"] = value,\r\n        _a)));\r\n}\r\n/**\r\n * Try to define get/set object property accessors for the target object/prototype, this will provide compatibility with\r\n * existing API definition when run within an ES5+ container that supports accessors but still enable the code to be loaded\r\n * and executed in an ES3 container, providing basic IE8 compatibility.\r\n * @deprecated It is recommended that you use {@link objDefine} instead {@link objDefineAccessors} as this internally creates\r\n * the {@link ObjDefinePropDescriptor} definition based on your provided arguments. And only using a minimum set of functions\r\n * reduces your overall bundle size.\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param prop - The name of the property to be defined or modified.\r\n * @param getProp - The getter function to wire against the getter.\r\n * @param setProp - The setter function to wire against the setter.\r\n * @param configurable - Can the value be changed, defaults to true\r\n * @param enumerable - Should this get property be enumerable, defaults to true.\r\n * @returns The object that was passed to the function\r\n */\r\nexport function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {\r\n    var desc = {\r\n        e: enumerable,\r\n        c: configurable\r\n    };\r\n    if (getProp) {\r\n        desc.g = getProp;\r\n    }\r\n    if (setProp) {\r\n        desc.s = setProp;\r\n    }\r\n    return objDefineProp(target, prop, _createProp(desc));\r\n}\r\n/**\r\n * The objDefine() method defines a new or modifies an existing single property accessors for the target object based\r\n * on the configuration defined for the propDesc argument of type {@link ObjDefinePropDescriptor}. This will call\r\n * {@link objDefineProp} after creating the required PropertyDescriptor populating defaults for the propDesc values.\r\n * Note, the default values (true) for `configurable` and `enumerable` are different from the defaults provided by objDefineProp.\r\n * @since 0.6.0\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param key - The name of the property to be defined or modified\r\n * @param propDesc - An object which defines the Property Descriptor mappings for the mapping.\r\n * @returns The target object.\r\n */\r\nexport function objDefine(target, key, propDesc) {\r\n    return objDefineProp(target, key, _createProp(propDesc));\r\n}\r\n/**\r\n * The objDefineProps() method defines new or modifies existing properties directly for the target object using the keys\r\n * and configuration from the propDescMap argument. This will call {@link objDefineProperties} after creating the required\r\n * PropertyDescriptorMap from the propDescMap values.\r\n * Note, the default values (true) for `configurable` and `enumerable` are different from the defaults provided by objDefineProperties.\r\n * @since 0.6.0\r\n * @group Object\r\n * @param target - The object on which to define or modify properties.\r\n * @param propDescMap - An object whose keys represent the names of properties to be defined or modified and whose values are\r\n * objects describing those properties. Each value in props must be either a data descriptor or an accessor descriptor;\r\n * it cannot be both (see {@link ObjDefinePropDescriptorMap} for more details).\r\n * @returns The target object.\r\n */\r\nexport function objDefineProps(target, propDescMap) {\r\n    var props = {};\r\n    objForEachKey(propDescMap, function (key, value) {\r\n        props[key] = _createProp(value);\r\n    });\r\n    return objDefineProperties(target, props);\r\n}\r\n//# sourceMappingURL=define.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { getLazy } from \"./lazy\";\r\nimport { safeGet } from \"./safe_get\";\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally.\r\n * If the callback throws the default value will be returned.\r\n * @since 0.9.5\r\n * @group Lazy\r\n * @group Safe\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @param defValue - The default value to return when an exception is thrown\r\n * @returns A new readonly {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = safeGetLazy(() => callSomeExpensiveFunctionWhichMightThrow(), \"someDefaultValue\");\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * ```\r\n */\r\nexport function safeGetLazy(cb, defValue) {\r\n    return getLazy(function () { return safeGet(cb, defValue); });\r\n}\r\n//# sourceMappingURL=safe_lazy.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n/**\r\n * Function to safely execute a callback function, if the function throws the provided default\r\n * value will be returned.\r\n * @since 0.9.5\r\n * @group Safe\r\n * @param cb - Callback function be wrapped with an exception\r\n * @param defValue - The default value to return when an exception is thrown\r\n * @returns The result of the callback function or the default if an exception occurred calling the callback\r\n * function.\r\n * @example\r\n * ```ts\r\n * let theExpression = \"{ invalid: json value\";\r\n *\r\n * let result = safeGet(() => {\r\n *     return JSON.parse(theExpression);\r\n * }, {});\r\n *\r\n * // result === {};\r\n * ```\r\n */\r\nexport function safeGet(cb, defValue) {\r\n    var result = defValue;\r\n    try {\r\n        result = cb();\r\n    }\r\n    catch (e) {\r\n        // Do nothing\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=safe_get.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { NULL_VALUE, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { _getGlobalValue } from \"../internal/global\";\r\nimport { safeGetLazy } from \"./safe_lazy\";\r\nimport { _globalLazyTestHooks } from \"./lazy\";\r\nvar WINDOW = \"window\";\r\nvar _cachedGlobal;\r\nvar _cachedWindow;\r\nvar _cachedDocument;\r\nvar _cachedNavigator;\r\nvar _cachedHistory;\r\nvar _isWebWorker;\r\nvar _isNode;\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the named global\r\n * value if available, will return `null` if the named global object is not available or if the runtime\r\n * throws an exception when attempting to access the global object.\r\n * Unlike {@link getInst} the value is cached after the first access, so if the global value changes after\r\n * the initial fetch the original cached value is still returned.\r\n * @since 0.9.5\r\n * @group Environment\r\n * @group Lazy\r\n * @group Safe\r\n * @param name The name of the global object to get.\r\n * @returns A new readonly {@link ILazyValue} instance which will lazily attempt to return the globally\r\n * available named instance.\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * window.myGlobal = \"Hello\";\r\n * let cachedValue = lazySafeGetInst(\"myGlobal\");\r\n * // cachedValue.v === \"Hello\"\r\n *\r\n * window.myGlobal = \"Darkness\";\r\n * // cachedValue.v === \"Hello\"\r\n *\r\n * let promiseCls = lazySafeGetInst(\"Promise\");\r\n * // null if Promise is not supported in the runtime\r\n * // otherwise the Promise class.\r\n * ```\r\n */\r\nexport var lazySafeGetInst = function (name) { return safeGetLazy(function () { return getInst(name) || UNDEF_VALUE; }, UNDEF_VALUE); };\r\n/**\r\n * Returns the current global scope object, for a normal web page this will be the current\r\n * window, for a Web Worker this will be current worker global scope via \"self\". The internal\r\n * implementation returns the first available instance object in the following order\r\n * - globalThis (New standard)\r\n * - self (Will return the current window instance for supported browsers)\r\n * - window (fallback for older browser implementations)\r\n * - global (NodeJS standard)\r\n * - <null> (When all else fails)\r\n * While the return type is a Window for the normal case, not all environments will support all\r\n * of the properties or functions. And this caches the lookup of the global as in some environments\r\n * this can be an expensive operation.\r\n * @group Environment\r\n * @param useCached - [Optional] used for testing to bypass the cached lookup, when `true` this will\r\n * cause the cached global to be reset.\r\n */\r\nexport var getGlobal = function (useCached) {\r\n    (!_cachedGlobal || useCached === false || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));\r\n    return _cachedGlobal.v;\r\n};\r\n/**\r\n * Return the named global object if available, will return null if the object is not available.\r\n * @group Environment\r\n * @param name The globally named object\r\n * @param useCached - [Optional] used for testing to bypass the cached lookup, when `true` this will\r\n * cause the cached global to be reset.\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * window.myGlobal = \"Hello\";\r\n * let cachedValue = getInst(\"myGlobal\");\r\n * // cachedValue === \"Hello\"\r\n *\r\n * window.myGlobal = \"Darkness\";\r\n * // getInst(\"myGlobal\") === \"Darkness\"\r\n *\r\n * let promiseCls = getInst(\"Promise\");\r\n * // May throw if the global is not supported by the runtime\r\n * // otherwise the Promise class.\r\n * ```\r\n */\r\nexport var getInst = function (name, useCached) {\r\n    var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;\r\n    if (gbl && gbl[name]) {\r\n        return gbl[name];\r\n    }\r\n    // Test workaround, for environments where <global>.window (when global == window) doesn't return the base window\r\n    if (name === WINDOW && _cachedWindow) {\r\n        // tslint:disable-next-line: no-angle-bracket-type-assertion\r\n        return _cachedWindow.v;\r\n    }\r\n    return NULL_VALUE;\r\n};\r\n/**\r\n * Identify whether the runtime contains a `document` object\r\n * @group Environment\r\n * @returns - True if a `document` exists\r\n */\r\nexport var hasDocument = function () { return !!getDocument(); };\r\n/**\r\n * Return the global `document` instance.\r\n * @group Environment\r\n * @returns\r\n */\r\nexport var getDocument = function () {\r\n    (!_cachedDocument || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedDocument.b)) && (_cachedDocument = lazySafeGetInst(\"document\"));\r\n    return _cachedDocument.v;\r\n};\r\n/**\r\n * Identify whether the runtime contains a `window` object\r\n * @group Environment\r\n * @returns\r\n */\r\nexport var hasWindow = function () { return !!getWindow(); };\r\n/**\r\n * Return the global `window` instance.\r\n * @group Environment\r\n * @returns\r\n */\r\nexport var getWindow = function () {\r\n    (!_cachedWindow || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedWindow.b)) && (_cachedWindow = lazySafeGetInst(WINDOW));\r\n    return _cachedWindow.v;\r\n};\r\n/**\r\n * Identify whether the runtimne contains a `navigator` object\r\n * @group Environment\r\n * @returns\r\n */\r\nexport var hasNavigator = function () { return !!getNavigator(); };\r\n/**\r\n * Returns the global `navigator` instance\r\n * @group Environment\r\n * @returns\r\n */\r\nexport var getNavigator = function () {\r\n    (!_cachedNavigator || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedNavigator.b)) && (_cachedNavigator = lazySafeGetInst(\"navigator\"));\r\n    return _cachedNavigator.v;\r\n};\r\n/**\r\n * Identifies whether the runtime contains a `history` object\r\n * @group Environment\r\n * @returns\r\n */\r\nexport var hasHistory = function () { return !!getHistory(); };\r\n/**\r\n * Returns the global `history` instance\r\n * @group Environment\r\n * @returns\r\n */\r\nexport var getHistory = function () {\r\n    (!_cachedHistory || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedHistory.b)) && (_cachedHistory = lazySafeGetInst(\"history\"));\r\n    return _cachedHistory.v;\r\n};\r\n/**\r\n * Simple method to determine if we are running in a node environment\r\n * @group Environment\r\n * @returns True if you are\r\n */\r\nexport var isNode = function () {\r\n    !_isNode && (_isNode = safeGetLazy(function () { return !!(process && (process.versions || {}).node); }, false));\r\n    return _isNode.v;\r\n};\r\n/**\r\n * Helper to identify if you are running as a Dedicated, Shared or Service worker\r\n * @group Environment\r\n * @returns True if the environment you are in looks like a Web Worker\r\n */\r\nexport var isWebWorker = function () {\r\n    !_isWebWorker && (_isWebWorker = safeGetLazy(function () { return !!(self && self instanceof WorkerGlobalScope); }, false));\r\n    return _isWebWorker.v;\r\n};\r\n//# sourceMappingURL=environment.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { NULL_VALUE, SYMBOL, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { polyGetKnownSymbol, polyNewSymbol, polySymbolFor, polySymbolKeyFor } from \"../polyfills/symbol\";\r\nimport { _wellKnownSymbolMap } from \"./well_known\";\r\nimport { _createIs } from \"../helpers/base\";\r\nimport { _globalLazyTestHooks } from \"../helpers/lazy\";\r\nimport { safeGetLazy } from \"../helpers/safe_lazy\";\r\nimport { lazySafeGetInst } from \"../helpers/environment\";\r\nvar _symbol;\r\nvar _symbolFor;\r\nvar _symbolKeyFor;\r\nfunction _getSymbolValue(name) {\r\n    return safeGetLazy(function () {\r\n        return (_symbol.v ? _symbol.v[name] : UNDEF_VALUE);\r\n    }, UNDEF_VALUE);\r\n}\r\n/**\r\n * Checks if the type of value is a symbol.\r\n * @group Symbol\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a symbol, false otherwise.\r\n */\r\nexport var isSymbol = _createIs(\"symbol\");\r\n/**\r\n * Helper to identify whether the runtime support the Symbols either via native or an installed polyfill\r\n * @group Symbol\r\n * @returns true if Symbol's are support otherwise false\r\n */\r\nexport function hasSymbol() {\r\n    return !!getSymbol();\r\n}\r\n/**\r\n * If Symbols are supported then attempt to return the named Symbol\r\n * @group Symbol\r\n * @returns The value of the named Symbol (if available)\r\n */\r\nexport function getSymbol() {\r\n    var resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);\r\n    resetCache && (_symbol = lazySafeGetInst(SYMBOL));\r\n    (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue(\"for\"));\r\n    (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue(\"keyFor\"));\r\n    return _symbol.v;\r\n}\r\n/**\r\n * If Symbols are supported then get the property of the global Symbol, if Symbol's are\r\n * not supported and noPoly is true it returns null. Used to access the well known symbols.\r\n * @group Symbol\r\n * @param name - The property name to return (if it exists) for Symbol\r\n * @param noPoly - Flag indicating whether to return a polyfill if symbols are not supported.\r\n * @returns The value of the property if present\r\n * @example\r\n * ```ts\r\n * // If Symbol is supported in the runtime\r\n * getKnownSymbol(\"toStringTag\") === Symbol.toStringTag;                // true\r\n * getKnownSymbol(WellKnownSymbols.toStringTag) === Symbol.toStringTag; // true\r\n * ```\r\n */\r\nexport function getKnownSymbol(name, noPoly) {\r\n    var knownName = _wellKnownSymbolMap[name];\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n    return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);\r\n}\r\n/**\r\n * Returns a new unique Symbol value. If noPoly is true and symbols are not supported\r\n * then this will return null.\r\n * @group Symbol\r\n * @param description Description of the new Symbol object.\r\n * @param noPoly - Flag indicating whether to return a polyfil if symbols are not supported.\r\n * @returns The new symbol\r\n */\r\nexport function newSymbol(description, noPoly) {\r\n    // Cause lazy _symbol to get initialized\r\n    (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n    return _symbol.v ? _symbol.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);\r\n}\r\n/**\r\n * Returns a Symbol object from the global symbol registry matching the given key if found.\r\n * Otherwise, returns a new symbol with this key. This will always return a polyfill if symbols\r\n * are not supported.\r\n * @group Symbol\r\n * @param key key to search for.\r\n */\r\nexport function symbolFor(key) {\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbolFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n    return (_symbolFor.v || polySymbolFor)(key);\r\n}\r\n/**\r\n * Returns a key from the global symbol registry matching the given Symbol if found.\r\n * Otherwise, returns a undefined. This will always attempt to lookup the polyfill\r\n * implementation if symbols are not supported\r\n * @group Symbol\r\n * @param sym Symbol to find the key for.\r\n */\r\nexport function symbolKeyFor(sym) {\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbolKeyFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);\r\n}\r\n//# sourceMappingURL=symbol.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2023 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { _unwrapInstFunction } from \"../internal/unwrapFunction\";\r\n/**\r\n * The `fnApply` function calls the specified `fn` function with the given `thisArg` as the `this` value,\r\n * and the optional `argArray` arguments provided as an array (or an Array-Like Object).\r\n *\r\n * Normally, when calling a function, the value of `this` inside the function is the object that the\r\n * function was accessed on. With `fnApply()`, you can assign an arbitrary value as this when calling an\r\n * existing function, without first attaching the function to the object as a property. This allows you\r\n * to use methods of one object as generic utility functions.\r\n *\r\n * You can also use any kind of object which is ArrayLike as the second parameter. In practice, this means\r\n * that it needs to have a length property, and integer (\"index\") properties in the range (0..length - 1).\r\n * For example, you could use a NodeList, or a custom object like `{ 'length': 2, '0': 'eat', '1': 'bananas' }`.\r\n * You can also use `arguments`.\r\n *\r\n * @since 0.9.8\r\n * @group Function\r\n *\r\n * @param fn - The function to be called\r\n * @param thisArg - The value of `this` provided for the call to `fn`. If the function is not in strict mode,\r\n * `null` and `undefined` will be replaced with the global object, and primitive values will be converted to objects.\r\n * @param argArray - An array-like object, specifying the arguments with which `fn` should be called, or `null` or\r\n * `undefined` if no arguments should be provided to the function.\r\n * @returns The result of calling the function with the specified `this` value and arguments.\r\n * @example\r\n * ```ts\r\n * // min / max number in an array\r\n * let max = fnApply(Math.max, null, [ 21, 42, 84, 168, 7, 3 ]);\r\n * // 168\r\n *\r\n * let min = fnApply(Math.min, null, [ 21, 42, 84, 168, 7, 3 ]);\r\n * // 3\r\n *\r\n * const module1 = {\r\n *     prefix: \"Hello\",\r\n *     x: 21,\r\n *     getX() {\r\n *         return this.x;\r\n *     },\r\n *     log(value: string) {\r\n *         return this.prefix + \" \" + value + \" : \" + this.x\r\n *     }\r\n * };\r\n *\r\n * // The 'this' parameter of 'getX' is bound to 'module'.\r\n * module1.getX(); // 21\r\n * module1.log(\"Darkness\"); // Hello Darkness : 21\r\n *\r\n * // Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.\r\n * let module2 = {\r\n *     prefix: \"my\",\r\n *     x: 42\r\n * };\r\n *\r\n * // Call the function of module1 with module2 as it's this\r\n * fnApply(module1.getX, module2); // 42\r\n * fnApply(module1.log, module2, [ \"friend\" ]); // my friend : 42\r\n * ```\r\n */\r\nexport var fnApply = _unwrapInstFunction(\"apply\");\r\n//# sourceMappingURL=fnApply.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { LENGTH } from \"../internal/constants\";\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array in ascending index order. It is not invoked for index properties\r\n * that have been deleted or are uninitialized. And unlike the ES6 forEach() you CAN stop or break the iteration by returning -1 from the\r\n * `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackfn A `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one time for each element in the array.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEach expects a `synchronous` function.\r\n * arrForEach does not wait for promises. Make sure you are aware of the implications while using promises (or async functions) as forEach callback.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3'];\r\n * const copyItems = [];\r\n *\r\n * // before using for loop\r\n * for (let i = 0; i < items.length; i++) {\r\n *   copyItems.push(items[i]);\r\n * }\r\n *\r\n * // before using forEach()\r\n * items.forEach((item) => {\r\n *   copyItems.push(item);\r\n * });\r\n *\r\n * // after\r\n * arrForEach(items, (item) => {\r\n *   copyItems.push(item);\r\n *   // May return -1 to abort the iteration\r\n * });\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n * ```\r\n */\r\nexport function arrForEach(theArray, callbackfn, thisArg) {\r\n    if (theArray) {\r\n        var len = theArray[LENGTH] >>> 0;\r\n        for (var idx = 0; idx < len; idx++) {\r\n            if (idx in theArray) {\r\n                if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=forEach.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { ArrProto, SLICE } from \"../internal/constants\";\r\nimport { _unwrapFunction } from \"../internal/unwrapFunction\";\r\n/**\r\n * The arrSlice() method returns a shallow copy of a portion of an array into a new array object\r\n * selected from start to end (end not included) where start and end represent the index of items\r\n * in that array. The original array will not be modified.\r\n *\r\n * The `arrSlice()` method is a copying method. It does not alter this but instead returns a shallow\r\n * copy that contains some of the same elements as the ones from the original array.\r\n *\r\n * The `arrSlice()` method preserves empty slots. If the sliced portion is sparse, the returned arra\r\n * is sparse as well.\r\n *\r\n * The `arrSlice()` method is generic. It only expects the this value to have a length property and\r\n * integer-keyed properties.\r\n *\r\n * For both start and end, a negative index can be used to indicate an offset from the end of the array.\r\n * For example, -2 refers to the second to last element of the array.\r\n * @since 0.9.3\r\n * @group Array\r\n * @group ArrayLike\r\n * @param start Zero-based index at which to start extraction, converted to an integer.\r\n * - Negative index counts back from the end of the array — if start < 0, start + array.length is used.\r\n * - If start < -array.length or start is omitted, 0 is used.\r\n * - If start >= array.length, nothing is extracted.\r\n * @param end Zero-based index at which to end extraction, converted to an integer. slice() extracts\r\n * up to but not including end.\r\n * - Negative index counts back from the end of the array — if end < 0, end + array.length is used.\r\n * - If end < -array.length, 0 is used.\r\n * - If end >= array.length or end is omitted, array.length is used, causing all elements until the\r\n * end to be extracted.\r\n * - If end is positioned before or at start after normalization, nothing is extracted.\r\n * @example\r\n * ```ts\r\n * const lyrics = [\"Hello\", \"Darkness\", \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\", \"talk\" ];\r\n *\r\n * arrSlice(lyrics);        // [ \"Hello\", \"Darkness\", \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\", \"talk\" ]\r\n * arrSlice(lyrics, 1, 3);  // [ \"Darkness\", \"my\" ]\r\n * arrSlicw(lyrics, 2);     // [ \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\", \"talk\" ]\r\n * arrSlice(lyrics, 2, 4);  // [ \"my\", \"old\" ]\r\n * arrSlice(lyrics, 1, 5);  // [ \"Darkness\", \"my\", \"old\", \"friend.\" ]\r\n * arrSlice(lyrics, -2);    // [ \"to\", \"talk\" ]\r\n * arrSlice(lyrics, 2, -1); // [ \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\" ]\r\n * ```\r\n */\r\nexport var arrSlice = _unwrapFunction(SLICE, ArrProto);\r\n//# sourceMappingURL=slice.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { NULL_VALUE } from \"../internal/constants\";\r\nimport { objDefineProp } from \"../object/define\";\r\nvar REF = \"ref\";\r\nvar UNREF = \"un\" + REF;\r\nvar HAS_REF = \"hasRef\";\r\nvar ENABLED = \"enabled\";\r\n/**\r\n * @ignore\r\n * @internal\r\n * Internal function to create and manage an ITimerHandler implementation, the object returned from this function\r\n * it directly used / returned by the pulic functions used to create timers (idle, interval and timeout)\r\n * @param startTimer - Should the timer be started as part of creating the handler\r\n * @param refreshFn - The function used to create/start or refresh the timer\r\n * @param cancelFn - The function used to cancel the timer.\r\n * @returns The new ITimerHandler instance\r\n */\r\nexport function _createTimerHandler(startTimer, refreshFn, cancelFn) {\r\n    var _a;\r\n    var ref = true;\r\n    var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;\r\n    var theTimerHandler;\r\n    var _unref = function () {\r\n        ref = false;\r\n        timerId && timerId[UNREF] && timerId[UNREF]();\r\n        return theTimerHandler;\r\n    };\r\n    var _ref = function () {\r\n        ref = true;\r\n        timerId && timerId[REF] && timerId[REF]();\r\n        return theTimerHandler;\r\n    };\r\n    var _hasRef = function () {\r\n        if (timerId && timerId[HAS_REF]) {\r\n            return timerId[HAS_REF]();\r\n        }\r\n        return ref;\r\n    };\r\n    var _refresh = function () {\r\n        timerId = refreshFn(timerId);\r\n        if (!ref) {\r\n            _unref();\r\n        }\r\n        return theTimerHandler;\r\n    };\r\n    var _cancel = function () {\r\n        timerId && cancelFn(timerId);\r\n        timerId = NULL_VALUE;\r\n    };\r\n    var _setEnabled = function (value) {\r\n        !value && timerId && _cancel();\r\n        value && !timerId && _refresh();\r\n    };\r\n    theTimerHandler = (_a = {\r\n            cancel: _cancel,\r\n            refresh: _refresh\r\n        },\r\n        _a[HAS_REF] = _hasRef,\r\n        _a[REF] = _ref,\r\n        _a[UNREF] = _unref,\r\n        _a[ENABLED] = false,\r\n        _a);\r\n    objDefineProp(theTimerHandler, ENABLED, {\r\n        get: function () { return !!timerId; },\r\n        set: _setEnabled\r\n    });\r\n    return {\r\n        h: theTimerHandler,\r\n        dn: function () {\r\n            timerId = NULL_VALUE;\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=handler.js.map","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrSlice } from \"../array/slice\";\r\nimport { fnApply } from \"../funcs/fnApply\";\r\nimport { isArray } from \"../helpers/base\";\r\nimport { UNDEF_VALUE } from \"../internal/constants\";\r\nimport { _createTimerHandler } from \"./handler\";\r\nfunction _createTimeoutWith(self, startTimer, overrideFn, theArgs) {\r\n    var isArr = isArray(overrideFn);\r\n    var len = isArr ? overrideFn.length : 0;\r\n    var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;\r\n    var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;\r\n    var timerFn = theArgs[0];\r\n    theArgs[0] = function () {\r\n        handler.dn();\r\n        fnApply(timerFn, self, arrSlice(arguments));\r\n    };\r\n    var handler = _createTimerHandler(startTimer, function (timerId) {\r\n        if (timerId) {\r\n            if (timerId.refresh) {\r\n                timerId.refresh();\r\n                return timerId;\r\n            }\r\n            fnApply(clearFn, self, [timerId]);\r\n        }\r\n        return fnApply(setFn, self, theArgs);\r\n    }, function (timerId) {\r\n        fnApply(clearFn, self, [timerId]);\r\n    });\r\n    return handler.h;\r\n}\r\nexport function scheduleTimeout(callback, timeout) {\r\n    return _createTimeoutWith(this, true, UNDEF_VALUE, arrSlice(arguments));\r\n}\r\nexport function scheduleTimeoutWith(overrideFn, callback, timeout) {\r\n    return _createTimeoutWith(this, true, overrideFn, arrSlice(arguments, 1));\r\n}\r\nexport function createTimeout(callback, timeout) {\r\n    return _createTimeoutWith(this, false, UNDEF_VALUE, arrSlice(arguments));\r\n}\r\nexport function createTimeoutWith(overrideFn, callback, timeout) {\r\n    return _createTimeoutWith(this, false, overrideFn, arrSlice(arguments, 1));\r\n}\r\n//# sourceMappingURL=timeout.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport var STRING_STATES = [\r\n    \"pending\", \"resolving\", \"resolved\", \"rejected\"\r\n];\r\n//# sourceMappingURL=state.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { dumpObj, getDocument, safeGetLazy, getInst } from \"@nevware21/ts-utils\";\r\nvar DISPATCH_EVENT = \"dispatchEvent\";\r\nvar _hasInitEvent;\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param target\r\n * @param evtName\r\n * @param populateEvent\r\n * @param useNewEvent\r\n */\r\nexport function emitEvent(target, evtName, populateEvent, useNewEvent) {\r\n    var doc = getDocument();\r\n    !_hasInitEvent && (_hasInitEvent = safeGetLazy(function () {\r\n        var evt;\r\n        if (doc && doc.createEvent) {\r\n            evt = doc.createEvent(\"Event\");\r\n        }\r\n        return (!!evt && evt.initEvent);\r\n    }, null));\r\n    var theEvt = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {});\r\n    populateEvent && populateEvent(theEvt);\r\n    if (_hasInitEvent.v) {\r\n        theEvt.initEvent(evtName, false, true);\r\n    }\r\n    if (theEvt && target[DISPATCH_EVENT]) {\r\n        target[DISPATCH_EVENT](theEvt);\r\n    }\r\n    else {\r\n        var handler = target[\"on\" + evtName];\r\n        if (handler) {\r\n            handler(theEvt);\r\n        }\r\n        else {\r\n            var theConsole = getInst(\"console\");\r\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=event.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined, throwTypeError, objToString, scheduleTimeout, getWindow, isNode, getGlobal, objDefine, objDefineProp, lazySafeGetInst } from \"@nevware21/ts-utils\";\r\nimport { doAwait } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\nvar NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nvar UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\nvar _currentPromiseId = [];\r\nvar _uniquePromiseId = 0;\r\nvar _unhandledRejectionTimeout = 10;\r\nvar _hasPromiseRejectionEvent;\r\nfunction dumpFnObj(value) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n    return dumpObj(value);\r\n}\r\nexport function _createPromise(newPromise, processor, executor) {\r\n    var additionalArgs = arrSlice(arguments, 3);\r\n    var _state = 0 /* ePromiseState.Pending */;\r\n    var _hasResolved = false;\r\n    var _settledValue;\r\n    var _queue = [];\r\n    var _id = _uniquePromiseId++;\r\n    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    var _handled = false;\r\n    var _unHandledRejectionHandler = null;\r\n    var _thePromise;\r\n    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + \"RejectionEvent\"));\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    var _then = function (onResolved, onRejected) {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"then(\" + dumpFnObj(onResolved)+ \", \" + dumpFnObj(onResolved) +  \")\");\r\n            //#endif\r\n            var thenPromise = newPromise(function (resolve, reject) {\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        var handler = _state === 2 /* ePromiseState.Resolved */ ? onResolved : onRejected;\r\n                        var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve, reject);\r\n                        }\r\n                        else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value);\r\n                        }\r\n                        else if (_state === 3 /* ePromiseState.Rejected */) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        }\r\n                        else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n            return thenPromise;\r\n        }\r\n        finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    };\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    var _catch = function (onRejected) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    };\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    var _finally = function (onFinally) {\r\n        var thenFinally = onFinally;\r\n        var catchFinally = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function (value) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            };\r\n            catchFinally = function (reason) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            };\r\n        }\r\n        return _then(thenFinally, catchFinally);\r\n    };\r\n    var _strState = function () {\r\n        return STRING_STATES[_state];\r\n    };\r\n    var _processQueue = function () {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            var pending = _queue.slice();\r\n            _queue = [];\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n            _handled = true;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n        }\r\n        else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    };\r\n    var _createSettleIfFn = function (newState, allowState) {\r\n        return function (theValue) {\r\n            if (_state === allowState) {\r\n                if (newState === 2 /* ePromiseState.Resolved */ && isPromiseLike(theValue)) {\r\n                    _state = 1 /* ePromiseState.Resolving */;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(_createSettleIfFn(2 /* ePromiseState.Resolved */, 1 /* ePromiseState.Resolving */), _createSettleIfFn(3 /* ePromiseState.Rejected */, 1 /* ePromiseState.Resolving */));\r\n                    return;\r\n                }\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === 3 /* ePromiseState.Rejected */ && !_unHandledRejectionHandler) {\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);\r\n                }\r\n            }\r\n            else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    };\r\n    var _notifyUnhandledRejection = function () {\r\n        if (!_handled) {\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            }\r\n            else {\r\n                var gbl = getWindow() || getGlobal();\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {\r\n                    objDefine(theEvt, \"promise\", { g: function () { return _thePromise; } });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    };\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    };\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, function () { return objToString(_settledValue); }, function () { return _handled; });\r\n    }\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol(11 /* WellKnownSymbols.toStringTag */)] = \"IPromise\";\r\n    }\r\n    var _toString = function () {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\");\r\n    };\r\n    _thePromise.toString = _toString;\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n        var _rejectFn = _createSettleIfFn(3 /* ePromiseState.Rejected */, 0 /* ePromiseState.Pending */);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(_thePromise, _createSettleIfFn(2 /* ePromiseState.Resolved */, 0 /* ePromiseState.Pending */), _rejectFn);\r\n        }\r\n        catch (e) {\r\n            _rejectFn(e);\r\n        }\r\n    })();\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\nexport function _createAllPromise(newPromise) {\r\n    return function (input) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            try {\r\n                var values_1 = [];\r\n                var pending_1 = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n                arrForEach(input, function (item, idx) {\r\n                    if (item) {\r\n                        pending_1++;\r\n                        doAwait(item, function (value) {\r\n                            // Set the result values\r\n                            values_1[idx] = value;\r\n                            if (--pending_1 === 0) {\r\n                                resolve(values_1);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n                // Now decrement the pending so that we finish correctly\r\n                pending_1--;\r\n                if (pending_1 === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values_1);\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\nexport function _createResolvedPromise(newPromise) {\r\n    return function (value) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike(value)) {\r\n            return value;\r\n        }\r\n        return newPromise(function (resolve) {\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\nexport function _createRejectedPromise(newPromise) {\r\n    return function (reason) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (_resolve, reject) {\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n//# sourceMappingURL=base.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nexport var STR_PROMISE = \"Promise\";\r\n//# sourceMappingURL=constants.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { _createAllPromise, _createPromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { timeoutItemProcessor } from \"./itemProcessor\";\r\n/**\r\n * Creates an asynchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the optional provided timeout value to schedule when the chained items will be ececuted.\r\n * @group Async\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createAsyncPromise(executor, timeout) {\r\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n * @group Async\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createAsyncAllPromise = _createAllPromise(createAsyncPromise);\r\n// /**\r\n//  * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n//  * or rejected.\r\n//  * @param values An array of Promises.\r\n//  * @returns A new Promise.\r\n//  */\r\n//     race<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>>;\r\n//export const createAsyncRacePromise: <T extends readonly unknown[] | []>(values: T): IPromise<T[number]>;\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Async\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncResolvedPromise = _createResolvedPromise(createAsyncPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Async\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncRejectedPromise = _createRejectedPromise(createAsyncPromise);\r\n//# sourceMappingURL=asyncPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nvar _processPendingItems = function (pending) {\r\n    arrForEach(pending, function (fn) {\r\n        try {\r\n            fn();\r\n        }\r\n        catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor() {\r\n    return _processPendingItems;\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout) {\r\n    var callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n    return function (pending) {\r\n        scheduleTimeout(function () {\r\n            _processPendingItems(pending);\r\n        }, callbackTimeout);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout) {\r\n    var options;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n    return function (pending) {\r\n        scheduleIdleCallback(function (deadline) {\r\n            _processPendingItems(pending);\r\n        }, options);\r\n    };\r\n}\r\n//# sourceMappingURL=itemProcessor.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { isPromiseLike } from \"@nevware21/ts-utils\";\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait to be resolved or rejected.\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse(value, cb) {\r\n    return doAwait(value, function (value) {\r\n        return cb ? cb({\r\n            value: value,\r\n            rejected: false\r\n        }) : value;\r\n    }, function (reason) {\r\n        return cb ? cb({\r\n            rejected: true,\r\n            reason: reason\r\n        }) : reason;\r\n    });\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait(value, resolveFn, rejectFn, finallyFn) {\r\n    var result = value;\r\n    if (isPromiseLike(value)) {\r\n        if (resolveFn || rejectFn) {\r\n            result = value.then(resolveFn, rejectFn);\r\n        }\r\n    }\r\n    else {\r\n        if (resolveFn) {\r\n            result = resolveFn(value);\r\n        }\r\n    }\r\n    if (finallyFn) {\r\n        doFinally(result, finallyFn);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally(value, finallyFn) {\r\n    var result = value;\r\n    if (finallyFn) {\r\n        if (isPromiseLike(value)) {\r\n            if (value.finally) {\r\n                result = value.finally(finallyFn);\r\n            }\r\n            else {\r\n                // Simulate finally if not available\r\n                result = value.then(function (value) {\r\n                    finallyFn();\r\n                    return value;\r\n                }, function (reason) {\r\n                    finallyFn();\r\n                    throw reason;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            finallyFn();\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=await.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { createAsyncAllPromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"./promise/asyncPromise\";\r\nimport { objForEachKey } from \"@nevware21/ts-utils\";\r\nimport { PolyPromise } from \"./polyfills/promise\";\r\n(function () {\r\n    var promisePolyfills = {\r\n        \"all\": createAsyncAllPromise,\r\n        \"resolved\": createAsyncResolvedPromise,\r\n        \"rejected\": createAsyncRejectedPromise\r\n    };\r\n    if (!Promise) {\r\n        Promise = PolyPromise;\r\n    }\r\n    else {\r\n        // Add Object polyfills\r\n        var PromiseClass_1 = Promise;\r\n        if (PromiseClass_1) {\r\n            objForEachKey(promisePolyfills, function (key, value) {\r\n                if (!PromiseClass_1[key]) {\r\n                    PromiseClass_1[key] = value;\r\n                }\r\n            });\r\n        }\r\n    }\r\n})();\r\n//# sourceMappingURL=polyfills.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\nimport { getKnownSymbol, objDefineProp } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncPromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nvar toStringTagSymbol = getKnownSymbol(11 /* WellKnownSymbols.toStringTag */);\r\nexport var PolyPromise = (function () {\r\n    function PolyPromiseImpl(executor) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function () {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    //PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    var theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved, onRejected) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl;\r\n}());\r\n//# sourceMappingURL=promise.js.map"],"names":["UNDEF_VALUE","undefined","NULL_VALUE","EMPTY","OBJECT","PROTOTYPE","UNDEFINED","SYMBOL","POLYFILL_TAG","LENGTH","SLICE","ObjClass","Object","ObjProto","StrCls","String","ArrCls","Array","ArrProto","_createIs","theType","value","objToString","toString","call","isUndefined","isFunction","isObject","isError","isArray","isNumber","isPromiseLike","then","objGetOwnPropertyDescriptor","getOwnPropertyDescriptor","objHasOwn","obj","prop","hasOwnProperty","objForEachKey","theObject","callbackfn","thisArg","throwTypeError","message","TypeError","_objFreeze","objFreeze","theMap","asyncIterator","hasInstance","isConcatSpreadable","iterator","match","matchAll","replace","search","species","split","toPrimitive","toStringTag","unscopables","key","_globalCfg","_wellKnownSymbolMap","asString","GLOBAL_CONFIG_KEY","_getGlobalValue","result","globalThis","self","window","global","dumpObj","object","format","propertyValueDump","stack","name","JSON","stringify","e","_globalLazyTestHooks","_arrSlice","_wellKnownSymbolCache","propMap","c","v","w","g","s","objDefineProp","_fetchLazyTestHooks","gbl","safeGetLazy","cb","defValue","safeGet","lazyValue","b","lzy","configurable","get","getInst","useCached","_cachedGlobal","getGlobal","WINDOW","_cachedWindow","_cachedDocument","_isNode","_symbol","_symbolFor","_symbolKeyFor","lazySafeGetInst","getWindow","isNode","process","versions","node","_getSymbolValue","getSymbol","resetCache","getKnownSymbol","noPoly","description","knownName","theSymbol","fnApply","funcName","apply","arguments","arrForEach","theArray","len","idx","clsFn","arrSlice","theFunc","UNREF","HAS_REF","ENABLED","scheduleTimeout","this","overrideFn","theArgs","isArr","length","setFn","setTimeout","clearFn","clearTimeout","timerFn","handler","dn","cancelFn","timerId","ref","refreshFn","refresh","_a","cancel","_cancel","_refresh","hasRef","theTimerHandler","_unref","set","h","_hasInitEvent","_hasPromiseRejectionEvent","STRING_STATES","DISPATCH_EVENT","STR_PROMISE","NODE_UNHANDLED_REJECTION","UNHANDLED_REJECTION","toLowerCase","_currentPromiseId","_uniquePromiseId","_unhandledRejectionTimeout","dumpFnObj","createAsyncPromise","executor","timeout","newPromise","processor","_then","onResolved","onRejected","push","_id","_handled","_unHandledRejectionHandler","resolve","reject","_queue","_state","_settledValue","_hasResolved","_processQueue","additionalArgs","pop","_strState","pending","slice","_createSettleIfFn","newState","allowState","theValue","_notifyUnhandledRejection","evtName","theConsole","doc","theEvt","emit","_thePromise","target","populateEvent","enumerable","l","desc","newValue","reason","useNewEvent","evt","createEvent","initEvent","Event","catch","finally","onFinally","thenFinally","catchFinally","_rejectFn","callbackTimeout","fn","createAsyncAllPromise","input","values_1","pending_1","item","resolveFn","rejectFn","createAsyncResolvedPromise","createAsyncRejectedPromise","_resolve","PromiseClass_1","toStringTagSymbol","PolyPromise","PolyPromiseImpl","all","theProto","prototype","_$","onfinally","state","Promise","resolved","rejected"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}