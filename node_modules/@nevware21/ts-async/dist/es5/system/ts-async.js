/*!
 * NevWare21 - ts-async, 0.4.0
 * https://github.com/nevware21/ts-async
 * Copyright (c) NevWare21 and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
System.register('nevware21.ts-async', [], (function (exports) {
    'use strict';
    return {
        execute: (function () {

            exports({
                createAsyncPromise: createAsyncPromise,
                createIdlePromise: createIdlePromise,
                createNativePromise: createNativePromise,
                createPromise: createPromise,
                createSyncPromise: createSyncPromise,
                createTaskScheduler: createTaskScheduler,
                doAwait: doAwait,
                doAwaitResponse: doAwaitResponse,
                doFinally: doFinally,
                setCreatePromiseImpl: setCreatePromiseImpl,
                setDetaultIdleTimeout: setDetaultIdleTimeout,
                setPromiseDebugState: setPromiseDebugState
            });

            var UNDEF_VALUE = undefined;
            var NULL_VALUE = null;
            var EMPTY = "";
            var FUNCTION = "function";
            var NUMBER = "number";
            var OBJECT = "object";
            var PROTOTYPE = "prototype";
            var __PROTO__ = "__proto__";
            var UNDEFINED = "undefined";
            var CONSTRUCTOR = "constructor";
            var SYMBOL = "Symbol";
            var POLYFILL_TAG = "_polyfill";
            var INDEX_OF = "indexOf";
            var LAST_INDEX_OF = "lastIndexOf";
            var LENGTH = "length";
            var VALUE = "value";
            var NAME = "name";
            var SLICE = "slice";
            var ObjClass = Object;
            var ObjProto = ObjClass[PROTOTYPE];
            var StrCls = String;
            var ArrCls = Array;
            var ArrProto = ArrCls[PROTOTYPE];

            function safeGet(cb, defValue) {
                var result = defValue;
                try {
                    result = cb();
                }
                catch (e) {
                }
                return result;
            }

            function _createIs(theType) {
                return function (value) {
                    return typeof value === theType;
                };
            }
            function _createObjIs(theName) {
                var theType = "[object " + theName + "]";
                return function (value) {
                    return !!(value && objToString(value) === theType);
                };
            }
            function objToString(value) {
                return ObjProto.toString.call(value);
            }
            function isUndefined(value) {
                return typeof value === UNDEFINED || value === UNDEFINED;
            }
            function isNullOrUndefined(value) {
                return value === NULL_VALUE || isUndefined(value);
            }
            function isDefined(arg) {
                return !!arg || arg !== UNDEF_VALUE;
            }
            var isFunction = _createIs(FUNCTION);
            function isObject(value) {
                if (!value && isNullOrUndefined(value)) {
                    return false;
                }
                return !!value && typeof value === OBJECT;
            }
            var isArray = ArrCls.isArray;
            var isNumber = _createIs(NUMBER);
            var isError = _createObjIs("Error");
            function isPromiseLike(value) {
                return !!value && isFunction(value.then);
            }

            var objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;

            function objHasOwnProperty(obj, prop) {
                return obj && ObjProto.hasOwnProperty.call(obj, prop);
            }

            var objHasOwn = ObjClass["hasOwn"] || polyObjHasOwn;
            function polyObjHasOwn(obj, prop) {
                return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
            }

            function objForEachKey(theObject, callbackfn, thisArg) {
                if (theObject && isObject(theObject)) {
                    for (var prop in theObject) {
                        if (objHasOwn(theObject, prop)) {
                            if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {
                                break;
                            }
                        }
                    }
                }
            }

            function _createKeyValueMap(values, keyType, valueType, completeFn) {
                var theMap = {};
                objForEachKey(values, function (key, value) {
                    theMap[key] = keyType ? value : key;
                    theMap[value] = valueType ? value : key;
                });
                return completeFn(theMap);
            }

            function throwTypeError(message) {
                throw new TypeError(message);
            }

            var _objFreeze = ObjClass["freeze"];
            var _doNothing = function (value) { return value; };
            var _getProto = function (value) { return value[__PROTO__] || NULL_VALUE; };
            function objDeepFreeze(value) {
                if (_objFreeze) {
                    objForEachKey(value, function (key, value) {
                        if (isArray(value) || isObject(value)) {
                            _objFreeze(value);
                        }
                    });
                }
                return objFreeze(value);
            }
            var objFreeze = _objFreeze || _doNothing;
            var objGetPrototypeOf = ObjClass["getPrototypeOf"] || _getProto;

            function createEnumKeyMap(values) {
                return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
            }

            var _wellKnownSymbolMap = createEnumKeyMap({
                asyncIterator: 0 ,
                hasInstance: 1 ,
                isConcatSpreadable: 2 ,
                iterator: 3 ,
                match: 4 ,
                matchAll: 5 ,
                replace: 6 ,
                search: 7 ,
                species: 8 ,
                split: 9 ,
                toPrimitive: 10 ,
                toStringTag: 11 ,
                unscopables: 12
            });

            var asString = StrCls;

            var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
            var _globalCfg;
            function _getGlobalValue() {
                var result;
                if (typeof globalThis !== UNDEFINED) {
                    result = globalThis;
                }
                if (!result && typeof self !== UNDEFINED) {
                    result = self;
                }
                if (!result && typeof window !== UNDEFINED) {
                    result = window;
                }
                if (!result && typeof global !== UNDEFINED) {
                    result = global;
                }
                return result;
            }
            function _getGlobalConfig() {
                if (!_globalCfg) {
                    var gbl = _getGlobalValue() || {};
                    _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
                }
                return _globalCfg;
            }

            function dumpObj(object, format) {
                var propertyValueDump = EMPTY;
                if (isError(object)) {
                    propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
                }
                else {
                    try {
                        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
                    }
                    catch (e) {
                        propertyValueDump = " - " + dumpObj(e, format);
                    }
                }
                return objToString(object) + ": " + propertyValueDump;
            }

            var _arrSlice = ArrProto[SLICE];
            var _throwMissingFunction = function (funcName, thisArg) {
                throwTypeError("'" + asString(funcName) + "' not defined for " + dumpObj(thisArg));
            };
            var _unwrapInstFunction = function (funcName) {
                return function (thisArg) {
                    return thisArg[funcName].apply(thisArg, _arrSlice.call(arguments, 1));
                };
            };
            var _unwrapFunction = function (funcName, clsProto) {
                var clsFn = clsProto && clsProto[funcName];
                return function (thisArg) {
                    var theFunc = (thisArg && thisArg[funcName]) || clsFn;
                    if (theFunc) {
                        return theFunc.apply(thisArg, _arrSlice.call(arguments, 1));
                    }
                    _throwMissingFunction(funcName, thisArg);
                };
            };
            function _unwrapProp(propName) {
                return function (thisArg) {
                    return thisArg[propName];
                };
            }

            var _wellKnownSymbolCache = {};
            function polyNewSymbol(description) {
                var theSymbol = {
                    description: asString(description),
                    toString: function () { return SYMBOL + "(" + description + ")"; }
                };
                theSymbol[POLYFILL_TAG] = true;
                return theSymbol;
            }
            function polyGetKnownSymbol(name) {
                var result;
                var knownName = _wellKnownSymbolMap[name];
                if (knownName) {
                    result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
                }
                return result;
            }

            var propMap = {
                e: "enumerable",
                c: "configurable",
                v: VALUE,
                w: "writable",
                g: "get",
                s: "set"
            };
            function _createProp(value) {
                var prop = {};
                prop[propMap["c"]] = true;
                prop[propMap["e"]] = true;
                if (value.l) {
                    prop.get = function () { return value.l.v; };
                    var desc = objGetOwnPropertyDescriptor(value.l, "v");
                    if (desc && desc.set) {
                        prop.set = function (newValue) {
                            value.l.v = newValue;
                        };
                    }
                }
                objForEachKey(value, function (key, value) {
                    prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
                });
                return prop;
            }
            var objDefineProp = ObjClass["defineProperty"];
            function objDefine(target, key, propDesc) {
                return objDefineProp(target, key, _createProp(propDesc));
            }

            var _globalLazyTestHooks;
            var _fetchLazyTestHooks = function () {
                _globalLazyTestHooks = _getGlobalConfig();
                _fetchLazyTestHooks = NULL_VALUE;
            };
            function getLazy(cb) {
                var lazyValue = {};
                _fetchLazyTestHooks && _fetchLazyTestHooks();
                lazyValue.b = _globalLazyTestHooks.lzy;
                objDefineProp(lazyValue, "v", {
                    configurable: true,
                    get: function () {
                        var result = cb();
                        if (!_globalLazyTestHooks.lzy) {
                            objDefineProp(lazyValue, "v", {
                                value: result
                            });
                            if (lazyValue.b) {
                                delete lazyValue.b;
                            }
                        }
                        if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                            lazyValue.b = _globalLazyTestHooks.lzy;
                        }
                        return result;
                    }
                });
                return lazyValue;
            }

            function safeGetLazy(cb, defValue) {
                return getLazy(function () { return safeGet(cb, defValue); });
            }

            var WINDOW = "window";
            var _cachedGlobal;
            var _cachedWindow;
            var _cachedDocument;
            var _isNode;
            var lazySafeGetInst = function (name) { return safeGetLazy(function () { return getInst(name) || UNDEF_VALUE; }, UNDEF_VALUE); };
            var getGlobal = function (useCached) {
                (!_cachedGlobal || useCached === false || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));
                return _cachedGlobal.v;
            };
            var getInst = function (name, useCached) {
                var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
                if (gbl && gbl[name]) {
                    return gbl[name];
                }
                if (name === WINDOW && _cachedWindow) {
                    return _cachedWindow.v;
                }
                return NULL_VALUE;
            };
            var getDocument = function () {
                (!_cachedDocument || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedDocument.b)) && (_cachedDocument = lazySafeGetInst("document"));
                return _cachedDocument.v;
            };
            var getWindow = function () {
                (!_cachedWindow || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedWindow.b)) && (_cachedWindow = lazySafeGetInst(WINDOW));
                return _cachedWindow.v;
            };
            var isNode = function () {
                !_isNode && (_isNode = safeGetLazy(function () { return !!(process && (process.versions || {}).node); }, false));
                return _isNode.v;
            };

            var _symbol;
            var _symbolFor;
            var _symbolKeyFor;
            function _getSymbolValue(name) {
                return safeGetLazy(function () {
                    return (_symbol.v ? _symbol.v[name] : UNDEF_VALUE);
                }, UNDEF_VALUE);
            }
            function hasSymbol() {
                return !!getSymbol();
            }
            function getSymbol() {
                var resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);
                resetCache && (_symbol = lazySafeGetInst(SYMBOL));
                (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue("for"));
                (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue("keyFor"));
                return _symbol.v;
            }
            function getKnownSymbol(name, noPoly) {
                var knownName = _wellKnownSymbolMap[name];
                (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
                return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
            }

            var fnApply = _unwrapInstFunction("apply");

            function arrForEach(theArray, callbackfn, thisArg) {
                if (theArray) {
                    var len = theArray[LENGTH] >>> 0;
                    for (var idx = 0; idx < len; idx++) {
                        if (idx in theArray) {
                            if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                                break;
                            }
                        }
                    }
                }
            }

            var arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto);
            _unwrapFunction(LAST_INDEX_OF, ArrProto);

            var arrSlice = _unwrapFunction(SLICE, ArrProto);

            var _objCreate = ObjClass["create"];
            var objCreate = _objCreate || polyObjCreate;
            function polyObjCreate(obj) {
                if (!obj) {
                    return {};
                }
                var type = typeof obj;
                if (type !== OBJECT && type !== FUNCTION) {
                    throw new TypeError("Prototype must be an Object or function: " + dumpObj(obj));
                }
                function tempFunc() { }
                tempFunc[PROTOTYPE] = obj;
                return new tempFunc();
            }

            var _isProtoArray;
            function objSetPrototypeOf(obj, proto) {
                var fn = ObjClass["setPrototypeOf"] ||
                    function (d, b) {
                        !_isProtoArray && (_isProtoArray = getLazy(function () {
                            var _a;
                            return ((_a = {}, _a[__PROTO__] = [], _a) instanceof Array);
                        }));
                        _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
                    };
                return fn(obj, proto);
            }

            var _createCustomError = function (name, d, b) {
                _safeDefineName(d, name);
                d = objSetPrototypeOf(d, b);
                function __() {
                    this.constructor = d;
                    _safeDefineName(this, name);
                }
                d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
                return d;
            };
            var _safeSetName = function (baseClass, name) {
                try {
                    name && (baseClass[NAME] = name);
                }
                catch (e) {
                }
            };
            var _safeDefineName = function (target, name) {
                try {
                    objDefine(target, NAME, { v: name, c: true, e: false });
                }
                catch (e) {
                }
            };
            function createCustomError(name, constructCb, errorBase) {
                var theBaseClass = errorBase || Error;
                var orgName = theBaseClass[PROTOTYPE][NAME];
                var captureFn = Error.captureStackTrace;
                return _createCustomError(name, function () {
                    var _this = this;
                    try {
                        _safeSetName(theBaseClass, name);
                        var _self = fnApply(theBaseClass, _this, arrSlice(arguments)) || _this;
                        if (_self !== _this) {
                            var orgProto = objGetPrototypeOf(_this);
                            if (orgProto !== objGetPrototypeOf(_self)) {
                                objSetPrototypeOf(_self, orgProto);
                            }
                        }
                        captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                        constructCb && constructCb(_self, arguments);
                        return _self;
                    }
                    finally {
                        _safeSetName(theBaseClass, orgName);
                    }
                }, theBaseClass);
            }

            function utcNow() {
                return (Date.now || polyUtcNow)();
            }
            function polyUtcNow() {
                return new Date().getTime();
            }

            var getLength = _unwrapProp(LENGTH);

            var _perf;
            function getPerformance() {
                (!_perf || (!_perf.b && _globalLazyTestHooks && _globalLazyTestHooks.lzy)) && (_perf = lazySafeGetInst("performance"));
                return _perf.v;
            }
            function perfNow() {
                var perf = getPerformance();
                if (perf && perf.now) {
                    return perf.now();
                }
                return utcNow();
            }
            function elapsedTime(startTime) {
                return perfNow() - startTime;
            }

            var REF = "ref";
            var UNREF = "un" + REF;
            var HAS_REF = "hasRef";
            var ENABLED = "enabled";
            function _createTimerHandler(startTimer, refreshFn, cancelFn) {
                var _a;
                var ref = true;
                var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
                var theTimerHandler;
                var _unref = function () {
                    ref = false;
                    timerId && timerId[UNREF] && timerId[UNREF]();
                    return theTimerHandler;
                };
                var _ref = function () {
                    ref = true;
                    timerId && timerId[REF] && timerId[REF]();
                    return theTimerHandler;
                };
                var _hasRef = function () {
                    if (timerId && timerId[HAS_REF]) {
                        return timerId[HAS_REF]();
                    }
                    return ref;
                };
                var _refresh = function () {
                    timerId = refreshFn(timerId);
                    if (!ref) {
                        _unref();
                    }
                    return theTimerHandler;
                };
                var _cancel = function () {
                    timerId && cancelFn(timerId);
                    timerId = NULL_VALUE;
                };
                var _setEnabled = function (value) {
                    !value && timerId && _cancel();
                    value && !timerId && _refresh();
                };
                theTimerHandler = (_a = {
                        cancel: _cancel,
                        refresh: _refresh
                    },
                    _a[HAS_REF] = _hasRef,
                    _a[REF] = _ref,
                    _a[UNREF] = _unref,
                    _a[ENABLED] = false,
                    _a);
                objDefineProp(theTimerHandler, ENABLED, {
                    get: function () { return !!timerId; },
                    set: _setEnabled
                });
                return {
                    h: theTimerHandler,
                    dn: function () {
                        timerId = NULL_VALUE;
                    }
                };
            }

            function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
                var isArr = isArray(overrideFn);
                var len = isArr ? overrideFn.length : 0;
                var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
                var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
                var timerFn = theArgs[0];
                theArgs[0] = function () {
                    handler.dn();
                    fnApply(timerFn, self, arrSlice(arguments));
                };
                var handler = _createTimerHandler(startTimer, function (timerId) {
                    if (timerId) {
                        if (timerId.refresh) {
                            timerId.refresh();
                            return timerId;
                        }
                        fnApply(clearFn, self, [timerId]);
                    }
                    return fnApply(setFn, self, theArgs);
                }, function (timerId) {
                    fnApply(clearFn, self, [timerId]);
                });
                return handler.h;
            }
            function scheduleTimeout(callback, timeout) {
                return _createTimeoutWith(this, true, UNDEF_VALUE, arrSlice(arguments));
            }

            var _hasIdleCallback;
            var _defaultIdleTimeout$1 = 100;
            var _maxExecutionTime = 50;
            function hasIdleCallback() {
                !_hasIdleCallback && (_hasIdleCallback = safeGetLazy(function () { return isDefined(requestIdleCallback); }, false));
                return !!(_hasIdleCallback.v ? requestIdleCallback : false);
            }
            function scheduleIdleCallback(callback, options) {
                function _createDeadline(timedOut) {
                    var startTime = perfNow();
                    return {
                        didTimeout: timedOut,
                        timeRemaining: function () {
                            return _maxExecutionTime - elapsedTime(startTime);
                        }
                    };
                }
                if (hasIdleCallback()) {
                    var handler_1 = _createTimerHandler(true, function (idleId) {
                        idleId && cancelIdleCallback(idleId);
                        return requestIdleCallback(function (deadline) {
                            handler_1.dn();
                            callback(deadline || _createDeadline(false));
                        }, options);
                    }, function (idleId) {
                        cancelIdleCallback(idleId);
                    });
                    return handler_1.h;
                }
                var timeout = (options || {}).timeout;
                if (isUndefined(timeout)) {
                    timeout = _defaultIdleTimeout$1;
                }
                return scheduleTimeout(function () {
                    callback(_createDeadline(true));
                }, timeout);
            }

            function doAwaitResponse(value, cb) {
                return doAwait(value, function (value) {
                    return cb ? cb({
                        value: value,
                        rejected: false
                    }) : value;
                }, function (reason) {
                    return cb ? cb({
                        rejected: true,
                        reason: reason
                    }) : reason;
                });
            }
            function doAwait(value, resolveFn, rejectFn, finallyFn) {
                var result = value;
                if (isPromiseLike(value)) {
                    if (resolveFn || rejectFn) {
                        result = value.then(resolveFn, rejectFn);
                    }
                }
                else {
                    if (resolveFn) {
                        result = resolveFn(value);
                    }
                }
                if (finallyFn) {
                    doFinally(result, finallyFn);
                }
                return result;
            }
            function doFinally(value, finallyFn) {
                var result = value;
                if (finallyFn) {
                    if (isPromiseLike(value)) {
                        if (value.finally) {
                            result = value.finally(finallyFn);
                        }
                        else {
                            result = value.then(function (value) {
                                finallyFn();
                                return value;
                            }, function (reason) {
                                finallyFn();
                                throw reason;
                            });
                        }
                    }
                    else {
                        finallyFn();
                    }
                }
                return result;
            }

            var _debugState;
            var _debugResult;
            var _debugHandled;
            var _promiseDebugEnabled = false;
            function _addDebugState$1(thePromise, stateFn, resultFn, handledFn) {
                _debugState = _debugState || { toString: function () { return "[[PromiseState]]"; } };
                _debugResult = _debugResult || { toString: function () { return "[[PromiseResult]]"; } };
                _debugHandled = _debugHandled || { toString: function () { return "[[PromiseIsHandled]]"; } };
                objDefineProp(thePromise, _debugState, { get: stateFn });
                objDefineProp(thePromise, _debugResult, { get: resultFn });
                objDefineProp(thePromise, _debugHandled, { get: handledFn });
            }
            function setPromiseDebugState(enabled, logger) {
                _promiseDebugEnabled = enabled;
            }

            var STRING_STATES = [
                "pending", "resolving", "resolved", "rejected"
            ];

            var DISPATCH_EVENT = "dispatchEvent";
            var _hasInitEvent;
            function emitEvent(target, evtName, populateEvent, useNewEvent) {
                var doc = getDocument();
                !_hasInitEvent && (_hasInitEvent = safeGetLazy(function () {
                    var evt;
                    if (doc && doc.createEvent) {
                        evt = doc.createEvent("Event");
                    }
                    return (!!evt && evt.initEvent);
                }, null));
                var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
                populateEvent && populateEvent(theEvt);
                if (_hasInitEvent.v) {
                    theEvt.initEvent(evtName, false, true);
                }
                if (theEvt && target[DISPATCH_EVENT]) {
                    target[DISPATCH_EVENT](theEvt);
                }
                else {
                    var handler = target["on" + evtName];
                    if (handler) {
                        handler(theEvt);
                    }
                    else {
                        var theConsole = getInst("console");
                        theConsole && (theConsole["error"] || theConsole["log"])(evtName, dumpObj(theEvt));
                    }
                }
            }

            var STR_PROMISE = "Promise";

            var NODE_UNHANDLED_REJECTION = "unhandledRejection";
            var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
            var _currentPromiseId = [];
            var _uniquePromiseId = 0;
            var _unhandledRejectionTimeout = 10;
            var _hasPromiseRejectionEvent;
            function dumpFnObj(value) {
                if (isFunction(value)) {
                    return value.toString();
                }
                return dumpObj(value);
            }
            function _createPromise(newPromise, processor, executor) {
                var additionalArgs = arrSlice(arguments, 3);
                var _state = 0 ;
                var _hasResolved = false;
                var _settledValue;
                var _queue = [];
                var _id = _uniquePromiseId++;
                var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
                var _handled = false;
                var _unHandledRejectionHandler = null;
                var _thePromise;
                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
                var _then = function (onResolved, onRejected) {
                    try {
                        _currentPromiseId.push(_id);
                        _handled = true;
                        _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                        _unHandledRejectionHandler = null;
                        var thenPromise = newPromise(function (resolve, reject) {
                            _queue.push(function () {
                                try {
                                    var handler = _state === 2  ? onResolved : onRejected;
                                    var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                                    if (isPromiseLike(value)) {
                                        value.then(resolve, reject);
                                    }
                                    else if (handler) {
                                        resolve(value);
                                    }
                                    else if (_state === 3 ) {
                                        reject(value);
                                    }
                                    else {
                                        resolve(value);
                                    }
                                }
                                catch (e) {
                                    reject(e);
                                }
                            });
                            if (_hasResolved) {
                                _processQueue();
                            }
                        }, additionalArgs);
                        return thenPromise;
                    }
                    finally {
                        _currentPromiseId.pop();
                    }
                };
                var _catch = function (onRejected) {
                    return _then(undefined, onRejected);
                };
                var _finally = function (onFinally) {
                    var thenFinally = onFinally;
                    var catchFinally = onFinally;
                    if (isFunction(onFinally)) {
                        thenFinally = function (value) {
                            onFinally && onFinally();
                            return value;
                        };
                        catchFinally = function (reason) {
                            onFinally && onFinally();
                            throw reason;
                        };
                    }
                    return _then(thenFinally, catchFinally);
                };
                var _strState = function () {
                    return STRING_STATES[_state];
                };
                var _processQueue = function () {
                    if (_queue.length > 0) {
                        var pending = _queue.slice();
                        _queue = [];
                        _handled = true;
                        processor(pending);
                        _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                        _unHandledRejectionHandler = null;
                    }
                };
                var _createSettleIfFn = function (newState, allowState) {
                    return function (theValue) {
                        if (_state === allowState) {
                            if (newState === 2  && isPromiseLike(theValue)) {
                                _state = 1 ;
                                theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                                return;
                            }
                            _state = newState;
                            _hasResolved = true;
                            _settledValue = theValue;
                            _processQueue();
                            if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                                _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                            }
                        }
                    };
                };
                var _notifyUnhandledRejection = function () {
                    if (!_handled) {
                        if (isNode()) {
                            process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
                        }
                        else {
                            var gbl = getWindow() || getGlobal();
                            emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                                objDefine(theEvt, "promise", { g: function () { return _thePromise; } });
                                theEvt.reason = _settledValue;
                                return theEvt;
                            }, !!_hasPromiseRejectionEvent.v);
                        }
                    }
                };
                _thePromise = {
                    then: _then,
                    "catch": _catch,
                    finally: _finally
                };
                objDefineProp(_thePromise, "state", {
                    get: _strState
                });
                if (_promiseDebugEnabled) {
                    _addDebugState$1(_thePromise, _strState, function () { return objToString(_settledValue); }, function () { return _handled; });
                }
                if (hasSymbol()) {
                    _thePromise[getKnownSymbol(11 )] = "IPromise";
                }
                var _toString = function () {
                    return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!isUndefined(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "");
                };
                _thePromise.toString = _toString;
                (function _initialize() {
                    if (!isFunction(executor)) {
                        throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
                    }
                    var _rejectFn = _createSettleIfFn(3 , 0 );
                    try {
                        executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
                    }
                    catch (e) {
                        _rejectFn(e);
                    }
                })();
                return _thePromise;
            }
            function _createAllPromise(newPromise) {
                return function (input) {
                    var additionalArgs = arrSlice(arguments, 1);
                    return newPromise(function (resolve, reject) {
                        try {
                            var values_1 = [];
                            var pending_1 = 1;
                            arrForEach(input, function (item, idx) {
                                if (item) {
                                    pending_1++;
                                    doAwait(item, function (value) {
                                        values_1[idx] = value;
                                        if (--pending_1 === 0) {
                                            resolve(values_1);
                                        }
                                    }, reject);
                                }
                            });
                            pending_1--;
                            if (pending_1 === 0) {
                                resolve(values_1);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    }, additionalArgs);
                };
            }
            function _createResolvedPromise(newPromise) {
                return function (value) {
                    var additionalArgs = arrSlice(arguments, 1);
                    if (isPromiseLike(value)) {
                        return value;
                    }
                    return newPromise(function (resolve) {
                        resolve(value);
                    }, additionalArgs);
                };
            }
            function _createRejectedPromise(newPromise) {
                return function (reason) {
                    var additionalArgs = arrSlice(arguments, 1);
                    return newPromise(function (_resolve, reject) {
                        reject(reason);
                    }, additionalArgs);
                };
            }

            var _processPendingItems = function (pending) {
                arrForEach(pending, function (fn) {
                    try {
                        fn();
                    }
                    catch (e) {
                    }
                });
            };
            function syncItemProcessor() {
                return _processPendingItems;
            }
            function timeoutItemProcessor(timeout) {
                var callbackTimeout = isNumber(timeout) ? timeout : 0;
                return function (pending) {
                    scheduleTimeout(function () {
                        _processPendingItems(pending);
                    }, callbackTimeout);
                };
            }
            function idleItemProcessor(timeout) {
                var options;
                if (timeout >= 0) {
                    options = {
                        timeout: +timeout
                    };
                }
                return function (pending) {
                    scheduleIdleCallback(function (deadline) {
                        _processPendingItems(pending);
                    }, options);
                };
            }

            function createAsyncPromise(executor, timeout) {
                return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
            }
            var createAsyncAllPromise = exports('createAsyncAllPromise', _createAllPromise(createAsyncPromise));
            var createAsyncResolvedPromise = exports('createAsyncResolvedPromise', _createResolvedPromise(createAsyncPromise));
            var createAsyncRejectedPromise = exports('createAsyncRejectedPromise', _createRejectedPromise(createAsyncPromise));

            var _isPromiseSupported;
            function createNativePromise(executor, timeout) {
                !_isPromiseSupported && (_isPromiseSupported = lazySafeGetInst(STR_PROMISE));
                var PrmCls = _isPromiseSupported.v;
                if (!PrmCls) {
                    return createAsyncPromise(executor);
                }
                if (!isFunction(executor)) {
                    throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
                }
                var _state = 0 ;
                function _strState() {
                    return STRING_STATES[_state];
                }
                var thePromise = new PrmCls(function (resolve, reject) {
                    function _resolve(value) {
                        _state = 2 ;
                        resolve(value);
                    }
                    function _reject(reason) {
                        _state = 3 ;
                        reject(reason);
                    }
                    executor(_resolve, _reject);
                });
                objDefineProp(thePromise, "state", {
                    get: _strState
                });
                return thePromise;
            }
            var createNativeAllPromise = exports('createNativeAllPromise', _createAllPromise(createNativePromise));
            var createNativeResolvedPromise = exports('createNativeResolvedPromise', _createResolvedPromise(createNativePromise));
            var createNativeRejectedPromise = exports('createNativeRejectedPromise', _createRejectedPromise(createNativePromise));

            function createSyncPromise(executor) {
                return _createPromise(createSyncPromise, syncItemProcessor(), executor);
            }
            var createSyncAllPromise = exports('createSyncAllPromise', _createAllPromise(createSyncPromise));
            var createSyncResolvedPromise = exports('createSyncResolvedPromise', _createResolvedPromise(createSyncPromise));
            var createSyncRejectedPromise = exports('createSyncRejectedPromise', _createRejectedPromise(createSyncPromise));

            var _defaultIdleTimeout;
            function setDetaultIdleTimeout(idleDeadline) {
                _defaultIdleTimeout = idleDeadline;
            }
            function createIdlePromise(executor, timeout) {
                var theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;
                return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);
            }
            var createIdleAllPromise = exports('createIdleAllPromise', _createAllPromise(createIdlePromise));
            var createIdleResolvedPromise = exports('createIdleResolvedPromise', _createResolvedPromise(createIdlePromise));
            var createIdleRejectedPromise = exports('createIdleRejectedPromise', _createRejectedPromise(createIdlePromise));

            var _promiseCreator;
            function setCreatePromiseImpl(creator) {
                _promiseCreator = creator ? getLazy(function () { return creator; }) : null;
            }
            function createPromise(executor, timeout) {
                !_promiseCreator && (_promiseCreator = getLazy(function () { return createNativePromise; }));
                return _promiseCreator.v.call(this, executor, timeout);
            }
            var createAllPromise = exports('createAllPromise', _createAllPromise(createPromise));
            var createResolvedPromise = exports('createResolvedPromise', _createResolvedPromise(createPromise));
            var createRejectedPromise = exports('createRejectedPromise', _createRejectedPromise(createPromise));

            var REJECT = "reject";
            var REJECTED_ERROR = "Rejected";
            var _schedulerId = 0;
            var _debugName;
            var _debugIntState;
            var _customErrors = {};
            var _rejectDone = function () {
            };
            var _createError = function (type, evt, message) {
                !_customErrors[type] && (_customErrors[type] = createCustomError(type));
                var now = utcNow();
                return new (_customErrors[type])("Task [".concat(evt.id, "] ").concat(message || "", "- ").concat((evt.st ? "Running" : "Waiting"), ": ").concat(_calcTime(now, evt.st || evt.cr)));
            };
            function _calcTime(now, start) {
                return ((now - start) || "0") + " ms";
            }
            function _abortStaleTasks(taskQueue, staleTimeoutPeriod) {
                var now = utcNow();
                var expired = now - staleTimeoutPeriod;
                arrForEach(taskQueue, function (evt) {
                    if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {
                        evt && evt[REJECT](evt.rj || _createError("Aborted", evt, "Stale "));
                    }
                });
            }
            function _removeTask(queue, taskDetail) {
                var idx = arrIndexOf(queue, taskDetail);
                if (idx !== -1) {
                    queue.splice(idx, 1);
                }
            }
            function _addDebugState(theScheduler, nameFn, stateFn) {
                _debugName = _debugName || { toString: function () { return "[[SchedulerName]]"; } };
                _debugIntState = _debugIntState || { toString: function () { return "[[SchedulerState]]"; } };
                objDefineProp(theScheduler, _debugName, { get: nameFn });
                objDefineProp(theScheduler, _debugIntState, { get: stateFn });
            }
            function createTaskScheduler(newPromise, name) {
                var _theTask;
                var _running = [];
                var _waiting = [];
                var _staleTimeoutPeriod = 600000;
                var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;
                var _taskCount = 0;
                var _schedulerName = (name ? (name + ".") : "") + _schedulerId++;
                var _blockedTimer;
                newPromise = newPromise || createPromise;
                var _startBlockedTimer = function () {
                    var hasTasks = (getLength(_running) + getLength(_waiting)) > 0;
                    if (_staleTimeoutPeriod > 0) {
                        if (!_blockedTimer) {
                            _blockedTimer = scheduleTimeout(function () {
                                _abortStaleTasks(_running, _staleTimeoutPeriod);
                                _abortStaleTasks(_waiting, _staleTimeoutPeriod);
                                _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));
                            }, _staleTimeoutCheckPeriod);
                            _blockedTimer.unref();
                        }
                        _blockedTimer && (_blockedTimer.enabled = hasTasks);
                    }
                };
                var _queueTask = function (startAction, taskName, timeout) {
                    var _a;
                    var taskId = _schedulerName + "." + _taskCount++;
                    if (taskName) {
                        taskId += "-(" + taskName + ")";
                    }
                    var newTask = (_a = {
                            id: taskId,
                            cr: utcNow(),
                            to: timeout
                        },
                        _a[REJECT] = function (reason) {
                            newTask.rj = reason || _createError(REJECTED_ERROR, newTask);
                            newTask[REJECT] = _rejectDone;
                        },
                        _a);
                    if (!_theTask) {
                        newTask.p = newPromise(_runTask(newTask, startAction));
                    }
                    else {
                        newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);
                    }
                    _theTask = newTask;
                    return newTask.p;
                };
                var _runTask = function (taskDetail, startAction) {
                    taskDetail.st = utcNow();
                    _running.push(taskDetail);
                    _startBlockedTimer();
                    return function (onTaskResolve, onTaskReject) {
                        var _promiseReject = function (reason) {
                            taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);
                            taskDetail[REJECT] = _rejectDone;
                            _doCleanup(taskDetail);
                            onTaskResolve = null;
                            onTaskReject && onTaskReject(reason);
                            onTaskReject = null;
                        };
                        var taskId = taskDetail.id;
                        if (taskDetail.rj) {
                            _promiseReject(taskDetail.rj);
                        }
                        else {
                            taskDetail[REJECT] = _promiseReject;
                            try {
                                var startResult = startAction(taskId);
                                if (taskDetail.to && isPromiseLike(startResult)) {
                                    taskDetail.t = scheduleTimeout(function () {
                                        _promiseReject(_createError("Timeout", taskDetail));
                                    }, taskDetail.to);
                                }
                                doAwait(startResult, function (theResult) {
                                    _doCleanup(taskDetail);
                                    onTaskReject = null;
                                    onTaskResolve && onTaskResolve(theResult);
                                    onTaskResolve = null;
                                }, _promiseReject);
                            }
                            catch (e) {
                                _promiseReject(e);
                            }
                        }
                    };
                };
                var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {
                    _waiting.push(taskDetail);
                    _startBlockedTimer();
                    return newPromise(function (onWaitResolve, onWaitReject) {
                        taskDetail.id;
                        prevTask.id;
                        doAwaitResponse(prevTask.p, function () {
                            _removeTask(_waiting, taskDetail);
                            _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);
                        });
                    });
                };
                var _doCleanup = function (taskDetail) {
                    _removeTask(_running, taskDetail);
                    taskDetail.t && taskDetail.t.cancel();
                    taskDetail.t = null;
                    if (_theTask && _theTask === taskDetail) {
                        _theTask = null;
                        if (getLength(_running) + getLength(_waiting) === 0) {
                            _blockedTimer && _blockedTimer.cancel();
                            _blockedTimer = null;
                        }
                    }
                };
                var theScheduler = {
                    idle: true,
                    queue: _queueTask,
                    setStaleTimeout: function (staleTimeout, staleCheckPeriod) {
                        _blockedTimer && _blockedTimer.cancel();
                        _blockedTimer = null;
                        _staleTimeoutPeriod = staleTimeout;
                        _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;
                        _startBlockedTimer();
                    }
                };
                objDefine(theScheduler, "idle", {
                    g: function () {
                        return getLength(_running) + getLength(_waiting) === 0;
                    }
                });
                _addDebugState(theScheduler, function () { return _schedulerName; }, function () {
                    return {
                        l: _theTask,
                        r: _running,
                        w: _waiting
                    };
                });
                return theScheduler;
            }

        })
    };
}));
//# sourceMappingURL=ts-async.js.map
