{"version":3,"file":"taskScheduler.js","sourceRoot":"","sources":["../../src/scheduler/taskScheduler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach, arrIndexOf, createCustomError, CustomErrorConstructor, getLength, isPromiseLike, ITimerHandler, objDefine, objDefineProp, scheduleTimeout, utcNow } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse, doFinally } from \"../promise/await\";\r\nimport { _debugLog } from \"../promise/debug\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor, RejectPromiseHandler, ResolvePromiseHandler,StartQueuedTaskFn } from \"../interfaces/types\";\r\nimport { ITaskDetail } from \"../internal/ITaskDetail\";\r\nimport { ITaskScheduler } from \"../interfaces/ITaskScheduler\";\r\nimport { createPromise } from \"../promise/promise\";\r\n\r\nconst REJECT = \"reject\";\r\nconst REJECTED_ERROR = \"Rejected\";\r\n\r\nlet _schedulerId: number = 0;\r\nlet _debugName: any;\r\nlet _debugIntState: any;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nlet _customErrors: { [type: string]: CustomErrorConstructor } = {};\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal structure for report the debugging state\r\n */\r\ninterface _InternalDebugState {\r\n    l: ITaskDetail,\r\n    r: ITaskDetail[],\r\n    w: ITaskDetail[]\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Empty reject function to avoid trying to re-reject\r\n */\r\nconst _rejectDone = () => {\r\n    // A Do nothing function\r\n}\r\n\r\nvar _createError = (type: string, evt: ITaskDetail, message?: string): Error => {\r\n    // Lazily create the class\r\n    !_customErrors[type] && (_customErrors[type] = createCustomError(type));\r\n\r\n    let now = utcNow();\r\n    return new (_customErrors[type])(`Task [${evt.id}] ${message||\"\"}- ${(evt.st ? \"Running\" : \"Waiting\")}: ${_calcTime(now, evt.st || evt.cr)}`);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function used for displaying the time in milliseconds (during debugging)\r\n * @param now - The current time\r\n * @param start - The start time to subtract\r\n * @returns A string representation of the time difference\r\n */\r\nfunction _calcTime(now: number, start: number) {\r\n    return ((now - start) || \"0\") + \" ms\";\r\n}\r\n\r\n/**\r\n * Abort any stale tasks in the provided task Queue\r\n * @param taskQueue - The Task Queue to search\r\n * @param staleTimeoutPeriod - The maxumum stale timeout period\r\n */\r\nfunction _abortStaleTasks(taskQueue: ITaskDetail[], staleTimeoutPeriod: number): void {\r\n    let now = utcNow();\r\n    let expired = now - staleTimeoutPeriod;\r\n    arrForEach(taskQueue, (evt) => {\r\n        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {\r\n            evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Remove the `taskDetail` from the `queue` if present\r\n * @param queue - The Task Queue\r\n * @param taskDetail - The Task detail to be removed\r\n */\r\nfunction _removeTask(queue: ITaskDetail[], taskDetail: ITaskDetail): void {\r\n    let idx = arrIndexOf(queue, taskDetail);\r\n    if (idx !== -1) {\r\n        queue.splice(idx, 1);\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore Internal function to add the debug state to the promise, this code is removed from the production artifacts\r\n * @param theScheduler - The scheduler instance to add the debug accessors to.\r\n * @param nameFn - The function to return then name of this scheduler\r\n * @param stateFn - The function to return the internal state of the scheduler\r\n */\r\nfunction _addDebugState(theScheduler: any, nameFn: () => string, stateFn: () => _InternalDebugState) {\r\n    _debugName = _debugName || { toString: () => \"[[SchedulerName]]\" };\r\n    _debugIntState = _debugIntState || { toString: () => \"[[SchedulerState]]\" };\r\n    \r\n    objDefineProp(theScheduler, _debugName, { get: nameFn });\r\n    objDefineProp(theScheduler, _debugIntState, { get: stateFn });\r\n}\r\n\r\n/**\r\n * Create a Task Scheduler using the optional promise implementation and scheduler name.\r\n * The newPromise can be any value promise creation function, where the execution of the\r\n * queued tasks will be processed based on how the promise implementation processes it's\r\n * chained promises (asynchrounsly; synchronously; idle processing, etc)\r\n *\r\n * The functions used to start each task my return a result (synchronous execution) or an\r\n * {@link IPromise}, `PromiseLike` or `Promise` result (asynchronous execution).\r\n *\r\n * Each task is executed in the order that it was queued and the provided `startTask` function\r\n * will not be called until all previous tasks have completed (whther they resolve or reject).\r\n * The result from any previous task does not affect and is not passed to any later scheduled\r\n * task, if you need this capability then your `startTask` functions will need to co-operate to\r\n * share any common context.\r\n *\r\n * By default, queued tasks which have either been \"waiting\" to run or have been running longer\r\n * then 10 minutes will be Auto-Rejected to try and free up resources. If a task is running when\r\n * it rejected then it will continue to \"run\" based on whatever operation it's `startTask` is\r\n * performing. If a task has not yet had it's `startTask` function called it will never get called.\r\n * In both cases the `IPromise` returned by the call to {@link ITaskScheduler.queue | queue} the\r\n * task will be `rejected`. You can change this default time, including disabling completly via\r\n * the {@link ITaskScheduler.setStaleTimeout | setStaleTimeout}\r\n * function.\r\n * @since 0.2.0\r\n * @group Scheduler\r\n * @param newPromise - The function to use for creating a new promise when required, if not\r\n * provided this will default to {@link createPromise} which will use the default registered\r\n * promise creation function which defaults to runtime native promises or async Promise if not\r\n * supported by the runtime.\r\n * @param name - The name you want to associated with this scheduler, mostly useful for debugging\r\n * @returns A new ITaskScheduler instance\r\n * @example\r\n * ```ts\r\n * let scheduler = createTaskScheduler();\r\n *\r\n * // Schedule a task using the ts-async helper promise functions\r\n * scheduler.queue(() => {\r\n *     return createPromise((resolve, reject) => {\r\n *         scheduleTimeout(() => {\r\n *             // Do something after a delay\r\n *         }, 100);\r\n *     });\r\n * });\r\n *\r\n * // Schedule an asynchronous task which uses async/await\r\n * scheduler.queue(async () => {\r\n *     // This task will only execute after the previous task has completed\r\n *     await performAnotherAsyncTask();\r\n * });\r\n *\r\n * // Schedule a synchronous task that executes and completes immediately\r\n * scheduled.queue(() => {\r\n *     // Do some synchronous task\r\n *     return 42;\r\n * });\r\n *\r\n * // Schedule an asynchronous task which returns a promise\r\n * scheduled.queue(() => {\r\n *     return doAwait(fetch(\"https://github.com/nevware21/ts-async/blob/main/README.md\"), (response) => {\r\n *         let theReadMe = response.text();\r\n *         // Do something with the readme\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport function createTaskScheduler(newPromise?: <T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>, name?: string): ITaskScheduler {\r\n    let _theTask: ITaskDetail;\r\n    let _running: ITaskDetail[] = [];\r\n    let _waiting: ITaskDetail[] = [];\r\n    let _staleTimeoutPeriod = 600000;            // 10 Minutes\r\n    let _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;    // 1 Minute\r\n    let _taskCount = 0;\r\n    let _schedulerName = (name ? (name + \".\") : \"\") + _schedulerId++;\r\n    let _blockedTimer: ITimerHandler;\r\n\r\n    // Make sure that a promise creator has been assigned\r\n    newPromise = newPromise || createPromise;\r\n\r\n    const _startBlockedTimer = () => {\r\n        let hasTasks = (getLength(_running) + getLength(_waiting)) > 0;\r\n        if (_staleTimeoutPeriod > 0) {\r\n            if (!_blockedTimer) {\r\n                // Only attempt to drop stale / blocked tasks if the timeout period is defined\r\n                _blockedTimer = scheduleTimeout(() => {\r\n                    _abortStaleTasks(_running, _staleTimeoutPeriod);\r\n                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);\r\n                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));\r\n                }, _staleTimeoutCheckPeriod);\r\n\r\n                _blockedTimer.unref();\r\n            }\r\n\r\n            _blockedTimer && (_blockedTimer.enabled = hasTasks);\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"Stale Timer disabled\");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    const _queueTask = <T>(startAction: StartQueuedTaskFn<T>, taskName?: string, timeout?: number): IPromise<T> => {\r\n        let taskId: string = _schedulerName + \".\" + _taskCount++;\r\n        if (taskName) {\r\n            taskId += \"-(\" + taskName + \")\";\r\n        }\r\n       \r\n        let newTask: ITaskDetail = {\r\n            id: taskId,\r\n            cr: utcNow(),\r\n            to: timeout,\r\n            [REJECT]: (reason: any) => {\r\n                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\r\n                newTask[REJECT] = _rejectDone;\r\n            }\r\n        };\r\n\r\n        if (!_theTask) {\r\n            // We don't have any currently running task, so just start the next task\r\n            newTask.p = newPromise(_runTask(newTask, startAction));\r\n        } else {\r\n            // Start a new promise which will wait until all current active tasks are completed before starting\r\n            // the new task, it does not resolve this scheduled task until after the new task is resolve to\r\n            // ensure that all scheduled tasks are completed in the correct order\r\n            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\r\n        }\r\n\r\n        // Set this new task as the last one, so that any future tasks will wait for this one\r\n        _theTask = newTask;\r\n\r\n        return newTask.p;\r\n    }\r\n\r\n    const _runTask = <T>(taskDetail: ITaskDetail, startAction: StartQueuedTaskFn<T>): PromiseExecutor<T> => {\r\n        taskDetail.st = utcNow();\r\n\r\n        // There should only ever be a single \"running\" task, but using an array\r\n        // for code reuse.\r\n        _running.push(taskDetail);\r\n        _startBlockedTimer();\r\n\r\n        // Create and return the promise executor for this action\r\n        return <T>(onTaskResolve: ResolvePromiseHandler<T>, onTaskReject: RejectPromiseHandler) => {\r\n            const _promiseReject = (reason: any) => {\r\n                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\r\n                taskDetail[REJECT] = _rejectDone;\r\n                _doCleanup(taskDetail);\r\n                onTaskResolve = null;\r\n                onTaskReject && onTaskReject(reason);\r\n                onTaskReject = null;\r\n            }\r\n\r\n            let taskId = taskDetail.id;\r\n\r\n            if (taskDetail.rj) {\r\n                // Already aborted / pre-rejected\r\n                _promiseReject(taskDetail.rj);\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_schedulerName, \"Task [\" + taskId + \"] Started after \" + _calcTime(taskDetail.st, taskDetail.cr));\r\n                //#endif\r\n                taskDetail[REJECT] = _promiseReject;\r\n\r\n                try {\r\n                    let startResult = startAction(taskId);\r\n                    if (taskDetail.to && isPromiseLike(startResult)) {\r\n                        taskDetail.t = scheduleTimeout(() => {\r\n                            _promiseReject(_createError(\"Timeout\", taskDetail));\r\n                        }, taskDetail.to);\r\n                    }\r\n\r\n                    doAwait(startResult, (theResult) => {\r\n                        _doCleanup(taskDetail);\r\n                        onTaskReject = null;\r\n                        onTaskResolve && onTaskResolve(theResult as any);\r\n                        onTaskResolve = null;\r\n                    }, _promiseReject);\r\n                } catch (e) {\r\n                    _promiseReject(e);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    const _waitForPreviousTask = <T>(taskDetail: ITaskDetail, prevTask: ITaskDetail, startAction: StartQueuedTaskFn<T>): IPromise<T> => {\r\n        _waiting.push(taskDetail);\r\n        _startBlockedTimer();\r\n\r\n        return newPromise((onWaitResolve, onWaitReject) => {\r\n            let taskId = taskDetail.id;\r\n            let prevTaskId = prevTask.id;\r\n\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"[\" + taskId + \"] is waiting for [\" + prevTaskId + \"] to complete before starting -- [\" + _waiting.length + \"] waiting\");\r\n            //#endif\r\n\r\n            // Wait for the previous tasks to complete before starting this one.\r\n            // This ensures the queue execution order and avoids removing tasks that\r\n            // have not yet been started.\r\n            doAwaitResponse(prevTask.p, () => {\r\n                _removeTask(_waiting, taskDetail);\r\n                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\r\n            });\r\n        });\r\n    }\r\n\r\n    const _doCleanup = (taskDetail: ITaskDetail) => {\r\n        _removeTask(_running, taskDetail);\r\n\r\n        // If there was a timeout stop and clear\r\n        taskDetail.t && taskDetail.t.cancel();\r\n        taskDetail.t = null;\r\n\r\n        // Clear the matching current task now that it's complete\r\n        if (_theTask && _theTask === taskDetail) {\r\n            _theTask = null;\r\n            if (getLength(_running) + getLength(_waiting) === 0) {\r\n                _blockedTimer && _blockedTimer.cancel();\r\n                _blockedTimer = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    let theScheduler: ITaskScheduler =  {\r\n        idle: true,\r\n        queue: _queueTask,\r\n        setStaleTimeout: (staleTimeout: number, staleCheckPeriod?: number) => {\r\n            _blockedTimer && _blockedTimer.cancel();\r\n            _blockedTimer = null;\r\n            _staleTimeoutPeriod = staleTimeout;\r\n            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\r\n            _startBlockedTimer();\r\n        }\r\n    };\r\n\r\n    // Change the idle property to dynamic\r\n    objDefine(theScheduler, \"idle\", {\r\n        g: () => {\r\n            return getLength(_running) + getLength(_waiting) === 0;\r\n        }\r\n    });\r\n\r\n    _addDebugState(theScheduler, () => _schedulerName,\r\n        () => {\r\n            return {\r\n                l: _theTask,\r\n                r: _running,\r\n                w: _waiting\r\n            }\r\n        });\r\n\r\n    return theScheduler;\r\n}\r\n"]}