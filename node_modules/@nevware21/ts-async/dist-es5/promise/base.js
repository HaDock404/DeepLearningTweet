/*
 * @nevware21/ts-async
 * https://github.com/nevware21/ts-async
 *
 * Copyright (c) 2022 Nevware21
 * Licensed under the MIT license.
 */
import { arrForEach, arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined, throwTypeError, objToString, scheduleTimeout, getWindow, isNode, getGlobal, objDefine, objDefineProp, lazySafeGetInst } from "@nevware21/ts-utils";
import { doAwait } from "./await";
import { _addDebugState, _promiseDebugEnabled } from "./debug";
import { STRING_STATES } from "../internal/state";
import { emitEvent } from "./event";
import { STR_PROMISE } from "../internal/constants";
var NODE_UNHANDLED_REJECTION = "unhandledRejection";
var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
var _currentPromiseId = [];
var _uniquePromiseId = 0;
var _unhandledRejectionTimeout = 10;
var _hasPromiseRejectionEvent;
function dumpFnObj(value) {
    if (isFunction(value)) {
        return value.toString();
    }
    return dumpObj(value);
}
export function _createPromise(newPromise, processor, executor) {
    var additionalArgs = arrSlice(arguments, 3);
    var _state = 0 /* ePromiseState.Pending */;
    var _hasResolved = false;
    var _settledValue;
    var _queue = [];
    var _id = _uniquePromiseId++;
    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
    var _handled = false;
    var _unHandledRejectionHandler = null;
    var _thePromise;
    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    var _then = function (onResolved, onRejected) {
        try {
            _currentPromiseId.push(_id);
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            //#ifdef DEBUG
            //#:(!DEBUG) _debugLog(_toString(), "then(" + dumpFnObj(onResolved)+ ", " + dumpFnObj(onResolved) +  ")");
            //#endif
            var thenPromise = newPromise(function (resolve, reject) {
                // Queue the new promise returned to be resolved or rejected
                // when this promise settles.
                _queue.push(function () {
                    // https://tc39.es/ecma262/#sec-newpromisereactionjob
                    //let value: any;
                    try {
                        // First call the onFulfilled or onRejected handler, on the settled value
                        // of this promise. If the corresponding `handler` does not exist, simply
                        // pass through the settled value.
                        //#ifdef DEBUG
                        //#:(!DEBUG) _debugLog(_toString(), "Handling settled value " + dumpFnObj(_settledValue));
                        //#endif
                        var handler = _state === 2 /* ePromiseState.Resolved */ ? onResolved : onRejected;
                        var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                        //#ifdef DEBUG
                        //#:(!DEBUG) _debugLog(_toString(), "Handling Result " + dumpFnObj(value));
                        //#endif
                        if (isPromiseLike(value)) {
                            // The called handlers returned a new promise, so the chained promise
                            // will follow the state of this promise.
                            value.then(resolve, reject);
                        }
                        else if (handler) {
                            // If we have a handler then chained promises are always "resolved" with the result returned
                            resolve(value);
                        }
                        else if (_state === 3 /* ePromiseState.Rejected */) {
                            // If this promise is rejected then the chained promise should be rejected
                            // with either the settled value of this promise or the return value of the handler.
                            reject(value);
                        }
                        else {
                            // If this promise is fulfilled, then the chained promise is also fulfilled
                            // with either the settled value of this promise or the return value of the handler.
                            resolve(value);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
                //#ifdef DEBUG
                //#:(!DEBUG) _debugLog(_toString(), "Added to Queue " + _queue.length);
                //#endif
                // If this promise is already settled, then immediately process the callback we
                // just added to the queue.
                if (_hasResolved) {
                    _processQueue();
                }
            }, additionalArgs);
            //#ifdef DEBUG
            //#:(!DEBUG) _debugLog(_toString(), "Created -> " + thenPromise.toString());
            //#endif
            return thenPromise;
        }
        finally {
            _currentPromiseId.pop();
        }
    };
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    var _catch = function (onRejected) {
        // Reuse then onRejected to support rejection
        return _then(undefined, onRejected);
    };
    // https://tc39.es/ecma262/#sec-promise.prototype.finally
    var _finally = function (onFinally) {
        var thenFinally = onFinally;
        var catchFinally = onFinally;
        if (isFunction(onFinally)) {
            thenFinally = function (value) {
                onFinally && onFinally();
                return value;
            };
            catchFinally = function (reason) {
                onFinally && onFinally();
                throw reason;
            };
        }
        return _then(thenFinally, catchFinally);
    };
    var _strState = function () {
        return STRING_STATES[_state];
    };
    var _processQueue = function () {
        if (_queue.length > 0) {
            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,
            // we make a copy of the queue and work on it once the current call stack unwinds.
            var pending = _queue.slice();
            _queue = [];
            //#ifdef DEBUG
            //#:(!DEBUG) _debugLog(_toString(), "Processing queue " + pending.length);
            //#endif
            _handled = true;
            processor(pending);
            //#ifdef DEBUG
            //#:(!DEBUG) _debugLog(_toString(), "Processing done");
            //#endif
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
        }
        else {
            //#ifdef DEBUG
            //#:(!DEBUG) _debugLog(_toString(), "Empty Processing queue ");
            //#endif
        }
    };
    var _createSettleIfFn = function (newState, allowState) {
        return function (theValue) {
            if (_state === allowState) {
                if (newState === 2 /* ePromiseState.Resolved */ && isPromiseLike(theValue)) {
                    _state = 1 /* ePromiseState.Resolving */;
                    //#ifdef DEBUG
                    //#:(!DEBUG) _debugLog(_toString(), "Resolving");
                    //#endif
                    theValue.then(_createSettleIfFn(2 /* ePromiseState.Resolved */, 1 /* ePromiseState.Resolving */), _createSettleIfFn(3 /* ePromiseState.Rejected */, 1 /* ePromiseState.Resolving */));
                    return;
                }
                _state = newState;
                _hasResolved = true;
                _settledValue = theValue;
                //#ifdef DEBUG
                //#:(!DEBUG) _debugLog(_toString(), _strState());
                //#endif
                _processQueue();
                if (!_handled && newState === 3 /* ePromiseState.Rejected */ && !_unHandledRejectionHandler) {
                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                }
            }
            else {
                //#ifdef DEBUG
                //#:(!DEBUG) _debugLog(_toString(), "Already " + _strState());
                //#endif
            }
        };
    };
    var _notifyUnhandledRejection = function () {
        if (!_handled) {
            if (isNode()) {
                //#ifdef DEBUG
                //#:(!DEBUG) _debugLog(_toString(), "Emitting " + NODE_UNHANDLED_REJECTION);
                //#endif
                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            }
            else {
                var gbl = getWindow() || getGlobal();
                //#ifdef DEBUG
                //#:(!DEBUG) _debugLog(_toString(), "Emitting " + UNHANDLED_REJECTION);
                //#endif
                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                    objDefine(theEvt, "promise", { g: function () { return _thePromise; } });
                    theEvt.reason = _settledValue;
                    return theEvt;
                }, !!_hasPromiseRejectionEvent.v);
            }
        }
    };
    _thePromise = {
        then: _then,
        "catch": _catch,
        finally: _finally
    };
    objDefineProp(_thePromise, "state", {
        get: _strState
    });
    if (_promiseDebugEnabled) {
        // eslint-disable-next-line brace-style
        _addDebugState(_thePromise, _strState, function () { return objToString(_settledValue); }, function () { return _handled; });
    }
    if (hasSymbol()) {
        _thePromise[getKnownSymbol(11 /* WellKnownSymbols.toStringTag */)] = "IPromise";
    }
    var _toString = function () {
        return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!isUndefined(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "");
    };
    _thePromise.toString = _toString;
    (function _initialize() {
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        }
        var _rejectFn = _createSettleIfFn(3 /* ePromiseState.Rejected */, 0 /* ePromiseState.Pending */);
        try {
            //#ifdef DEBUG
            //#:(!DEBUG) _debugLog(_toString(), "Executing");
            //#endif
            executor.call(_thePromise, _createSettleIfFn(2 /* ePromiseState.Resolved */, 0 /* ePromiseState.Pending */), _rejectFn);
        }
        catch (e) {
            _rejectFn(e);
        }
    })();
    //#ifdef DEBUG
    //#:(!DEBUG) _debugLog(_toString(), "Returning");
    //#endif
    return _thePromise;
}
/**
 * @ignore
 * @internal
 * Returns a function which when called will return a new Promise object that resolves to an array of the
 * results from the input promises. The returned promise will resolve when all of the inputs' promises have
 * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises
 * rejected or non-promises throwing an error, and will reject with this first rejection message / error.
 * @param newPromise - The delegate function used to create a new promise object the new promise instance.
 * @returns A function to create a promise that will be resolved when all arguments are resolved.
 */
export function _createAllPromise(newPromise) {
    return function (input) {
        var additionalArgs = arrSlice(arguments, 1);
        return newPromise(function (resolve, reject) {
            try {
                var values_1 = [];
                var pending_1 = 1; // Prefix to 1 so we finish iterating over all of the input promises first
                arrForEach(input, function (item, idx) {
                    if (item) {
                        pending_1++;
                        doAwait(item, function (value) {
                            // Set the result values
                            values_1[idx] = value;
                            if (--pending_1 === 0) {
                                resolve(values_1);
                            }
                        }, reject);
                    }
                });
                // Now decrement the pending so that we finish correctly
                pending_1--;
                if (pending_1 === 0) {
                    // All promises were either resolved or where not a promise
                    resolve(values_1);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    };
}
/**
 * @ignore
 * @internal
 * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is
 * PromiseLike (i.e. has a "then" method), the returned promise will "follow" that thenable, adopting its eventual
 * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers
 * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.
 * @param newPromise - The delegate function used to create a new promise object
 * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.
 * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of
 * the new promise instance.
 */
export function _createResolvedPromise(newPromise) {
    return function (value) {
        var additionalArgs = arrSlice(arguments, 1);
        if (isPromiseLike(value)) {
            return value;
        }
        return newPromise(function (resolve) {
            resolve(value);
        }, additionalArgs);
    };
}
/**
 * @ignore
 * @internal
 * Return a promise like object that is rejected with the given reason.
 * @param newPromise - The delegate function used to create a new promise object
 * @param reason - The rejection reason
 * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of
 * the new promise instance.
 */
export function _createRejectedPromise(newPromise) {
    return function (reason) {
        var additionalArgs = arrSlice(arguments, 1);
        return newPromise(function (_resolve, reject) {
            reject(reason);
        }, additionalArgs);
    };
}
//# sourceMappingURL=base.js.map