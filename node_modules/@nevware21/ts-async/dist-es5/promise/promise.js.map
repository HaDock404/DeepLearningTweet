{"version":3,"file":"promise.js","sourceRoot":"","sources":["../../src/promise/promise.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,OAAO,EAAc,MAAM,qBAAqB,CAAC;AAC1D,OAAO,EAAE,iBAAiB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,MAAM,QAAQ,CAAC;AAE3F,OAAO,EAAE,mBAAmB,EAAE,MAAM,iBAAiB,CAAC;AAGtD,IAAI,eAA+F,CAAC;AAEpG;;;;;;;;;GASG;AACH,MAAM,UAAU,oBAAoB,CAChC,OAA2E;IAE3E,eAAe,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,cAAM,OAAA,OAAO,EAAP,CAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AAC9D,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,aAAa,CAAI,QAA4B,EAAE,OAAgB;IAC3E,CAAC,eAAe,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,cAAM,OAAA,mBAAmB,EAAnB,CAAmB,CAAC,CAAC,CAAC;IAE3E,OAAO,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAC3D,CAAC;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,CAAC,IAAM,gBAAgB,GAAoE,iBAAiB,CAAC,aAAa,CAAC,CAAC;AAElI;;;;;;;;;GASG;AACH,MAAM,CAAC,IAAM,qBAAqB,GAAmD,sBAAsB,CAAC,aAAa,CAAC,CAAC;AAE3H;;;;;;;;GAQG;AACH,MAAM,CAAC,IAAM,qBAAqB,GAAgE,sBAAsB,CAAC,aAAa,CAAC,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getLazy, ILazyValue } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createNativePromise } from \"./nativePromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\n\r\nlet _promiseCreator: ILazyValue<<T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>>;\r\n\r\n/**\r\n * Set the default promise implementation to use when calling `createPromise`; `createAllPromise`; `createResolvedPromise`\r\n * and `createRejectedPromise`. This is effective a global value and changing this will affect ALL callers of these\r\n * functions, as such these functions should only be used when switching implementations would have not unexpected\r\n * consequences like switching from a `createSyncPromise` to `createIdlePromise` where idle promises have a possibility\r\n * of never getting called during application shutdown or during an expected timeframe.\r\n * @group Alias\r\n * @group Promise\r\n * @param creator - The creator function to call when a new promise is required.\r\n */\r\nexport function setCreatePromiseImpl(\r\n    creator: <T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>\r\n) {\r\n    _promiseCreator = creator ? getLazy(() => creator) : null;\r\n}\r\n\r\n/**\r\n * Creates a Promise instance using the current default promise creator that when resolved or rejected will execute\r\n * it's pending chained operations.\r\n * @group Alias\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - [Optional] timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createPromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T>  {\r\n    !_promiseCreator && (_promiseCreator = getLazy(() => createNativePromise));\r\n\r\n    return _promiseCreator.v.call(this, executor, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createAllPromise: <T>(input: PromiseLike<T>[], timeout?: number) => IPromise<T[]> = _createAllPromise(createPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = _createResolvedPromise(createPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = _createRejectedPromise(createPromise);\r\n"]}