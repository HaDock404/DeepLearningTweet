{"version":3,"file":"nativePromise.js","sourceRoot":"","sources":["../../src/promise/nativePromise.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AACpD,OAAO,EAAE,iBAAiB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,MAAM,QAAQ,CAAC;AAE3F,OAAO,EAAiB,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAEjE,OAAO,EAAE,OAAO,EAAE,eAAe,EAAc,UAAU,EAAE,aAAa,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAC;AACtH,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AAEpD,IAAI,mBAAmD,CAAC;AAExD;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,mBAAmB,CAAI,QAA4B,EAAE,OAAgB;IACjF,CAAC,mBAAmB,IAAI,CAAC,mBAAmB,GAAG,eAAe,CAAC,WAAW,CAAC,CAAC,CAAC;IAE7E,IAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,CAAC;IACrC,IAAI,CAAC,MAAM,EAAE;QACT,OAAO,kBAAkB,CAAC,QAAQ,CAAC,CAAC;KACvC;IAED,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QACvB,cAAc,CAAC,WAAW,GAAG,iCAAiC,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;KACvF;IAED,IAAI,MAAM,gCAAwB,CAAC;IAEnC,SAAS,SAAS;QACd,OAAO,aAAa,CAAC,MAAM,CAAC,CAAC;IACjC,CAAC;IAED,IAAI,UAAU,GAAG,IAAI,MAAM,CAAI,UAAC,OAAO,EAAE,MAAM;QAC3C,SAAS,QAAQ,CAAC,KAAQ;YACtB,MAAM,iCAAyB,CAAC;YAChC,OAAO,CAAC,KAAK,CAAC,CAAC;QACnB,CAAC;QAED,SAAS,OAAO,CAAC,MAAW;YACxB,MAAM,iCAAyB,CAAC;YAChC,MAAM,CAAC,MAAM,CAAC,CAAC;QACnB,CAAC;QAED,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAEhC,CAAC,CAAgB,CAAC;IAElB,aAAa,CAAC,UAAU,EAAE,OAAO,EAAE;QAC/B,GAAG,EAAE,SAAS;KACjB,CAAC,CAAC;IAEH,OAAO,UAAU,CAAC;AACtB,CAAC;AAED;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,CAAC,IAAM,sBAAsB,GAAoE,iBAAiB,CAAC,mBAAmB,CAAC,CAAC;AAE9I;;;;;;;;;;GAUG;AACH,MAAM,CAAC,IAAM,2BAA2B,GAAmD,sBAAsB,CAAC,mBAAmB,CAAC,CAAC;AAEvI;;;;;;;;;GASG;AACH,MAAM,CAAC,IAAM,2BAA2B,GAA+D,sBAAsB,CAAC,mBAAmB,CAAC,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { createAsyncPromise } from \"./asyncPromise\";\r\nimport { _createAllPromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { dumpObj, lazySafeGetInst, ILazyValue, isFunction, objDefineProp, throwTypeError } from \"@nevware21/ts-utils\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\n\r\nlet _isPromiseSupported: ILazyValue<PromiseConstructor>;\r\n\r\n/**\r\n * Creates a Promise instance that when resolved or rejected will execute it's pending chained operations using the\r\n * available native Promise implementation.\r\n * If runtime does not support native `Promise` class (or no polyfill is available) this function will fallback to using\r\n * `createAsyncPromise` which will resolve them __asynchronously__ using the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * @group Alias\r\n * @group Promise\r\n * @group Native\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createNativePromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T> {\r\n    !_isPromiseSupported && (_isPromiseSupported = lazySafeGetInst(STR_PROMISE));\r\n\r\n    const PrmCls = _isPromiseSupported.v;\r\n    if (!PrmCls) {\r\n        return createAsyncPromise(executor);\r\n    }\r\n\r\n    if (!isFunction(executor)) {\r\n        throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\r\n    }\r\n\r\n    let _state = ePromiseState.Pending;\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    let thePromise = new PrmCls<T>((resolve, reject) => {\r\n        function _resolve(value: T) {\r\n            _state = ePromiseState.Resolved;\r\n            resolve(value);\r\n        }\r\n\r\n        function _reject(reason: any) {\r\n            _state = ePromiseState.Rejected;\r\n            reject(reason);\r\n        }\r\n\r\n        executor(_resolve, _reject);\r\n\r\n    }) as IPromise<T>;\r\n\r\n    objDefineProp(thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    return thePromise;\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group All\r\n * @group Native\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createNativeAllPromise: <T>(input: PromiseLike<T>[], timeout?: number) => IPromise<T[]> = _createAllPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Resolved\r\n * @group Native\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeResolvedPromise: <T>(value: T, timeout?: number) => Promise<T> =  _createResolvedPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Rejected\r\n * @group Native\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeRejectedPromise: <T = unknown>(reason: any, timeout?: number) => Promise<T> = _createRejectedPromise(createNativePromise);\r\n"]}