{"version":3,"file":"IPromise.js","sourceRoot":"","sources":["../../src/interfaces/IPromise.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { FinallyPromiseHandler, RejectedPromiseHandler, ResolvedPromiseHandler } from \"./types\";\r\n\r\n/**\r\n * Create a Promise object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\r\n * This interface definition, closely mirrors the typescript / javascript PromiseLike<T> and Promise<T> definitions as well as providing\r\n * simular functions as that provided by jQuery deferred objects.\r\n *\r\n * The returned Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers\r\n * with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous\r\n * methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point\r\n * in the future.\r\n *\r\n * A Promise is in one of these states:\r\n * <ul>\r\n * <li> pending: initial state, neither fulfilled nor rejected.\r\n * <li> fulfilled: meaning that the operation was completed successfully.\r\n * <li> rejected: meaning that the operation failed.\r\n * </ul>\r\n *\r\n * A pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options happens, the\r\n * associated handlers queued up by a promise's then method are called synchronously. If the promise has already been fulfilled or rejected\r\n * when a corresponding handler is attached, the handler will be called synchronously, so there is no race condition between an asynchronous\r\n * operation completing and its handlers being attached.\r\n *\r\n * As the `then()` and `catch()` methods return promises, they can be chained.\r\n * @typeParam T - Identifies the expected return type from the promise\r\n */\r\nexport interface IPromise<T> extends PromiseLike<T>, Promise<T> {\r\n      \r\n    /**\r\n     * Returns a string representation of the current state of the promise. The promise can be in one of four states.\r\n     * <ul>\r\n     * <li> <b>\"pending\"</b>: The promise is not yet in a completed state (neither \"rejected\"; or \"resolved\").</li>\r\n     * <li> <b>\"resolved\"</b>: The promise is in the resolved state.</li>\r\n     * <li> <b>\"rejected\"</b>: The promise is in the rejected state.</li>\r\n     * </ul>\r\n     * @example\r\n     * ```ts\r\n     * let doResolve;\r\n     * let promise: IPromise<any> = createSyncPromise((resolve) => {\r\n     *  doResolve = resolve;\r\n     * });\r\n     *\r\n     * let state: string = promise.state();\r\n     * console.log(\"State: \" + state);      // State: pending\r\n     * doResolve(true);                     // Promise will resolve synchronously as it's a synchronous promise\r\n     * console.log(\"State: \" + state);      // State: resolved\r\n     * ```\r\n     */\r\n    state?: string;\r\n\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onResolved The callback to execute when the Promise is resolved.\r\n     * @param onRejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     * @example\r\n     * ```ts\r\n     * const promise1 = createPromise((resolve, reject) => {\r\n     *   resolve('Success!');\r\n     * });\r\n     *\r\n     * promise1.then((value) => {\r\n     *   console.log(value);\r\n     *   // expected output: \"Success!\"\r\n     * });\r\n     * ```\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): IPromise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onResolved The callback to execute when the Promise is resolved.\r\n     * @param onRejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     * @example\r\n     * ```ts\r\n     * const promise1 = createPromise((resolve, reject) => {\r\n     *   resolve('Success!');\r\n     * });\r\n     *\r\n     * promise1.then((value) => {\r\n     *   console.log(value);\r\n     *   // expected output: \"Success!\"\r\n     * });\r\n     * ```\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): PromiseLike<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onResolved The callback to execute when the Promise is resolved.\r\n     * @param onRejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     * @example\r\n     * ```ts\r\n     * const promise1 = createPromise((resolve, reject) => {\r\n     *   resolve('Success!');\r\n     * });\r\n     *\r\n     * promise1.then((value) => {\r\n     *   console.log(value);\r\n     *   // expected output: \"Success!\"\r\n     * });\r\n     * ```\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onRejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     * @example\r\n     * ```ts\r\n     * const promise1 = createPromise((resolve, reject) => {\r\n     *   throw 'Uh-oh!';\r\n     * });\r\n     *\r\n     * promise1.catch((error) => {\r\n     *   console.error(error);\r\n     * });\r\n     * // expected output: Uh-oh!\r\n     * ```\r\n     */\r\n    catch<TResult = never>(onRejected?: ((reason: any) => TResult | IPromise<TResult>) | undefined | null): IPromise<T | TResult>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onRejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     * @example\r\n     * ```ts\r\n     * const promise1 = createPromise((resolve, reject) => {\r\n     *   throw 'Uh-oh!';\r\n     * });\r\n     *\r\n     * promise1.catch((error) => {\r\n     *   console.error(error);\r\n     * });\r\n     * // expected output: Uh-oh!\r\n     * ```\r\n     */\r\n    catch<TResult = never>(onRejected?: ((reason: any) => TResult | IPromise<TResult>) | undefined | null): PromiseLike<T | TResult>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onRejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     * @example\r\n     * ```ts\r\n     * const promise1 = createPromise((resolve, reject) => {\r\n     *   throw 'Uh-oh!';\r\n     * });\r\n     *\r\n     * promise1.catch((error) => {\r\n     *   console.error(error);\r\n     * });\r\n     * // expected output: Uh-oh!\r\n     * ```\r\n     */\r\n     catch<TResult = never>(onRejected?: ((reason: any) => TResult | IPromise<TResult>) | undefined | null): Promise<T | TResult>;\r\n \r\n    /**\r\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\r\n     * resolved value cannot be modified from the callback.\r\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\r\n     * @returns A Promise for the completion of the callback.\r\n     * @example\r\n     * ```ts\r\n     * function doFunction() {\r\n     *   return createPromise((resolve, reject) => {\r\n     *     if (Math.random() > 0.5) {\r\n     *       resolve('Function has completed');\r\n     *     } else {\r\n     *       reject(new Error('Function failed to process'));\r\n     *     }\r\n     *   });\r\n     * }\r\n     *\r\n     * doFunction().then((data) => {\r\n     *     console.log(data);\r\n     * }).catch((err) => {\r\n     *     console.error(err);\r\n     * }).finally(() => {\r\n     *     console.log('Function processing completed');\r\n     * });\r\n     * ```\r\n     */\r\n    finally(onfinally?: FinallyPromiseHandler): IPromise<T>\r\n\r\n    /**\r\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\r\n     * resolved value cannot be modified from the callback.\r\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\r\n     * @returns A Promise for the completion of the callback.\r\n     * @example\r\n     * ```ts\r\n     * function doFunction() {\r\n     *   return createPromise((resolve, reject) => {\r\n     *     if (Math.random() > 0.5) {\r\n     *       resolve('Function has completed');\r\n     *     } else {\r\n     *       reject(new Error('Function failed to process'));\r\n     *     }\r\n     *   });\r\n     * }\r\n     *\r\n     * doFunction().then((data) => {\r\n     *     console.log(data);\r\n     * }).catch((err) => {\r\n     *     console.error(err);\r\n     * }).finally(() => {\r\n     *     console.log('Function processing completed');\r\n     * });\r\n     * ```\r\n     */\r\n    finally(onFinally?: FinallyPromiseHandler): Promise<T>;\r\n}\r\n"]}