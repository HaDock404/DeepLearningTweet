{"version":3,"file":"ITaskScheduler.js","sourceRoot":"","sources":["../../src/interfaces/ITaskScheduler.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { IPromise } from \"./IPromise\";\r\nimport { StartQueuedTaskFn } from \"./types\";\r\n\r\n/**\r\n * Defines a Task Scheduler that uses IPromise implementations to serialize the execution of the tasks.\r\n * Each added task will not get executed until the previous task has completed.\r\n * @since 0.2.0\r\n * @group Scheduler\r\n */\r\nexport interface ITaskScheduler {\r\n    /**\r\n     * Identifies if this scheduler is currently idle (`true`) or has waiting or currently processing tasks (`false).\r\n     * @example\r\n     * ```ts\r\n     * let scheduler = createTaskScheduler();\r\n     *\r\n     * // Check idle state\r\n     * scheduler.idle;  // true\r\n     *\r\n     * let queuedTask = scheduler.queue(() => {\r\n     *     // Return a promise\r\n     *     return createPromise((resolve) => {\r\n     *         // Wait some time then resolve\r\n     *     });\r\n     * });\r\n     *\r\n     * // Check idle state\r\n     * scheduler.idle;  // false\r\n     *\r\n     * // Wait for the queued task to complete\r\n     * await queuedTask;\r\n     *\r\n     * // Check idle state\r\n     * scheduler.idle;  // true\r\n     * ```\r\n     */\r\n    readonly idle: boolean;\r\n\r\n    /**\r\n     * Queue a task to be scheduled for execution, once the task has completed the returned IPromise\r\n     * will be resolved / rejected\r\n     * @param theTask - The function to call to start the task\r\n     * @param taskName - The optional task name for the task, useful for debugging.\r\n     * @param timeout - Specify a specific timeout for the task, the timeout will only apply once the task is started.\r\n     * @returns A new promise that will be resolved (or rejected) once the task has been executed or aborted.\r\n     * @example\r\n     * ```ts\r\n     * let scheduler = createTaskScheduler();\r\n     *\r\n     * // Schedule an async task, where the function returns a Promise or PromiseLike result\r\n     * let queuedTask = scheduler.queue(runSomeAsyncTask());\r\n     *\r\n     * // Schedule an async task, where the function returns a Promise or PromiseLike result\r\n     * let queuedTask2 = scheduler.queue(runAnotherAsyncTask());\r\n     *\r\n     * // Both queuedTask and queuedTask2 are Promise implementation (based on the type used by the scheduler)\r\n     * // You can now treat these like any promose to wait for them to be resolve / rejected\r\n     * // Somewhere else in your code using either `await`, `doAwait`, doAwaitResponse`, `doFinally`, `then`, `catch`\r\n     * // or `finally`\r\n     * doAwait(queuedTask, (result1) => {\r\n     *     // queued task 1 is now complete\r\n     *     // queued task 2 is now scheduled to run (or is already running)\r\n     * });\r\n     *\r\n     * doAwait(queuedTask2, (result1) => {\r\n     *     // Both task 1 and 2 have completed\r\n     *     // As task 2 did not start until task 1 finished\r\n     * });\r\n     *\r\n     * // This Will also work and will not cause a deadlock\r\n     * // But task 2 will still not start until task 1 has completed\r\n     * let task2Result = await queuedTask2;\r\n     *\r\n     * // Now get the task 1 response\r\n     * let task1Result = await queuedTask1;\r\n     * ```\r\n     */\r\n    queue: <T>(theTask: StartQueuedTaskFn<T>, taskName?: string, timeout?: number) => IPromise<T>;\r\n\r\n    /**\r\n     * Set the timeout to reject and remove any stale running tasks to avoid filling up memory\r\n     * with blocked tasks.\r\n     * @param staleTimeout - Identifies the maximum that a task can be running or waiting to start,\r\n     * defaults to 10 minutes. If the value is set to zero or less the stale timeout will never\r\n     * abort waiting tasks.\r\n     * @param staleCheckPeriod - Identifes how oftem the queue's should be checked for stale tasks,\r\n     * defaults to 1/10th of the staleTimeout when not specified. This directly sets the asynchronous\r\n     * timeout value.\r\n     * @example\r\n     * ```ts\r\n     * let secheduler = createTaskScheduler();\r\n     *\r\n     * // Set the stale task timeout to 1 second, this will check every 100ms\r\n     * // for any long waiting / executing tasks and \"reject\" them.\r\n     * scheduler.setStaleTimeout(1000);\r\n     *\r\n     * // Set the stale task timeout to 5 minutes (300 seconds), this will check every 1 minute (60 seconds)\r\n     * // for any long waiting / executing tasks and \"reject\" them.\r\n     * scheduler.setStaleTimeout(300000, 60000);\r\n     * ```\r\n     */\r\n    setStaleTimeout: (staleTimeout: number, staleCheckPeriod?: number) => void;\r\n}\r\n"]}