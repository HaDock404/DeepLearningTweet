{"version":3,"file":"DynamicState.js.map","sources":["DynamicState.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { arrForEach, arrIndexOf, dumpObj, newSymbol, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { throwAggregationError } from \"../JavaScriptSDK/AggregationError\";\r\nimport { _DYN_BLK_VAL, _DYN_CANCEL, _DYN_HDLR, _DYN_LENGTH, _DYN_LOGGER, _DYN_NOTIFY, _DYN_PUSH, _DYN_RD_ONLY, _DYN_SET_DF, _DYN_THROW_INTERNAL } from \"../__DynamicConstants\";\r\nvar symPrefix = \"[[ai_\";\r\nvar symPostfix = \"]]\";\r\nexport function _createState(cfgHandler) {\r\n    var _a;\r\n    var dynamicPropertySymbol = newSymbol(symPrefix + \"get\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyReadOnly = newSymbol(symPrefix + \"ro\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyReferenced = newSymbol(symPrefix + \"rf\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyBlockValue = newSymbol(symPrefix + \"blkVal\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyDetail = newSymbol(symPrefix + \"dtl\" + cfgHandler.uid + symPostfix);\r\n    var _waitingHandlers = null;\r\n    var _watcherTimer = null;\r\n    var theState;\r\n    function _useHandler(activeHandler, callback) {\r\n        var prevWatcher = theState.act;\r\n        try {\r\n            theState.act = activeHandler;\r\n            if (activeHandler && activeHandler[dynamicPropertyDetail]) {\r\n                // Clear out the previously tracked details for this handler, so that access are re-evaluated\r\n                arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {\r\n                    detail.clr(activeHandler);\r\n                });\r\n                activeHandler[dynamicPropertyDetail] = [];\r\n            }\r\n            callback({\r\n                cfg: cfgHandler.cfg,\r\n                set: cfgHandler.set.bind(cfgHandler),\r\n                setDf: cfgHandler[_DYN_SET_DF /* @min:%2esetDf */].bind(cfgHandler),\r\n                ref: cfgHandler.ref.bind(cfgHandler),\r\n                rdOnly: cfgHandler[_DYN_RD_ONLY /* @min:%2erdOnly */].bind(cfgHandler)\r\n            });\r\n        }\r\n        catch (e) {\r\n            var logger = cfgHandler[_DYN_LOGGER /* @min:%2elogger */];\r\n            if (logger) {\r\n                // Don't let one individual failure break everyone\r\n                logger[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](1 /* eLoggingSeverity.CRITICAL */, 107 /* _eInternalMessageId.ConfigWatcherException */, dumpObj(e));\r\n            }\r\n            // Re-throw the exception so that any true \"error\" is reported back to the called\r\n            throw e;\r\n        }\r\n        finally {\r\n            theState.act = prevWatcher || null;\r\n        }\r\n    }\r\n    function _notifyWatchers() {\r\n        if (_waitingHandlers) {\r\n            var notifyHandlers = _waitingHandlers;\r\n            _waitingHandlers = null;\r\n            // Stop any timer as we are running them now anyway\r\n            _watcherTimer && _watcherTimer[_DYN_CANCEL /* @min:%2ecancel */]();\r\n            _watcherTimer = null;\r\n            var watcherFailures_1 = [];\r\n            // Now run the handlers\r\n            arrForEach(notifyHandlers, function (handler) {\r\n                if (handler) {\r\n                    if (handler[dynamicPropertyDetail]) {\r\n                        arrForEach(handler[dynamicPropertyDetail], function (detail) {\r\n                            // Clear out this handler from  previously tracked details, so that access are re-evaluated\r\n                            detail.clr(handler);\r\n                        });\r\n                        handler[dynamicPropertyDetail] = null;\r\n                    }\r\n                    // The handler may have self removed as part of another handler so re-check\r\n                    if (handler.fn) {\r\n                        try {\r\n                            _useHandler(handler, handler.fn);\r\n                        }\r\n                        catch (e) {\r\n                            // Don't let a single failing watcher cause other watches to fail\r\n                            watcherFailures_1[_DYN_PUSH /* @min:%2epush */](e);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            // During notification we may have had additional updates -- so notify those updates as well\r\n            if (_waitingHandlers) {\r\n                try {\r\n                    _notifyWatchers();\r\n                }\r\n                catch (e) {\r\n                    watcherFailures_1[_DYN_PUSH /* @min:%2epush */](e);\r\n                }\r\n            }\r\n            if (watcherFailures_1[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                throwAggregationError(\"Watcher error(s): \", watcherFailures_1);\r\n            }\r\n        }\r\n    }\r\n    function _addWatcher(detail) {\r\n        if (detail && detail.h[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n            if (!_waitingHandlers) {\r\n                _waitingHandlers = [];\r\n            }\r\n            if (!_watcherTimer) {\r\n                _watcherTimer = scheduleTimeout(function () {\r\n                    _watcherTimer = null;\r\n                    _notifyWatchers();\r\n                }, 0);\r\n            }\r\n            // Add all of the handlers for this detail (if not already present) - using normal for-loop for performance\r\n            for (var idx = 0; idx < detail.h[_DYN_LENGTH /* @min:%2elength */]; idx++) {\r\n                var handler = detail.h[idx];\r\n                // Add this handler to the collection of handlers to re-execute\r\n                if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {\r\n                    _waitingHandlers[_DYN_PUSH /* @min:%2epush */](handler);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function _trackHandler(handler, detail) {\r\n        if (handler) {\r\n            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];\r\n            if (arrIndexOf(details, detail) === -1) {\r\n                // If this detail is not already listed as tracked then add it so that we re-evaluate it's usage\r\n                details[_DYN_PUSH /* @min:%2epush */](detail);\r\n            }\r\n        }\r\n    }\r\n    theState = (_a = {\r\n            prop: dynamicPropertySymbol,\r\n            ro: dynamicPropertyReadOnly,\r\n            rf: dynamicPropertyReferenced\r\n        },\r\n        _a[_DYN_BLK_VAL /* @min:blkVal */] = dynamicPropertyBlockValue,\r\n        _a[_DYN_HDLR /* @min:hdlr */] = cfgHandler,\r\n        _a.add = _addWatcher,\r\n        _a[_DYN_NOTIFY /* @min:notify */] = _notifyWatchers,\r\n        _a.use = _useHandler,\r\n        _a.trk = _trackHandler,\r\n        _a);\r\n    return theState;\r\n}\r\n//# sourceMappingURL=DynamicState.js.map"],"names":[],"mappings":";;;;AAA4D;AAC1B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}