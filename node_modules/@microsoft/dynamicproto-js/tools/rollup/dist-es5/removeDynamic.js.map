{"version":3,"file":"removeDynamic.js","sourceRoot":"","sources":["../../../../rollup/src/removeDynamic.ts"],"names":[],"mappings":"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","sourcesContent":["import MagicString from 'magic-string';\r\n\r\nexport interface IDynamicProtoRollupOptions {\r\n  tagname?: string,\r\n  comment?:string,\r\n  sourcemap?: boolean\r\n};\r\n\r\nfunction escape(str:string) {\r\n  return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\r\n}\r\n\r\nfunction isSourceMapEnabled(options:any) {\r\n  if (options) {\r\n    return options.sourceMap !== false && options.sourcemap !== false;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// Need to mock this rather than rely on JavaScript String.prototype.padEnd() as it doesn't always\r\n// exists in the build / test infrastructure\r\nfunction padEnd(input:string, len:number, fill:string) {\r\n  let value = input||\"\";\r\n  while (value.length < len) {\r\n    value += fill;\r\n  }\r\n\r\n  if (value.length > len) {\r\n    value = value.substring(0, len);\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction isNullOrWhitespace(value:string) {\r\n  if (value) {\r\n    return value.replace(/\\s/g, \"\").length < 1;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Simple Rush plugin to remove code that is wrapped between specific comments, this is used to\r\n * remove the boilerplate code require by typescript to define methods as prototype level while\r\n * using @ms-dynamicProto project to support minification. This can also be used to remove \"debug\"\r\n * functions from the production code.\r\n */\r\nexport default function dynamicRemove(options:IDynamicProtoRollupOptions = {}) {\r\n  var token = (options || {}).tagname || \"@DynamicProtoStub\";\r\n  var replaceValue = (options || {}).comment || \"// Removed Stub for %function%.\";\r\n  let tokenGroups:Array<number> = [4, 10, 13];\r\n  let funcNameGroup:number = 6;\r\n\r\n  // Because of the test infrastructure (PhamtonJS) the RegEx can't use the \"s\" flag (gis vs gi) or named groups\r\n  const pattern = new RegExp(\"([\\\\t ]*\\\\/\\\\*\\\\*((?!\\\\*\\\\/)(.|\\\\r|\\\\n))*\\\\*\\\\/[\\\\s]*)*(\\\\/\\\\/[\\\\t ]*\" + escape(token) + \"[^\\\\r\\\\n]*(\\\\r\\\\n|\\\\n\\\\r|\\\\r|\\\\n))*[\\\\t ]*([\\\\w]*\\\\.prototype(\\\\.|\\\\[\\\\\\\"|\\\\[\\\\')[\\\\w]*(\\\\\\\"\\\\]|\\\\'\\\\])?)[\\\\t ]*=[\\\\t ]*function[\\\\t ]*\\\\([^\\\\{]*\\\\{[^\\\\/\\\\}\\\\{]*(\\\\{[^\\\\}]*\\\\}[^\\\\/\\\\}\\\\{]*)*(\\\\/[\\\\*\\\\/][\\\\t ]*\" + escape(token) + \"[^\\\\*\\\\r\\\\n]*(\\\\*\\\\/)?(\\\\r\\\\n|\\\\n\\\\r|\\\\r|\\\\n))*[^\\\\}]*\\\\};([\\\\t ]*\\\\/\\\\/[\\\\t ]*\" + escape(token) + \"[^\\\\r\\\\n]*)*\", 'gi');\r\n\r\n  function formatError(token:string, code:string, pos:number, id:string) {\r\n    let lines = code.split(/(?:\\r\\n|\\n\\r|\\r|\\n)/);\r\n    let lineNumber = 0;\r\n    let count = pos;\r\n    while (count > 0) {\r\n      lineNumber ++;\r\n      count = code.lastIndexOf(\"\\n\", count - 1);\r\n    }\r\n  \r\n    let column = 0;\r\n    let lineStart = code.lastIndexOf(\"\\n\", pos);\r\n    if (lineStart != -1) {\r\n      column = (pos - lineStart);\r\n    } else {\r\n      column = pos + 1;\r\n    }\r\n  \r\n    var message = \"Invalid (Unremoved) token [\" + token + \"] found on line [\" + lineNumber + \"], column [\" + column + \"], position [\" + pos + \"] - \" + (id||\"\") + \"\\n\";\r\n  \r\n    let marker = padEnd(\"\", token.length, \"^\");\r\n    let line = lineNumber - 6;\r\n    if (line > 0) {\r\n      message += \" ...\\n\";\r\n    }\r\n  \r\n    count = 0;\r\n    while (count < 10 && line < lines.length-1) {\r\n      count++;\r\n      if (line >= 0) {\r\n        let number = padEnd(\"\" + (line + 1), 4, \" \");\r\n        message += number + \":\" + lines[line] + \"\\n\";\r\n        if (line == lineNumber-1) {\r\n          message += padEnd(\"\", column + 4, \" \") + marker + \"\\n\";\r\n        }\r\n      }\r\n  \r\n      line++;\r\n    }\r\n  \r\n    if (line < lines.length-1) {\r\n      message += \" ...\\n\";\r\n    }\r\n  \r\n    let match;\r\n    let matchCount = 0;\r\n    while ((match = pattern.exec(code))) {\r\n      let funcName = match[funcNameGroup];\r\n      if (!isNullOrWhitespace(funcName)) {\r\n        if (matchCount == 0) {\r\n          message += \"\\nMatch checks\\n\";\r\n        }\r\n\r\n        matchCount++;\r\n        if (match[0].length > 0) {\r\n          message += \"Match \" + matchCount + \" tag Groups for \" + (funcName||\"\") + \"\\n\";\r\n          message += \"--=( Complete Matched Content )=--\\n\";\r\n          message += match[0];\r\n          message += \"\\n--------------------------------\\n\";\r\n          for(let lp = 1; lp < match.length; lp++) {\r\n            if (match[lp]) {\r\n              message += \"\" + lp + \": \" + (match[lp] || \"\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\");\r\n              if ((match[lp]||\"\").indexOf(token) != -1) {\r\n                message += \" <- Contains tag\";\r\n              }\r\n              message += \"\\n\";\r\n            }\r\n          }\r\n          message += \"\\n\";\r\n        }\r\n      }\r\n    }\r\n  \r\n    return message;\r\n  }\r\n\r\n  function replaceToken(code:string, theString:MagicString) {\r\n    let result = false;\r\n    let match;\r\n    while ((match = pattern.exec(code))) {\r\n      let funcName = match[funcNameGroup];\r\n      if (!isNullOrWhitespace(funcName)) {\r\n        // Only remove matches that contain a tag and function\r\n        let hasToken = false;\r\n        for(let lp = 0; lp < tokenGroups.length; lp++) {\r\n          if ((match[tokenGroups[lp]]||\"\").indexOf(token) != -1) {\r\n            hasToken = true;\r\n            break;\r\n          }\r\n        }\r\n  \r\n        if (hasToken) {\r\n          result = true;\r\n          let start = match.index;\r\n          let newValue = replaceValue.replace(\"%function%\", funcName);\r\n          theString.overwrite(start, start + match[0].length, newValue);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function checkResult(result:string, id:string) {\r\n    if (result) {\r\n      let pos = result.indexOf(token);\r\n      if (pos != -1) {\r\n        throw new Error(formatError(token, result, pos, id));\r\n      }\r\n    }\r\n  }\r\n\r\n  function doTransform(code:string, id:string) {\r\n    let theString = new MagicString(code);\r\n    if (!replaceToken(code, theString)) {\r\n      return null;\r\n    }\r\n\r\n    let result:any = { code: theString.toString() };\r\n    if (isSourceMapEnabled(options)) {\r\n      result.map = theString.generateMap({hires: true});\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function doTransformAndCheck(code:string, id:string) {\r\n    let result = doTransform(code, id);\r\n    if (result) {\r\n      // Do a final check of the string\r\n      checkResult(result.code, id);\r\n    } else {\r\n      // Check that the raw input doesn't include the tag\r\n      checkResult(code, id);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    name: 'dynamicRemove',\r\n    renderChunk(code:string, chunk:any) {\r\n      return doTransformAndCheck(code, chunk.filename);\r\n    },\r\n    transform: doTransformAndCheck\r\n  }\r\n}\r\n  \r\n  "]}